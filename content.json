{"meta":{"title":"zhi","subtitle":null,"description":null,"author":"智宏伟","url":"http://zhi.com","root":"/"},"pages":[{"title":"archives","date":"2020-03-22T12:20:19.000Z","updated":"2020-03-22T12:20:19.916Z","comments":true,"path":"archives/index.html","permalink":"http://zhi.com/archives/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-03-22T12:12:08.000Z","updated":"2020-03-22T12:12:08.370Z","comments":true,"path":"tags/index-1.html","permalink":"http://zhi.com/tags/index-1.html","excerpt":"","text":""},{"title":"about me","date":"2020-03-22T12:21:10.000Z","updated":"2021-01-12T02:20:21.519Z","comments":true,"path":"about/index.html","permalink":"http://zhi.com/about/index.html","excerpt":"","text":"关于我GitHub：zhi-hong-wei微信: z1822711079邮箱: zhihw0811@163.com 开源项目 supermall-zhi: 一款女装商城项目，仍有部分功能未实现 black-blue: 本主题源码放送。 商城小程序: 功能较完善，小程序项目 云开发的音乐小程序: 基于原生云音乐小程序开发 基于Vue的后台管理系统: 与云音乐小程序为配套全栈项目 OCR识别:基于canvas实现OCR识别展示 关于小站小站由hexo脚本搭建，配置，部署完成。采用的是黑蓝配组合，喜欢干净简洁，大方的主题风格。"},{"title":"博客圈","date":"2020-03-23T13:39:37.000Z","updated":"2020-03-24T06:22:18.331Z","comments":true,"path":"categories/index.html","permalink":"http://zhi.com/categories/index.html","excerpt":"","text":"静态博客 hexo技能网址 建议收藏 不分排行 简书Hexo专题 sf-Hexo专题 ruby中文网 来必力 valine评论 leanClound Travis Ci OAuth Application 图标下载 cherryblog 禅时雨 轻松入门hexo"},{"title":"标签","date":"2020-03-21T05:13:57.000Z","updated":"2020-03-21T05:16:49.312Z","comments":true,"path":"tags/index.html","permalink":"http://zhi.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"markdown语法","slug":"markdown语法","date":"2020-11-12T06:37:12.000Z","updated":"2020-11-12T07:31:57.883Z","comments":true,"path":"2020/11/12/markdown语法/","link":"","permalink":"http://zhi.com/2020/11/12/markdown语法/","excerpt":"Markdown语法总结笔记神器","text":"Markdown语法总结笔记神器 1、标题一个#是一级标题，二个#是二级标题，以此类推。支持六级标题。 注：标准语法一般在#后跟个空格再写文字，貌似简书不加空格也行。 123456# 这是一级标题## 这是二级标题### 这是三级标题#### 这是四级标题##### 这是五级标题###### 这是六级标题 2、字体1234**这是加粗的文字***这是倾斜的文字*`***这是斜体加粗的文字***~~这是加删除线的文字~~ 3、引用123&gt;这是引用的内容&gt;&gt;这是引用的内容&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容 效果图： 这是引用的内容 这是引用的内容 4、分割线1234-------******** 5、图片1234![图片alt](图片地址 &apos;&apos;图片title&apos;&apos;)图片alt就是显示在图片下面的文字，相当于对图片内容的解释。图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加 6、超链接12[超链接名](超链接地址 &quot;超链接title&quot;)title可加可不加 示例： 12[简书](http://jianshu.com)[百度](http://baidu.com) 如果想在新页面打开： 1234&lt;a href=&quot;超链接地址&quot; target=&quot;_blank&quot;&gt;超链接名&lt;/a&gt;示例&lt;a href=&quot;https://www.jianshu.com/u/1f5ac0cf6a8b&quot; target=&quot;_blank&quot;&gt;简书&lt;/a&gt; 7、列表7.1、有序列表数字加点 123451. 列表内容2. 列表内容3. 列表内容注意：序号跟内容之间要有空格 效果如下： 列表内容 列表内容 列表内容 7.2、无序列表12345- 列表内容+ 列表内容* 列表内容注意：- + * 跟内容之间都要有一个空格 效果如下： 列表内容 列表内容 列表内容 8、表格1234567891011表头|表头|表头---|:--:|---:内容|内容|内容内容|内容|内容第二行分割表头和内容。- 有一个就行，为了对齐，多加了几个文字默认居左-两边加：表示文字居中-右边加：表示文字居右注：原生的语法两边都要用 | 包起来。此处省略 9、代码单行代码：代码之间分别用一个反引号包起来 1`代码内容` 代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行 1​ 代码… 代码… 代码…​12345```## 10、一些特殊语法空格符： 从小到大：小：&amp;nbsp 中：ensp 大：emsp 居中的内容 就像使用html一样，使用标签或者在末尾敲击两个空格，然后回车 我是黑体字我是红色我是5号大小我是黑体，绿色，尺寸为5 --- ### 以上就是比较常用的Markdown语法，日常生活一定够用了，特殊情况请找无所不知的百度大明白！","categories":[],"tags":[{"name":"markdown","slug":"markdown","permalink":"http://zhi.com/tags/markdown/"}]},{"title":"Canvas绘图及描框","slug":"Canvas绘图及描框","date":"2020-07-22T09:15:07.000Z","updated":"2020-07-22T10:51:09.975Z","comments":true,"path":"2020/07/22/Canvas绘图及描框/","link":"","permalink":"http://zhi.com/2020/07/22/Canvas绘图及描框/","excerpt":"canvas绘制图片和画识别框问题canvas知识","text":"canvas绘制图片和画识别框问题canvas知识 前言先说一下业务需求，此处的功能是用于微信OCR文字识别的PC端和小程序端应用。要求上传本地图片后，图片以及识别结果能够展示，为便于测试要求在识别图片上对识别的文字用矩形框及序号框出，与结果一一对应。 记录下此处的实现方法及难点： 1、首先图片显示不要使用img标签，使用canvas来描绘，我们需要得到的是img的宽高属性。小程序使用：wx.getImageInfo，vue中直接new Image() 2、我们要知道两个比例：（1）图片与画布的比例，用于图片自适应画布大小。（2）图片自身缩放比例，用于识别框同比例缩放。 3、计算居中显示的偏移量：（画布-图片）/2；调用canvas的api接口绘图ctx.drawImage 4、根据后台返回的坐标点（原图）进行描框和缩放ctx.strokeRect，对序号框字体进行优化，自适应框的大小，此处小程序和pc不同。 分别附带小程序及vue的完整代码小程序：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135canvasToFile(ctx) &#123; const cWidth = 640, cHeight = 480; console.log(&apos;画布宽：&apos; + cWidth) console.log(&apos;画布高：&apos; + cHeight) wx.getImageInfo(&#123; src: SRC, success: res =&gt; &#123; console.log(res) // 原始图大小 let imgWidth = res.width, imgHeight = res.height; // 相对画布等比例缩放 let n = 1; if (imgWidth &gt; imgHeight) &#123; n = imgWidth / cWidth; imgWidth = cWidth; imgHeight = imgHeight / n; &#125; else &#123; n = imgHeight / cHeight; imgHeight = cHeight; imgWidth = imgWidth / n; &#125; // 图片自身缩放比例 let widthScal = imgWidth / res.width console.log(widthScal) console.log(&apos;imgWidth:&apos; + imgWidth) console.log(&apos;imgHeight:&apos; + imgHeight) console.log(cWidth) console.log(cHeight) let zoom = &#123; width: widthScal, height: widthScal &#125; // 偏移x,y位移量 let right_move = (cWidth - imgWidth) / 2; let bottom_move = (cHeight - imgHeight) / 2; console.log(&apos;right_move:&apos; + right_move) console.log(&apos;bottom_move:&apos; + bottom_move) // 获取预览画布上下文 const c_t_x = wx.createCanvasContext(&apos;canvas_pre&apos;) // 缩放展示画布图片 ctx.scale(0.5, 0.5) ctx.drawImage(SRC, right_move, bottom_move, imgWidth, imgHeight) c_t_x.drawImage(SRC, right_move, bottom_move, imgWidth, imgHeight) ctx.draw() c_t_x.draw() // 画矩形识别框 setTimeout(function() &#123; let value = wx.getStorageSync(&apos;ocr&apos;) if (value.hasOwnProperty(&apos;items&apos;)) &#123; console.log(value) let length = value.items.length let item = value.items for (let i = 0; i &lt; length; i++) &#123; let show = item[i] // 原图坐标 let X1 = show.pos.left_top.x let Y1 = show.pos.left_top.y let X2 = show.pos.right_bottom.x let Y2 = show.pos.right_bottom.y let startPoint = [X1, Y1], endPoint = [X2, Y2]; // console.log(startPoint) // console.log(endPoint) // 等比例缩放坐标 let Num_x = startPoint[0] * zoom.width + right_move let Num_y = startPoint[1] * zoom.height + bottom_move let Num_width = (endPoint[0] - startPoint[0]) * zoom.width let Num_height = (endPoint[1] - startPoint[1]) * zoom.height ctx.setStrokeStyle(&apos;blue&apos;) c_t_x.setStrokeStyle(&apos;blue&apos;) // 分别画两个画布的矩形框 c_t_x.strokeRect(Num_x, Num_y, Num_width, Num_height) ctx.strokeRect(Num_x, Num_y, Num_width, Num_height); // 区分文字横向，竖向展示时，数字框位置 if (Num_width &lt; Num_height) &#123; let top_x = Num_x let top_y = (startPoint[1] - (endPoint[0] - startPoint[0])) * zoom.height + bottom_move let w_h = Num_width ctx.setFontSize(w_h) c_t_x.setFontSize(w_h) ctx.setStrokeStyle(&apos;#006bff&apos;) c_t_x.setStrokeStyle(&apos;#006bff&apos;) ctx.setFillStyle(&apos;#006bff&apos;) c_t_x.setFillStyle(&apos;#006bff&apos;) ctx.fillText(i + 1, Num_x + (w_h / 2), Num_y, w_h) c_t_x.fillText(i + 1, Num_x + (w_h / 2), Num_y, w_h) ctx.strokeRect(top_x, top_y, w_h, w_h) c_t_x.strokeRect(top_x, top_y, w_h, w_h) ctx.setTextAlign(&apos;center&apos;) c_t_x.setTextAlign(&apos;center&apos;) &#125; else &#123; let left_X = (startPoint[0] - (endPoint[1] - startPoint[1])) * zoom.width + right_move let left_Y = Num_y let W_H = Num_height ctx.setFontSize(W_H) ctx.setStrokeStyle(&apos;#006bff&apos;) ctx.setFillStyle(&apos;#006bff&apos;) ctx.fillText(i + 1, left_X + W_H / 2, left_Y + W_H, W_H) ctx.strokeRect(left_X, left_Y, W_H, W_H) ctx.setTextAlign(&apos;center&apos;) c_t_x.setFontSize(W_H) c_t_x.setStrokeStyle(&apos;#006bff&apos;) c_t_x.setFillStyle(&apos;#006bff&apos;) c_t_x.fillText(i + 1, left_X + W_H / 2, left_Y + W_H, W_H) c_t_x.strokeRect(left_X, left_Y, W_H, W_H) c_t_x.setTextAlign(&apos;center&apos;) &#125; &#125; ctx.draw(true) // 导出图片到url数组中，注意像素值 c_t_x.draw(true, setTimeout(function() &#123; let dpr = wx.getSystemInfoSync().pixelRatio console.log(dpr) wx.canvasToTempFilePath(&#123; x: right_move, y: bottom_move, width: imgWidth, height: imgHeight, destWidth: imgWidth * dpr, destHeight: imgHeight * dpr, canvasId: &apos;canvas_pre&apos;, success(res) &#123; console.log(res) url.push(res.tempFilePath) &#125; &#125;) &#125;, 100)); &#125; &#125;, 1200) &#125; &#125;) &#125;, 这里有两个canvas，是因为公司新加的一个需求：点击图片放大预览，同时识别框也要放大。但是在同一画布内使用wx.canvasToTempFilePath导成图片后，预览的图片很模糊，网上也有些方法，但并不起作用。所以我使用两个画布，一个画布展示图片和识别框，另一个定位在屏幕外用于预览图片，预览画布宽高是展示画布的2倍。即可解决模糊问题。 在onload调用该方法并初始化： 1234const ctx = wx.createCanvasContext(&apos;canvas&apos;)ctx.clearRect(0, 0, 320, 240)ctx.draw()this.canvasToFile(ctx) vue中实现：调canvas组件： 1234567891011121314151617181920212223&lt;template&gt; &lt;Canvas @upload=&quot;upload&quot; :result_show=&quot;result_title&quot; :list=&quot;ocr_comm&quot; :show=&quot;loading&quot; :err=&quot;err&quot;&gt;&lt;/Canvas&gt;&lt;/template&gt;&lt;script&gt; import Canvas from &apos;components/HomeChildren/Canvas/Canvas&apos; export default &#123; name: &quot;ocr_comm&quot;, components: &#123; Canvas &#125;, data() &#123; return &#123; CW: &apos;400px&apos;, CH: &apos;400px&apos;, result_title: &apos;通用OCR识别结果&apos;, ocr_comm: [], loading: false, err: false &#125; &#125;, 图片自适应及绘图，使用async解决异步影响： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748async upload(file, canvas) &#123; // console.log(file) if (!file) return; // 加载图标显示 this.loading = true // 图片缩放比例 let widthScal = 0 // 先基于FileReader进行文件的读取 let fileExample = new FileReader(); // console.dir(fileExample) fileExample.readAsDataURL(file); fileExample.onload = ev =&gt; &#123; // 创建新图片 // console.dir(ev) this.IMAGE = new Image(); this.IMAGE.src = ev.target.result; this.IMAGE.onload = () =&gt; &#123; this.IW = this.IMAGE.width; this.IH = this.IMAGE.height; const NCW = parseInt(this.CW); const NCH = parseInt(this.CW); // 重新按照比例计算宽高 let n = 1; if (this.IW &gt; this.IH) &#123; n = this.IW / NCW; this.IW = NCW; this.IH = this.IH / n; &#125; else &#123; n = this.IH / NCH; this.IH = NCH; this.IW = this.IW / n; &#125; this.IL = (NCW - this.IW) / 2; this.IT = (NCH - this.IH) / 2; widthScal = this.IW / this.IMAGE.width; // console.log(zoom.width) // 绘制图片 this.CTX = canvas.getContext(&quot;2d&quot;); // 清空画布 this.CTX.clearRect(0, 0, parseInt(this.CW), parseInt(this.CH)); // 绘制图片 this.CTX.drawImage(this.IMAGE, this.IL, this.IT, this.IW, this.IH); &#125;; &#125; //上传文件 await this.uploadImg(file) this.strokeRect(widthScal) &#125;, 描框代码，这里的序号字体自适应使用字符串拼接形式： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152strokeRect(widthScal) &#123; if (this.ocr_comm.length !== 0) &#123; for (let i = 0; i &lt; this.ocr_comm.length; i++) &#123; // console.log(this.ocr_comm) let show = this.ocr_comm[i] // 原图坐标 // console.log(show) let X1 = show.pos.left_top.x let Y1 = show.pos.left_top.y let X2 = show.pos.right_bottom.x let Y2 = show.pos.right_bottom.y let startPoint = [X1, Y1], endPoint = [X2, Y2]; let Num_x = startPoint[0] * widthScal + this.IL let Num_y = startPoint[1] * widthScal + this.IT let Num_width = (endPoint[0] - startPoint[0]) * widthScal let Num_height = (endPoint[1] - startPoint[1]) * widthScal this.CTX.strokeStyle = &apos;blue&apos;; this.CTX.strokeRect(Num_x, Num_y, Num_width, Num_height); if (Num_width &lt; Num_height) &#123; let top_x = Num_x let top_y = (startPoint[1] - (endPoint[0] - startPoint[0])) * widthScal + this.IT let w_h = Num_width // console.log(w_h) let fontsize=w_h+&apos;px&apos; let fontFamily=&quot;宋体&quot; let Num_font=fontsize+&apos; &apos;+fontFamily this.CTX.font=Num_font this.CTX.strokeStyle = &apos;#006bff&apos; this.CTX.fillStyle = &apos;#006bff&apos; this.CTX.fillText(i + 1, Num_x + (w_h / 2), Num_y, w_h) this.CTX.strokeRect(top_x, top_y, w_h, w_h) this.CTX.textAlign = &apos;center&apos; &#125; else &#123; let left_X = (startPoint[0] - (endPoint[1] - startPoint[1])) * widthScal + this.IL let left_Y = Num_y let W_H = Num_height let fontsize=W_H+&apos;px&apos; let fontFamily=&quot;宋体&quot; let Num_font=fontsize+&apos; &apos;+fontFamily this.CTX.font=Num_font this.CTX.strokeStyle = &apos;#006bff&apos; this.CTX.fillStyle = &apos;#006bff&apos; this.CTX.fillText(i + 1, left_X + W_H / 2, left_Y + W_H, W_H) this.CTX.strokeRect(left_X, left_Y, W_H, W_H) this.CTX.textAlign = &apos;center&apos; &#125; &#125; &#125; else &#123; console.log(&quot;数据未取到&quot;) &#125; &#125;, 上传代码到后台服务器，前端使用api代理解决跨域问题： 123456789101112131415161718192021222324async uploadImg(file) &#123; var forms = new FormData(); forms.append(&apos;file&apos;, file) let config = &#123; headers: &#123;&apos;Content-Type&apos;: &apos;multipart/form-data&apos;&#125; &#125;; await this.$axios.post(&apos;/apidebug_imagequery?action=ocr_comm&apos;, forms, config) .then(res =&gt; &#123; console.log(res); this.loading = false if (res.data.ocrcomm_res.items.length !== 0) &#123; this.ocr_comm = res.data.ocrcomm_res.items console.log(this.ocr_comm) this.err = false &#125; else &#123; this.ocr_comm = [] this.err = true &#125; // resolve(this.ocr_comm) &#125;).catch(err =&gt; &#123; //补充异常处理代码 console.log(err) &#125;) &#125;, 至此！canvas的相关实现就是这些，图片预览仅用于小程序中，解决模糊问题是难点。canvas远比自己想的强大，现在所知也是九牛一毛，以后再会~！","categories":[],"tags":[{"name":"html5","slug":"html5","permalink":"http://zhi.com/tags/html5/"},{"name":"canvas","slug":"canvas","permalink":"http://zhi.com/tags/canvas/"}]},{"title":"节流和防抖","slug":"节流和防抖","date":"2020-06-01T06:10:07.000Z","updated":"2020-06-01T06:35:59.931Z","comments":true,"path":"2020/06/01/节流和防抖/","link":"","permalink":"http://zhi.com/2020/06/01/节流和防抖/","excerpt":"性能优化问题Js知识","text":"性能优化问题Js知识 防抖与节流防抖与节流是前端最基本的优化技巧，实现很简单，为了记录下，可供学习参考。 防抖概念：防抖就是在持续触发事件的时候，只有当不触发事件一段时间后才会执行处理的函数，当触发一次事件后，在规定事件内再次触发， 就会清除上次的定时任务，重新创建定时任务。 实现方式：每次触发事件时设置一个延迟调用方法，并且取消之前的延时调用方法 缺点：如果事件在规定的时间间隔内被不断的触发，则调用方法会被不断的延迟 12345678910111213141516171819//防抖debounce代码：function debounce(fn,delay) &#123; var timeout = null; // 创建一个标记用来存放定时器的返回值 return function (e) &#123; // 每当用户输入的时候把前一个 setTimeout clear 掉 clearTimeout(timeout); // 然后又创建一个新的 setTimeout, 这样就能保证interval 间隔内如果时间持续触发，就不会执行 fn 函数 timeout = setTimeout(() =&gt; &#123; fn.apply(this, arguments); &#125;, delay); &#125;;&#125;// 处理函数function handle() &#123; console.log(&apos;防抖：&apos;, Math.random());&#125; //滚动事件window.addEventListener(&apos;scroll&apos;, debounce(handle,500)); 节流概念：节流就是在持续触发事件的时候，利用标志位进行控制处理函数是否执行，比如为 true 执行，为 false 不执行通过指定间隔时间修改标志位的值即可实现在指定时间内只触发一次处理函数 实现方式：每次触发事件时，如果当前有等待执行的延时函数，则直接return12345678910111213141516171819202122//节流throttle代码：function throttle(fn,delay) &#123; let canRun = true; // 通过闭包保存一个标记 return function () &#123; // 在函数开头判断标记是否为true，不为true则return if (!canRun) return; // 立即设置为false canRun = false; // 将外部传入的函数的执行放在setTimeout中 setTimeout(() =&gt; &#123; // 最后在setTimeout执行完毕后再把标记设置为true(关键)表示可以执行下一次循环了。 // 当定时器没有执行的时候标记永远是false，在开头被return掉 fn.apply(this, arguments); canRun = true; &#125;, delay); &#125;;&#125; function sayHi(e) &#123; console.log(&apos;节流：&apos;, e.target.innerWidth, e.target.innerHeight);&#125;window.addEventListener(&apos;resize&apos;, throttle(sayHi,500)); 总结函数防抖：将多次操作合并为一次操作进行。原理是维护一个计时器，规定在delay时间后触发函数，但是在delay时间内再次触发的话，就会取消之前的计时器而重新设置。这样一来，只有最后一次操作能被触发。函数节流：使得一定时间内只触发一次函数。原理是通过判断是否有延迟调用函数未执行。区别： 函数节流不管事件触发有多频繁，都会保证在规定时间内一定会执行一次真正的事件处理函数，而函数防抖只是在最后一次事件后才触发一次函数。 比如在页面的无限加载场景下，我们需要用户在滚动页面时，每隔一段时间发一次 Ajax 请求，而不是在用户停下滚动页面操作时才去请求数据。这样的场景，就适合用节流技术来实现。","categories":[],"tags":[{"name":"Js","slug":"Js","permalink":"http://zhi.com/tags/Js/"},{"name":"Js封装","slug":"Js封装","permalink":"http://zhi.com/tags/Js封装/"}]},{"title":"Js同步与异步","slug":"JS同步与异步","date":"2020-04-01T04:43:57.000Z","updated":"2020-04-01T05:49:24.871Z","comments":true,"path":"2020/04/01/JS同步与异步/","link":"","permalink":"http://zhi.com/2020/04/01/JS同步与异步/","excerpt":"Js的同步与异步问题Js知识","text":"Js的同步与异步问题Js知识 前言如果有人问你Js的同步异步问题，你该怎么回答？理解一个问题无非是what-why-how，js同步和异步问题是什么–&gt;为什么会产生异步问题–&gt;如何解决。 首先，我们要知道Js是单线程的，同一时间只处理一个任务，这已经成这门语言的核心特征。 同步与异步（重点）同步就是任务放入到队列中后按照顺序执行；异步就是同时进行多个任务。举个例子：比方说你要烧水做菜，如果你先烧水，等着水烧开，再去做菜，这就是同步操作；但如果你边烧着水，同时准备做菜材料，同时进行，这就是异步操作；&nbsp;js单线程是执行同步操作的，但有时也需要异步操作，防止某一块解析时间过长，造成“卡死”情况。那么，js单线程又是如何实现异步的呢? ——是通过事件循环实现“异步”js中，最基础的异步是setTimeout和setInterval函数，还有onclick, ajax等异步操作。 123456 console.log(&apos;1&apos;)setTimeout(function()&#123; console.log(&apos;2&apos;)&#125;,0)console.log(&apos;3&apos;) //输出 1，3，2 promise解决异步问题promise解决嵌套回调的问题，将嵌套的回调函数改成.then()的连缀使用。Promise有这些特征：只能决议一次，决议值只能有一个，决议之后无法改变。任何then中的回调也只会被调用一次。Promise的特征保证了Promise可以解决信任问题。 promise 的使用 首先通过new Promise（function）创建一个promise对象，接收一个函数参数，并且在函数中传入resolve以及reject两个参数； 1234567var p = new Promise(function(resolve, reject)&#123; //做一些异步操作 setTimeout(function()&#123; console.log(&apos;这是一个异步操作&apos;); resolve(&apos;异步操作成功并且结束&apos;); &#125;, 1000); &#125;); then() 接收两个函数，分别是对promise的resolve及reject状态处理的函数，并且处理结束之后返回promise对象 1234567891011121314151617181920212223242526272829303132333435363738function fn1() &#123; console.log(&quot;第一个函数开始执行&quot;); var p = new Promise(function (resolve, reject) &#123; setTimeout(function () &#123; console.log(&apos;第一个函数执行完毕&apos;); resolve(&apos;接下来进入第二个函数&apos;); &#125;, 1000); &#125;); return p; &#125; function fn2(data) &#123; console.log(data); console.log(&apos;第二个函数开始执行&apos;); var p = new Promise(function (resolve, reject) &#123; setTimeout(function () &#123; var num = Math.ceil(Math.random() * 10); // 生成随机数 console.log(num); //num = 0；设置num=0 if (num === 0) &#123; console.log(&apos;第二个函数执行完毕&apos;); resolve(&apos;所有函数执行完毕&apos;); &#125; else&#123; reject(&quot;执行函数2失败&quot;); &#125; &#125;, 2000); &#125;); return p; &#125; fn1() .then(function (data) &#123; return fn2(data); &#125;) .then(function (data) &#123; console.log(data); &#125;) 第一个函数开始执行 第一个函数执行完毕 接下来进入第二个函数 第二个函数开始执行 第二个函数执行完毕 所有函数执行完毕&emsp;&emsp;调用reslove .all() 接收一个函数数组，进行并发操作，并将每个函数的结果以数组的形式返回。.race()接收函数数组，函数先执行完成之后先进入下一个回调函数中。.catch() 当then中出现错误时不会中止整个函数，catch能够获取到错误并进行提示。 这几种方法不做详述啦！会用即可，好了！今天先到这里，我们下期见!","categories":[],"tags":[{"name":"Js","slug":"Js","permalink":"http://zhi.com/tags/Js/"},{"name":"解决异步","slug":"解决异步","permalink":"http://zhi.com/tags/解决异步/"}]},{"title":"Vue双向绑定原理","slug":"Vue双向绑定原理","date":"2020-03-23T05:45:49.000Z","updated":"2020-11-12T07:19:40.375Z","comments":true,"path":"2020/03/23/Vue双向绑定原理/","link":"","permalink":"http://zhi.com/2020/03/23/Vue双向绑定原理/","excerpt":"详述Vue的数据双向绑定原理前端知识","text":"详述Vue的数据双向绑定原理前端知识 Vue实现双向数据绑定的原理就是利用了 Object.defineProperty() 这个方法重新定义了对象获取属性值(get)和设置属性值(set)的操作来实现的。 另一种说法：vue的双向绑定是由数据劫持结合发布者－订阅者模式实现的。（这里不懂没关系，接着往下看…）首先，我们我们需要一个监听器Observer来给所有的属性设置set函数。如果属性发生了变化，就要通知所有的订阅者Watcher。而这些Watcher统一存放在消息订阅器Dep中，这样比较方便统一管理。Watcher接受到来自Dep的通知后就执行相应的操作去更新视图。&nbsp; Observer 监听器的核心代码如下： 1234567891011121314151617181920212223242526272829function observe(data) &#123; if (!data || typeof data !== &apos;object&apos;) &#123; return; &#125; Object.keys(data).forEach(function(key) &#123; // 遍历属性，递归设置set函数 defineReactive(data, key, data[key]); &#125;);&#125;function defineReactive(data, key, val) &#123; observe(val) var dep = new Dep() Object.defineProperty(data, key, &#123; enumerable: true, configurable: true, get: function() &#123; if (Dep.target) &#123; dep.addSub(Dep.target) // 添加watcher &#125; return val &#125;, set: function(newVal) &#123; if (val === newVal) &#123; return; &#125; val = newVal; dep.notify() // 通知dep &#125; &#125;)&#125; 通过调用observe（）函数来递归地给data对象设置set和get函数，在data的属性被get时添加watcher，被set时通知dep，dep的notify会接着通知所有的watcher去执行更新操作。&nbsp;这里需要对defineProperty做一个补充，上述的observe递归过程，在value值为对象时会继续递归，只有当value值是非对象时才return，然后调用definePropery。所以对于data里面的数组arr，vue实际监听的是arr[0]、arr[1]…arr[n]，而不是arr本身。所以对于改变arr的操作，arr[0] = 9这样是可以被监听到的，而arr.push(‘123’)这样是不行的，因为push方法本质上只是改变了arr[n+1]的值，而这个值本身是没有被监听的，即没有设置set函数。vue为了方便我们对数组的操作，对数组的一些常用方法进行额外的封装，即对vue的data的属性的原型赋值为封装层，当我们使用this.arr.push时，根据原型链向上找会先找到封装层的push，而不会使用原生的push。封装层的push做的事情是先触发原生push方法，然后再监听新push的项，再触发消息订阅器dep的notify方法，从而提醒watcher去更新视图。&nbsp; Dep 消息订阅器的核心代码如下： 1234567891011121314function Dep() &#123; this.subs = [] // 订阅者数组&#125;Dep.prototype = &#123; addSub: function(sub) &#123; this.subs.push(sub) &#125;, notify: function() &#123; this.subs.forEach(function(sub) &#123; sub.update() &#125;) &#125;&#125;Dep.target = null 消息订阅器比较简单，就是维护一个subs数组。当监听新属性时把它push进subs数组中，然后dep被通知时触发notify函数，从而触发subs数组中每个watcher的update操作。&nbsp; Watcher1234567891011121314151617181920212223242526function Watcher(vm, exp, cb) &#123; this.cb = cb this.vm = vm this.exp = exp this.value = this.get()&#125;Watcher.prototype = &#123; update: function() &#123; this.run() &#125;, run: function() &#123; var value = this.vm.data[this.exp] var oldVal = this.value if (value !== oldVal) &#123; this.value = value this.cb.call(this.vm, value, oldVal) // 执行更新时的回调函数 &#125; &#125;, get: function() &#123; Dep.target = this var value = this.vm.data[this.exp] // 读取data的属性，从而执行属性的get函数 Dep.target = null return value &#125;&#125; Watcher的主要功能是去触发属性的get函数，从而添加watcher到Dep的subs数组中。另外就是在update()中更新属性的值并触发更新回调函数。使用Watcher的方法如下： 12345var el = document.getElementById(&apos;XXX&apos;)observe(data)new Watcher(vm, exp, function(value) &#123; // vm表示某个实例,exp表示属性名 el.innerHTML = value&#125;) 为了使用时的整洁，我们需要把代码稍微包装下。 SimpleVue1234567891011121314151617181920212223242526272829function SimpleVue (data, el, exp) &#123; var self = this this.data = data Object.keys(data).forEach(function(key) &#123; self.proxyKeys(key) &#125;) observe(data) el.innerHTML = this.data[exp] new Watcher(this, exp, function(value) &#123; el.innerHTML = value &#125;) return this&#125;SimpleVue.prototype = &#123; proxyKeys: function(key) &#123; var self = this Object.defineProperty(this, key, &#123; enumerable: false, configurable: true, get: function() &#123; return self.data[key] &#125;, set: function(newVal) &#123; self.data[key] = newVal &#125; &#125;) &#125;&#125; SimpleVue做的事情就是使用observe递归地给data的每个属性都加上get和set，然后对于要监听的属性exp新建一个Watcher对象去监听。（Watcher对象触发属性exp的get函数从而添加订阅事件到Dep，而且会在属性的update方法里面触发监听回调函数）使用如下： 123456789// html&lt;h1 id=&quot;name&quot;&gt;&#123;&#123;name&#125;&#125;&lt;/h1&gt; //这个&#123;&#123;name&#125;&#125;暂时没用// jsvar el = document.querySelector(&apos;#name&apos;)var selfVue = new SimpleVue(&#123; name: &apos;hello&apos;&#125;, el, &apos;name&apos;)setTimeout(function() &#123; selfVue.name = &apos;123&apos;&#125;, 2000) 需要注意的是SimpleVue原型的proxyKeys是为了将selfVue.data.name这种操作代理为selfVue.name。这下我们就可以直接通过selfVue.name = “XXX”来改变数据了，并且视图也会相应变化。 Compile1234567891011121314151617181920212223242526272829303132nodeToFragement: function(el) &#123; var fragment = document.createDocumentFragment() var child = el.firstChild // 将dom节点移到fragment while(child) &#123; fragment.appendChild(child) child = el.firstChild &#125; return fragment &#125;, compileElement: function(el) &#123; var childNodes = el.childNodes var self = this; [].slice.call(childNodes).forEach(function(node) &#123; var reg = /\\&#123;\\&#123;(.*)\\&#125;\\&#125;/ var text = node.textContent if (self.isTextNode(node) &amp;&amp; reg.test(text)) &#123; self.compileText(node, reg.exec(text)[1]) &#125; if (node.childNodes &amp;&amp; node.childNodes.length) &#123; self.compileElement(node) // 递归遍历子节点 &#125; &#125;); &#125;, compileText: function(node, exp) &#123; var self = this var initText = this.vm[exp] this.updateText(node, initText) new Watcher(this.vm, exp, function(value) &#123; self.updateText(node, value) &#125;) &#125;, compile将dom节点移入DocumentFragment中去，并递归调用compileElement函数来遍历所有子节点，compileText函数创建新的watcher。 1234567891011function SimpleVue (options) &#123; var self = this this.vm = this this.data = options.data Object.keys(this.data).forEach(function(key) &#123; self.proxyKeys(key) &#125;) observe(this.data) new Compile(options.el, this.vm) return this&#125; &nbsp; 好了！以上就是全部内容啦~~希望可以帮到你！！！","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://zhi.com/tags/Vue/"},{"name":"前端","slug":"前端","permalink":"http://zhi.com/tags/前端/"}]},{"title":"小程序开发和Vue组件化开发的使用区别","slug":"小程序与Vue区别","date":"2020-03-21T06:04:46.000Z","updated":"2020-03-24T06:51:53.773Z","comments":true,"path":"2020/03/21/小程序与Vue区别/","link":"","permalink":"http://zhi.com/2020/03/21/小程序与Vue区别/","excerpt":"总结一下二者的共同点和区别前端知识","text":"总结一下二者的共同点和区别前端知识 写了vue项目和小程序，发现二者有许多相同之处，在此想总结一下二者的共同点和区别。 1.生命周期 vue生命周期： 小程序生命周期: 相比之下，小程序的钩子函数要简单得多。vue的钩子函数在跳转新页面时，钩子函数都会触发，但是小程序的钩子函数，页面不同的跳转方式，触发的钩子并不一样。 onLoad: 页面加载一个页面只会调用一次，可以在 onLoad 中获取打开当前页面所调用的 query 参数。 onShow: 页面显示每次打开页面都会调用一次。 onReady: 页面初次渲染完成一个页面只会调用一次，代表页面已经准备妥当，可以和视图层进行交互。 对界面的设置如wx.setNavigationBarTitle请在onReady之后设置。详见生命周期 onHide: 页面隐藏当navigateTo或底部tab切换时调用。 onUnload: 页面卸载当redirectTo或navigateBack的时候调用。 数据请求: 在页面加载请求数据时，两者钩子的使用有些类似，vue一般会在created或者mounted中请求数据，而在小程序，会在onLoad或者onShow中请求数据。 2.数据绑定VUE:vue动态绑定一个变量的值为元素的某个属性的时候，会在变量前面加上冒号：，例：1. &lt;img :src=&quot;imgSrc&quot;/&gt;小程序：绑定某个变量的值为元素属性时，会用两个大括号括起来，如果不加括号，为被认为是字符串。例：1. &lt;image src=&quot;&quot;&gt;&lt;/image&gt; 3.列表渲染两者还是有些相似 vue： 123456789101112131415161. &lt;ul id=&quot;example-1&quot;&gt; 2. &lt;li v-for=&quot;item in items&quot;&gt; 3. &#123;&#123; item.message &#125;&#125; 4. &lt;/li&gt; 5\\. &lt;/ul&gt; 7. var example1 = new Vue(&#123; 8. el: &apos;#example-1&apos;, 9. data: &#123; 10. items: [ 11. &#123; message: &apos;苹果&apos; &#125;, 12. &#123; message: &apos;橘子&apos; &#125; 13. ] 14. &#125; 15. &#125;) 小程序: 123456789101. Page(&#123; 2. data: &#123; 3. items: [ 4. &#123; message: &apos;苹果&apos; &#125;, 5. &#123; message: &apos;橘子&apos; &#125; 6. ] 7. &#125; 8. &#125;) 10. &lt;text wx:for=&quot;&#123;&#123;items&#125;&#125;&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/text&gt; 4.显示与隐藏元素vue中，使用v-if 和v-show控制元素的显示和隐藏 小程序中，使用wx-if和hidden控制元素的显示和隐藏 5.事件处理vue：使用v-on:event绑定事件，或者使用@event绑定事件,例如: 121. &lt;button v-on:click=&quot;counter += 1&quot;&gt;Add 1&lt;/button&gt; 2\\. &lt;button v-on:click.stop=&quot;counter+=1&quot;&gt;Add1&lt;/button&gt; //阻止事件冒泡 小程序中，全用bindtap(bind+event)，或者catchtap(catch+event)绑定事件,例如： 121. &lt;button bindtap=&quot;noWork&quot;&gt;明天不上班&lt;/button&gt; 2. &lt;button catchtap=&quot;noWork&quot;&gt;明天不上班&lt;/button&gt; //阻止事件冒泡 6.数据双向绑定1.设置值 在vue中,只需要再表单元素上加上v-model,然后再绑定data中对应的一个值，当表单元素内容发生变化时，data中对应的值也会相应改变，这是vue非常nice的一点。 12345678910111. &lt;div id=&quot;app&quot;&gt; 2. &lt;input v-model=&quot;reason&quot; placeholder=&quot;填写理由&quot; class=&apos;reason&apos;/&gt; 3. &lt;/div&gt; 5. new Vue(&#123; 6. el: &apos;#app&apos;, 7. data: &#123; 8. reason:&apos;&apos; 9. &#125; 10. &#125;) 但是在小程序中，却没有这个功能。那怎么办呢？ 当表单内容发生变化时，会触发表单元素上绑定的方法，然后在该方法中，通过this.setData({key:value})来将表单上的值赋值给data中的对应值。 下面是代码，可以感受一下: 12345678910111. &lt;input bindinput=&quot;bindReason&quot; placeholder=&quot;填写理由&quot; class=&apos;reason&apos; value=&apos;&#123;&#123;reason&#125;&#125;&apos; name=&quot;reason&quot; /&gt; 2. Page(&#123; 3. data:&#123; 4. reason:&apos;&apos; 5. &#125;, 6. bindReason(e) &#123; 7. this.setData(&#123; 8. reason: e.detail.value 9. &#125;) 10. &#125; 11. &#125;) 当页面表单元素很多的时候，更改值就是一件体力活了。和小程序一比较，vue的v-model简直爽的不要不要的。2.取值 vue中，通过this.reason取值 小程序中，通过this.data.reason取值 7.绑定事件传参在vue中，绑定事件传参挺简单，只需要在触发事件的方法中，把需要传递的数据作为形参传入就可以了，例如： 1234567891. &lt;button @click=&quot;say(&apos;明天不上班&apos;)&quot;&gt;&lt;/button&gt; 2. new Vue(&#123; 3. el: &apos;#app&apos;, 4. methods:&#123; 5. say(arg)&#123; 6. consloe.log(arg) 7. &#125; 8. &#125; 9. &#125;) 在小程序中，不能直接在绑定事件的方法中传入参数，需要将参数作为属性值，绑定到元素上的data-属性上，然后在方法中，通过e.currentTarget.dataset.*的方式获取，从而完成参数的传递，很麻烦有没有… 1234567891. &lt;view class=&apos;tr&apos; bindtap=&apos;toApprove&apos; data-id=&quot;&#123;&#123;item.id&#125;&#125;&quot;&gt;&lt;/view&gt; 2. Page(&#123; 3. data:&#123; 4. reason:&apos;&apos; 5. &#125;, 6. toApprove(e) &#123; 7. let id = e.currentTarget.dataset.id; 8. &#125; 9. &#125;) 8.父子组件通信1.子组件的使用 在vue中，需要： 编写子组件在需要使用的父组件中通过import引入在vue的components中注册在模板中使用 12345678910111213141516171819202122232425262728293031323334353637383940414243444546471. //子组件 bar.vue 2. &lt;template&gt; 3. &lt;div class=&quot;search-box&quot;&gt; 4. &lt;div @click=&quot;say&quot; :title=&quot;title&quot; class=&quot;icon-dismiss&quot;&gt;&lt;/div&gt; 5. &lt;/div&gt; 6\\. &lt;/template&gt; 7. &lt;script&gt; 8. export default&#123; 9. props:&#123; 10. title:&#123; 11. type:String, 12. default:&apos;&apos; 13. &#125; 14. &#125; 15. &#125;, 17. methods:&#123; 18. say()&#123; 19. console.log(&apos;明天不上班&apos;); 20. this.$emit(&apos;helloWorld&apos;) 21. &#125; 22. &#125; 23. &lt;/script&gt; 25\\. // 父组件 foo.vue 26. &lt;template&gt; 27. &lt;div class=&quot;container&quot;&gt; 28. &lt;bar :title=&quot;title&quot; @helloWorld=&quot;helloWorld&quot;&gt;&lt;/bar&gt; 29. &lt;/div&gt; 30\\. &lt;/template&gt; 32. &lt;script&gt; 33. import Bar from &apos;./bar.vue&apos; 34. export default&#123; 35. data:&#123; 36. title:&quot;我是标题&quot; 37. &#125;, 38. methods:&#123; 39. helloWorld()&#123; 40. console.log(&apos;我接收到子组件传递的事件了&apos;) 41. &#125; 42. &#125;, 43. components:&#123; 44. Bar 45. &#125; 46. &lt;/script&gt; 在小程序中，需要：1.编写子组件2.在子组件的json文件中，将该文件声明为组件 1231. &#123; 2. &quot;component&quot;: true 3. &#125; 3.在需要引入的父组件的json文件中，在usingComponents填写引入组件的组件名以及路径 12341. &quot;usingComponents&quot;: &#123; 2. &quot;tab-bar&quot;: &quot;../../components/tabBar/tabBar&quot; 3. &#125; 4.在父组件中，直接引入即可1. &lt;tab-bar currentpage=&quot;index&quot;&gt;&lt;/tab-bar&gt;2.父子组件间通信 在vue中 父组件向子组件传递数据，只需要在子组件通过v-bind传入一个值，在子组件中，通过props接收，即可完成数据的传递，示例: 123456789101112131415161718192021222324252627282930313233341. // 父组件 foo.vue 2. &lt;template&gt; 3. &lt;div class=&quot;container&quot;&gt; 4. &lt;bar :title=&quot;title&quot;&gt;&lt;/bar&gt; 5. &lt;/div&gt; 6\\. &lt;/template&gt; 7. &lt;script&gt; 8. import Bar from &apos;./bar.vue&apos; 9. export default&#123; 10. data:&#123; 11. title:&quot;我是标题&quot; 12. &#125;, 13. components:&#123; 14. Bar 15. &#125; 16. &lt;/script&gt; 18\\. // 子组件bar.vue 19. &lt;template&gt; 20. &lt;div class=&quot;search-box&quot;&gt; 21. &lt;div :title=&quot;title&quot; &gt;&lt;/div&gt; 22. &lt;/div&gt; 23\\. &lt;/template&gt; 24. &lt;script&gt; 25. export default&#123; 26. props:&#123; 27. title:&#123; 28. type:String, 29. default:&apos;&apos; 30. &#125; 31. &#125; 32. &#125; 33. &lt;/script&gt; 子组件和父组件通信可以通过this.$emit将方法和数据传递给父组件。在小程序中 父组件向子组件通信和vue类似，但是小程序没有通过v-bind，而是直接将值赋值给一个变量，如下：1. &lt;tab-bar currentpage=&quot;index&quot;&gt;&lt;/tab-bar&gt;此处， “index”就是要向子组件传递的值在子组件properties中，接收传递的值 123456781. properties: &#123; 2. // 弹窗标题 3. currentpage: &#123; // 属性名 4. type: String, // 类型（必填），目前接受的类型包括：String, Number, Boolean, Object, Array, null（表示任意类型） 5. value: &apos;index&apos; // 属性初始值（可选），如果未指定则会根据类型选择一个 6. &#125; 7. &#125; 子组件向父组件通信和vue也很类似，代码如下: 123456789101112131415161. //子组件中 2. methods: &#123; 3. // 传递给父组件 4. cancelBut: function (e) &#123; 5. var that = this; 6. var myEventDetail = &#123; pickerShow: false, type: &apos;cancel&apos; &#125; // detail对象，提供给事件监听函数 7. this.triggerEvent(&apos;myevent&apos;, myEventDetail) //myevent自定义名称事件，父组件中使用 8. &#125;, 9. &#125; 10. //父组件中 11. &lt;bar bind:myevent=&quot;toggleToast&quot;&gt;&lt;/bar&gt; 12. // 获取子组件信息 13. toggleToast(e)&#123; 14. console.log(e.detail) 15. &#125; 如果父组件想要调用子组件的方法 vue会给子组件添加一个ref属性，通过this.$refs.ref的值便可以获取到该子组件，然后便可以调用子组件中的任意方法，例如： 123451. //子组件 2. &lt;bar ref=&quot;bar&quot;&gt;&lt;/bar&gt; 3. //父组件 4. this.$ref.bar.子组件的方法 小程序是给子组件添加id或者class，然后通过this.selectComponent找到子组件，然后再调用子组件的方法,示例： 123451. //子组件 2. &lt;bar id=&quot;bar&quot;&gt;&lt;/bar&gt; 3. // 父组件 4. this.selectComponent(&apos;#id&apos;).syaHello() 小程序和vue在这点上太相似了… 这些都是我们常用到的知识点，还有不足，以后慢慢改善~~！ 原文地址","categories":[{"name":"小程序","slug":"小程序","permalink":"http://zhi.com/categories/小程序/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://zhi.com/tags/Vue/"},{"name":"小程序","slug":"小程序","permalink":"http://zhi.com/tags/小程序/"}]}]}