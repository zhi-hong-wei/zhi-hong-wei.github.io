{"meta":{"title":"zhi","subtitle":null,"description":null,"author":"智宏伟","url":"http://zhi.com","root":"/"},"pages":[{"title":"about me","date":"2020-03-22T12:21:10.000Z","updated":"2021-01-12T02:20:21.519Z","comments":true,"path":"about/index.html","permalink":"http://zhi.com/about/index.html","excerpt":"","text":"关于我GitHub：zhi-hong-wei微信: z1822711079邮箱: zhihw0811@163.com 开源项目 supermall-zhi: 一款女装商城项目，仍有部分功能未实现 black-blue: 本主题源码放送。 商城小程序: 功能较完善，小程序项目 云开发的音乐小程序: 基于原生云音乐小程序开发 基于Vue的后台管理系统: 与云音乐小程序为配套全栈项目 OCR识别:基于canvas实现OCR识别展示 关于小站小站由hexo脚本搭建，配置，部署完成。采用的是黑蓝配组合，喜欢干净简洁，大方的主题风格。"},{"title":"archives","date":"2020-03-22T12:20:19.000Z","updated":"2020-03-22T12:20:19.916Z","comments":true,"path":"archives/index.html","permalink":"http://zhi.com/archives/index.html","excerpt":"","text":""},{"title":"博客圈","date":"2020-03-23T13:39:37.000Z","updated":"2020-03-24T06:22:18.331Z","comments":true,"path":"categories/index.html","permalink":"http://zhi.com/categories/index.html","excerpt":"","text":"静态博客 hexo技能网址 建议收藏 不分排行 简书Hexo专题 sf-Hexo专题 ruby中文网 来必力 valine评论 leanClound Travis Ci OAuth Application 图标下载 cherryblog 禅时雨 轻松入门hexo"},{"title":"标签","date":"2020-03-21T05:13:57.000Z","updated":"2020-03-21T05:16:49.312Z","comments":true,"path":"tags/index.html","permalink":"http://zhi.com/tags/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-03-22T12:12:08.000Z","updated":"2020-03-22T12:12:08.370Z","comments":true,"path":"tags/index-1.html","permalink":"http://zhi.com/tags/index-1.html","excerpt":"","text":""}],"posts":[{"title":"LeetCode总结","slug":"LeetCode笔记","date":"2021-05-08T08:09:00.000Z","updated":"2021-05-08T08:41:24.130Z","comments":true,"path":"2021/05/08/LeetCode笔记/","link":"","permalink":"http://zhi.com/2021/05/08/LeetCode笔记/","excerpt":"LeetCode笔记","text":"LeetCode笔记 二叉树递归如果从根节点向下进行需要递归一次，若将左右子树作为根节点再向下进行，需要两次递归。一般递归写成单独的函数 递归二部曲： 1.写终止递归条件：if(!root) return null/0; 2.写递归式和递归条件：**先写递归式代表自底向上执行(有return返回值)，后写递归式代表自顶向下执行 1.二叉树最大深度(树的高度)* 12345var maxDepth = function(root) &#123; if(!root) return 0; return Math.max(maxDepth(root.left),maxDepth(root.right)) + 1; //返回的是数值，每次调用加一行&#125;;//O(n)/O(Height),时间复杂度看节点数，空间复杂度看树的高度，一般为O(n)，单支树； 2.平衡二叉树 求一个结点的最大深度本来就要遍历整个结点并求出左右子树的深度，用一个全局的变量看有没有一个结点让flag变成false即可 1234567891011121314151617var isBalanced = function (root) &#123; //后序遍历二叉树（左右根），从底至顶返回子树最大高度 var flag = true; var isBalancedHelper = function (root) &#123; if (!root) return 0; let l = isBalancedHelper(root.left); //树的左子树高度 let r = isBalancedHelper(root.right); if (Math.abs(l - r) &gt; 1) flag = false;//若不平衡，赋为false**** return Math.max(l,r) + 1; //若左右子树平衡，返回当前树的深度，使用它们的高度判断父节点是否平衡 &#125; isBalancedHelper(root); return flag;&#125;;//O(n)/O(n)谨记：1.在求树高的函数内，同时做判断，不能先写求树高函数，再在外面判断，那只是左右各调用一次，求的是左子树高度和右子树高度。2.***必须用flag承接，因为若是在isBalancedHelper函数内直接return，结束的是isBalancedHelper函数，不影响外面函数的返回值，所以外面函数若写死return：true，无论结果如何，都返回true。***面试时犯的错误 3. 二叉树的直径x-543 1234567891011121314151617181920212223242526//就是递归求左右子树高度加和的最大值，看自己方法好些var diameterOfBinaryTree = function(root) &#123; let ans = 1; function getDepth(rootNode)&#123; if(!rootNode) return 0; let l = getDepth(rootNode.left); let r = getDepth(rootNode.right); ans = Math.max(ans,l + r + 1); //左节点高度+右节点高度+1(根节点)=总路径 return Math.max(l,r) + 1;&#125; getDepth(root); return ans - 1;&#125;;**************************************************************************************我的方法：var diameterOfBinaryTree = function (root) &#123; if (!root) return 0 var deepTree = function (root) &#123; //求树的深度 if (!root) return 0; return Math.max(deepTree(root.left), deepTree(root.right)) + 1; &#125; var temp = deepTree(root.left) + deepTree(root.right) //求除根节点的左分支、右分支高度 //对每个节点都进行高度汇总，取最大值。求最大值时类似12，要把上一次求得的值放里比较（temp） return Math.max(temp, diameterOfBinaryTree(root.left), diameterOfBinaryTree(root.right)) &#125;; //O(N)/O(Height)，其中N为二叉树的节点数,Height为树高度； 思路其实和上一个求平衡二叉树的相同，都是在求最大深度的过程中更新一个全局变量。 4. 翻转二叉树-226* 123456789101112131415 var invertTree = function(root) &#123; if(!root) return null; [root.left,root.right] = [invertTree(root.right), invertTree(root.left)]; return root;&#125;;*********************************************************************************************我的方法：var invertTree = function (root) &#123; if (!root) return null; //就算说树非空，后面要是用到root.left或root.right，还是要判断，也是递归边界 let temp = invertTree(root.right); //从下往上遍历的，也可以从上往下，就是交换节点 root.right = invertTree(root.left); root.left = temp return root&#125;;//O(n)/O(n),N为二叉树节点的数目。我们会遍历二叉树中的每一个节点，并在常数时间内交换其两棵子树。空间由递归栈的深度决定，它等于当前节点在二叉树中的高度。在平均情况下，二叉树的高度与节点个数为对数关系，即O(logN)。而在最坏情况下，树形成链状，空间复杂度为 O(N)。 递归目的或返回值：输入一个root为根的树，返回一个以root为根的对称树递归式：左子树 = 以右子树为根的对称右子树 右子树 = 以左子树为根的对称左子树递归边界： root为空直接返回 5.合并二叉树-617 递归目的：输入一个root1,root2,返回一个以root1为根的合并树递归逻辑：root1.val += root2.val递归式：左子树.left = 输入一个root1.left,root2.left，返回一个以root1.left为根的合并树 右子树相同递归边界： root1若为空则返回root2 root2若为空则返回root1(正好与递归边界有所重叠) 执行从上至下，每次递归会生成新的值，不仅仅是完成操作，所以要承接 12345678910var mergeTrees = function(t1, t2) &#123; if(t1 === null) return t2; if(t2 === null) return t1; t1.val = t1.val + t2.val; //val代表树的值，递归条件 t1.left = mergeTrees(t1.left,t2.left); t1.right = mergeTrees(t1.right,t2.right); return t1;&#125;//O(min(m,n))/O(min(m,n))，其中m和n分别是两个二叉树的节点个数;空间：递归调用的层数不会超过较小的二叉树的最大高度，最坏情况下，二叉树的高度等于节点数。//注：递归条件有返回值时，直接左右递归即可，没有返回值时，用左右节点承接。 6.路径总和-112** 123456789101112131415161718192021222324252627282930var hasPathSum = function(root, sum) &#123; if(root === null)&#123; //等同于if(!root)&#123;&#125; return false; &#125; sum -= root.val; if(sum === 0 &amp;&amp; !root.left &amp;&amp; !root.right) return true; return hasPathSum(root.left,sum) || hasPathSum(root.right,sum); //此处要加‘或’符号，因为顺序调用hasPathSum(root.left,sum)/(root.right,sum)时，虽遍历全树，其实判断的只是最后一次调用hasPathSum(root.right,sum)的值，5-8-4-1，返回false，但我们只要一次true就行，所以要用||取值&#125;;//O(n)/O(Height),空间复杂度取决于空间栈的开销，最坏不超过O(n)***************************************************************************************leetcode-113求路径总和II**，要求输出满足条件的路径，存放在数组中，nums.slice()不是很懂。var pathSum = function (root, targetSum) &#123; if (!root) return []; let res = []; //1. 设置结果集 let nums=[]; //2. 存放路径 let dfs = function (node, sum) &#123; if (!node) return []; //3. 终止递归条件 sum -= node.val; nums.push(node.val); if (!node.left &amp;&amp; !node.right &amp;&amp; sum === 0) &#123; res.push(nums.slice()); //重点***需要赋新数组 &#125; dfs(node.left, sum); dfs(node.right, sum); nums.pop(); //剪枝操作，遍历到叶节点，不满足时，逐层向上剪枝 &#125; dfs(root, targetSum); return res;&#125;; 目的：输入一个root,sum,判断能否以该结点为根…递归逻辑：sum - root.val是否等于0该结点为叶子结点，若为0则返回true递归式：若sum已经小于0则不用递归，否则对左右子树进行递归递归边界： root 为空注意sum可以为负值，所以不能用sum&lt;0来结束递归 7. 路径总和 IIIx-437 我的方法： 找所有满足条件的路径，用两个函数递归就可以遍历所有结点。 12345678910111213141516171819202122232425var pathSum = function (root, sum) &#123; var ans = 0; var pathSumHelper = function (root, sum) &#123; if (!root) &#123; //终止递归条件 return; &#125; sum -= root.val; if (sum === 0) &#123; ans += 1; &#125; pathSumHelper(root.left, sum); pathSumHelper(root.right, sum); &#125; var traverse = function (root, sum) &#123; if (!root) return; pathSumHelper(root, sum); //从根节点向下找 traverse(root.left, sum); //改变根节点位置，第二次递归遍历 traverse(root.right, sum); &#125; &lt;&lt;&lt;&lt;&lt;//pathSumHelper(root, sum); //为啥不能这么写，因为调用总函数的话，每次ans会重置，所以另写traverse &lt;&lt;&lt;&lt;&lt;//pathSum(root.left, sum); &lt;&lt;&lt;&lt;&lt;//pathSum(root.right, sum); traverse(root, sum); //也可以使用主函数本身递归 return ans;&#125;; 思路与上一个题类似，上一题必须从根节点开始向下求值，本题可从任一节点向下求值，所以第二次递归遍历是改变根节点位置。 另外一种： 123456789101112var pathSum = function (root, sum) &#123; function pathSumHelper(root, sum) &#123;//以一个结点为根有多少连续的路径可以得到这个sum if (!root) return 0;//注意这里的递归边界 let res = 0; if (root.val === sum) res++; res += pathSumHelper(root.left, sum - root.val) + pathSumHelper(root.right, sum - root.val); return res; &#125; if (!root) return 0; let ans = pathSumHelper(root, sum) + pathSum(root.left, sum) + pathSum(root.right, sum); return ans;&#125;; 其实原理都一样，但是这种写法其实更好的体现了递归的思想，一定要注意这种拿到递归的返回结果返回给一个变量的方法 8.另一个树的子树xx-572 不熟，把功能分成两层，一层为判断两个树是否相等(从根节点开始)，另外一层对树的结点进行遍历(转移到左右节点) 123456789101112var isSubtree = function (s, t) &#123; function isEqual(s,t)&#123; if(!s &amp;&amp; !t) return true; //后面要用到s.left和t.left/right，所以此处要判断是否为空 if(!s || !t)return false; if(s.val === t.val) return isEqual(s.left,t.left) &amp;&amp; isEqual(s.right,t.right);//左右要一起判断，如果分别递归，就是先左子树后右子树。 else return false; &#125; if (!s) return false; //同上面因为只用到s，对s判断，也是终止条件 if (isEqual(s,t)) return true; else return isSubtree(s.left, t) || isSubtree(s.right, t); //此处是从根节点移到左右节点继续判断&#125;;//O(m*n),O(max(d1,d2)),m和n是s和t的节点数，d1和d2是 9.对称二叉树xx-剑指28 和上题类似：创新点在于“将除根节点之外的左右子树当成两棵树比较”和递归传参“(s.left，t.right)” 12345678910var isSymmetric = function(root) &#123; function isSymmetricHelper(s,t)&#123; //将除根节点之外的左右子树当成两棵树比较 if(!s &amp;&amp; !t) return true; if(!s || !t)return false; if(s.val === t.val) return isSymmetricHelper(s.left,t.right) &amp;&amp; isSymmetricHelper(s.right,t.left); //与-判断全符合条件的情况 else return false; &#125; if(!root) return true; return isSymmetricHelper(root.left,root.right);&#125;;O(n)/O(n) 10.二叉树的最小深度-111* 解法1:该方法类似回溯剪枝，就是穷举遍历，迭代找最小值 12345678910111213141516var minDepth = function(root) &#123; var min = 100000000; function traverse(root,depth)&#123;//遍历更新全局变量 if(!root) return 0; //有此判断，下面if不需要 depth += 1; if(!root.left &amp;&amp; !root.right)&#123; min = Math.min(min, depth); return; &#125; // if(root.left)不需要了 traverse(root.left,depth); //****此处depth参数不可以定义，只能传，因为定义的参数只会累加，最后min traverse(root.right,depth); //的值就是找完左节点的高度值。传的参数在每一层函数中值是不同的，例如 //[1,2,3,4,5]，定义是3，传参是2. &#125; if(!root) return 0; traverse(root,0); return min;&#125;; 解法二： 123456789var minDepth = function (root) &#123; if (!root) return 0; let l = minDepth(root.left); let r = minDepth(root.right); //如果左子树或右子树的深度不为 0，即存在一个子树，那么当前子树的最小深度就是该子树的深度+1 //如果左子树和右子树的深度都不为 0，即左右子树都存在，那么当前子树的最小深度就是它们较小值+1 if (l == 0 || r == 0) return l + r + 1; return Math.min(l, r) + 1;&#125;; 也不完全一样，注意对该结点的左结点或右结点为空的情况 11.左叶子之和-404 方法1: 有左孩子，且左孩子为叶节点时累加即可 1234567891011121314var sumOfLeftLeaves = function(root) &#123; if (!root) return 0; let ans = 0; function dfs(root) &#123; //属于前序遍历 if (!root) return 0; if (root.left &amp;&amp; !root.left.left &amp;&amp; !root.left.right) &#123; ans += root.left.val; &#125; dfs(root.left); dfs(root.right); &#125; dfs(root); return ans;&#125;; 方法2: 123456789var sumOfLeftLeaves = function(root) &#123; if(!root) return 0; let ans = 0; if(root.left &amp;&amp; !root.left.left &amp;&amp; !root.left.right)&#123; //左节点存在并为叶子节点时 ans += root.left.val; &#125; ans += (sumOfLeftLeaves(root.left) + sumOfLeftLeaves(root.right)); //ans+=就不会重置ans=0了 return ans;&#125;; 方法2更好的体现了递归的思想 注意是左叶子而不是左孩子 12.最长同值路径xxx-687 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//自底向上执行，有返回值，若root值==左节点值，L+1，否则重置为0，右侧同理var longestUnivaluePath = function (root) &#123; let ans = 0; function helper(root) &#123;//从一个结点开始的最长同值路径长度 if (!root) return 0; //注意因为要递归到底所以不能在这个时候判断相等不相等然后结束递归 let l = helper(root.left); let r = helper(root.right); //递归式在这里 //左右节点和根节点同值情况，感觉少了左节点和根节点同值/右节点和根节点同值情况 l = (root.left &amp;&amp; root.left.val === root.val) ? l + 1 : 0; r = (root.right &amp;&amp; root.right.val === root.val) ? r + 1 : 0; ans = Math.max(ans,l + r); return Math.max(l, r); //递归的功能就是从左子树和右子树中返回一个最长同值路径 &#125; helper(root); return ans;&#125;;*****************************************************************************************我的解法：var longestUnivaluePath = function (root) &#123; let ans = 0; function helper(root) &#123;//从一个结点开始的最长同值路径长度 if (!root) return 0; let maxLorRres = 0 //注意因为要递归到底所以不能在这个时候判断相等不相等然后结束递归 let l = helper(root.left); let r = helper(root.right); //递归式在这里 if (root.left &amp;&amp; root.left.val == root.val &amp;&amp; root.right &amp;&amp; root.right.val == root.val) &#123; ans = Math.max(ans, l + r + 2); &#125; //从左右子树中选择最长的同值路径 if (root.left &amp;&amp; root.left.val == root.val) &#123; maxLorRres = l + 1; &#125; if (root.right &amp;&amp; root.right.val == root.val) &#123; maxLorRres = Math.max(maxLorRres, r + 1); &#125; //从ans与maxLorRres中更新最大值 ans = Math.max(ans, maxLorRres); return maxLorRres; //递归的功能就是从左子树和右子树中返回一个最长同值路径，此处注意 &#125; helper(root); return ans;&#125;; 其实思路与求二叉树的直径和平衡二叉树类似都是在求另外一个子目标的过程中不断更新一个最优值 13.打家劫舍 IIIx-337 这个题是递归的美妙应用 1234567891011121314var rob = function (root) &#123; //递归式：一个结点的最高金额和（目的） = Max(子结点的最高金额之和，孙结点最高金额和 + 自己的金额) if (!root) return 0; let val = root.val; if (root.left) &#123; val += rob(root.left.left); val += rob(root.left.right); &#125; if (root.right) &#123; val += rob(root.right.left); val += rob(root.right.right); &#125; return Math.max(val, rob(root.left) + rob(root.right));&#125;; 14.完全二叉树节点数-222 12345678910111213var countNodes = function (root) &#123; if (!root) return 0; let count = 1; function dfs(root) &#123; if (!root) return 0; if (root.left) count += 1; if (root.right) count += 1; dfs(root.left); dfs(root.right); &#125; dfs(root); return count;&#125;; 15.二叉树的所有路径看回溯-例4 总结 对于可以不从根结点开始的题目，要先抽象出一个简单的从根结点开始的函数，找到与原函数的递推关系，或者是在递归的过程中更新一个全局变量找到最优解 对树进行整体搜索时，不用返回值，查找某一路径或某一条件时有返回值 对于需要求路径的题目，转换为以一个结点为根的深度问题并找到与路径的递推关系 对于既不要求从根结点开始，又求路径的问题，结合以上两者将问题转换为在求深度的过程中更新一个全局变量 层次遍历1.二叉树的层平均值 123456789101112131415161718层次遍历：1、定义空队列。2、根节点入队列。3、while循环（队列不空）。4.获取队列长度用以for循环。5.每次对队头元素判断左右节点是否为空，push进队列。6.最后出队列。var averageOfLevels = function (root) &#123; var q = []; var ans = []; q.push(root); //***推进来的都是节点** while (q.length !== 0) &#123; let sum = 0; let len = q.length; for (let i = 0; i &lt; len; i++) &#123; sum += q[0].val;//注意这个地方下标都为0，因为出队后下标会发生改变，运算使用val if (q[0].left) q.push(q[0].left); if (q[0].right) q.push(q[0].right); q.shift();//队首出队用shift() &#125; ans.push(sum / len); &#125; return ans;&#125;; //O(n)/O(n) 2.找树左下角的值 12345678910111213141516//从右侧入队列var findBottomLeftValue = function (root) &#123; let q = []; q.push(root); let ans = root; while (q.length) &#123; let len = q.length; for (let i = 0; i &lt; len; i++) &#123; ans = q[0]; if (q[0].right) q.push(q[0].right);//注意是从右孩子开始入队 if (q[0].left) q.push(q[0].left); q.shift(); &#125; &#125; return ans.val;&#125;; 3.二叉树的层次遍历102* 1234567891011121314151617181920212223var levelOrder = function (root) &#123; if (!root) return []; let q = []; let ans = []; // 存放遍历结果 q.push(root); let level = 0; // 代表当前层数 while (q.length) &#123; let len = q.length; // 第level层的节点数量 ans[level] = []; // 第level层的遍历结果 for (let i = 0; i &lt; len; i++) &#123; let temp = q.shift(); //由变量保存出来节点，后面就不用q[0]判断 ans[level].push(temp.val); if (temp.left) q.push(temp.left); //（589） if (temp.right) q.push(temp.right); &#125; level++; &#125; return ans; //LeetCode-107若要求从底向上层次遍历的话，只需反转数组即可 //LeetCode-589若要求算N叉树的层次遍历，将上述（589）改为 for (int i = 0; i &lt; node-&gt;children.size(); i++) &#123; // 将节点孩子加入队列，c++的 if (node-&gt;children[i]) que.push(node-&gt;children[i]); &#125;&#125;; //O(n)/O(n) 前中后序遍历1.非递归实现二叉树的前序遍历x12345678910111213前中后遍历：1、定义空栈。2、根节点入栈。3、while循环（栈不空），根节点出栈，右,左子树进栈(注意进栈顺序)。var preorderTraversal = function (root) &#123; let ans = []; let stack = []; if(root) stack.push(root); while (stack.length) &#123; let temp = stack.pop(); //先出栈就要用结点承接，上题层次遍历同理 ans.push(temp.val); if (temp.right) stack.push(temp.right); if (temp.left) stack.push(temp.left); &#125; return ans;&#125;; 先入根结点，再依次遍历是先入右孩子，再入左孩子 2.非递归后序遍历x12345678910111213var postorderTraversal = function (root) &#123; let ans = []; let stack = []; if (root) stack.push(root); while (stack.length) &#123; let temp = stack.pop(); ans.push(temp.val); if (temp.left) stack.push(temp.left); if (temp.right) stack.push(temp.right); &#125; return ans.reverse();&#125;; 先入根结点，再入左孩子，再入右孩子，最后再反转思路与前序类似，就是最后要再反转 3.非递归二叉树的中序遍历*123456789101112131415var inorderTraversal = function(root) &#123; let stack = []; let ans = []; let node = root; while(node || stack.length !== 0)&#123; //开始根节点并不入栈，所以加判断条件node while(node)&#123; stack.push(node); //根节点在这里入栈，不要提前入 node = node.left; //左侧节点全部入栈 &#125; let temp = stack.pop(); ans.push(temp.val); node = temp.right; &#125; return ans;&#125;; 根入栈后一直左孩子入栈，直到入不了了再出栈顶从栈顶的右孩子重复 二叉查找树0.验证二叉搜索树 1234567891011121314var isValidBST = function (root) &#123; //二叉搜索树中序遍历后是递增的数组，判断后一项大于前一项即可 let queue = []; function dfs(root)&#123; if(!root) return; //测试用例1&lt;size&lt;1000 dfs(root.left); queue.push(root.val); dfs(root.right); &#125; dfs(root); for(let i=0;i&lt;queue.length-1;i++)&#123; //使用数组承接和在中序里判断相差不多 if(queue[i]&gt;=queue[i+1]) return false; &#125; return true;&#125;; 1.二叉搜索树的搜索* 1234567//搜索某一结点，先比根节点，再递归比左右树，因为只需找到符合条件的，不必遍历整棵树，所以要return递归函数var searchBST = function (root, val) &#123; if (!root || root.val === val) return root; if (root.val &lt; val) return searchBST(root.right, val); if (root.val &gt; val) return searchBST(root.left, val); return null;&#125;; 2.修剪二叉搜索树 1234567891011121314var trimBST = function(root, L, R) &#123; //目的：返回以一个结点为根的修建后的二叉树 //递归式：若结点值小于要求，则返回以右结点为根修剪后的二叉树 //若结点值大于要求，则返回以左结点为根修剪后的二叉树 //若满足要求，则将左孩子修剪后返回给左孩子，右孩子修剪后返回右孩子 //边界条件：root为空,返回空； if(!root) return null; if(root.val &lt; L) return trimBST(root.right,L ,R );//记得填满参数呀！！！ if(root.val &gt; R) return trimBST(root.left,L ,R ); root.left = trimBST(root.left,L ,R ); root.right = trimBST(root.right, L, R); return root;&#125;;//O(N)，其中N是给定的树的全部节点。我们最多访问每个节点一次。O(N)即使我们没有明确使用任何额外的内存，在最糟糕的情况下，我们递归调用的栈可能与节点数一样大。 注意这是二叉搜索树，左孩子的值都小于根，右孩子的值都大于根，所以若一个结点根的值大于范围，这个结点和右孩子都不能要，反之左孩子都不能要 3.寻找二叉查找树的第 k 小的元素* 12345678910111213141516171819202122232425262728293031var kthSmallest = function(root, k) &#123; //二叉搜索树的两个重要性质 //1.左子树的所有结点比根结点小，右子树的所有结点比根结点打 //2.中序遍历后的数组仍然有序 let ans = 0; let now = 0; function inOrder(root,k)&#123; if(!root) return; inOrder(root.left,k); now += 1;//用来计数是第几个数，由于有序，第几个数就是第几小 if(now === k)&#123; ans = root.val; return; &#125; inOrder(root.right,k); &#125; inOrder(root,k); return ans;&#125;;*********************************************************************************var kthSmallest = function (root, k) &#123; let q=[]; function inroder(root) &#123; //中序排序，存入数组,还是第一种快 if(!root) return; inroder(root.left); q.push(root.val); inroder(root.right); &#125; inroder(root); return q[k-1];&#125; 灵活运用了二叉搜索树的遍历后数组仍然有序的性质，并且运用一个计数来提前结束递归 4. 把二叉搜索树转换为累加树-538 12345678910111213var convertBST = function (root) &#123;//注意执行顺序，右-根-左，使用递归中序的翻转即可。 var sum = 0; function midTra(root) &#123; if(!root) return; midTra(root.right); sum += root.val; root.val = sum; midTra(root.left); &#125; midTra(root); return root;&#125;; 同样灵活运用了二叉搜索树中序遍历有序的性质，右中左遍历得到由大到小的序列，再通过一个变量计数积累和从而进行运算 5.二叉搜索树的最近公共祖先-剑指68I* 123456//二叉搜索树规律：递归+要实现的功能var lowestCommonAncestor = function(root, p, q) &#123; if(root.val &gt; p.val &amp;&amp; root.val &gt; q.val) return lowestCommonAncestor(root.left,p,q); if(root.val &lt; p.val &amp;&amp; root.val &lt; q.val) return lowestCommonAncestor(root.right,p,q); return root;&#125;; 注意返回的是结点，输入的也是结点灵活运用了二叉搜索树的右边大，左边小的性质 6.二叉树的最近公共祖先 x-剑指68II* 12345678910//此题为二叉树* 递归寻找左右子树值，若在左右子树中，返回根节点，若在一棵子树中，返回该递归节点。var lowestCommonAncestor = function(root, p, q) &#123; if(!root || root.val === p.val || root.val === q.val)&#123; //终止条件+*查找条件 return root; &#125; let l = lowestCommonAncestor(root.left,p,q); //l和r代表节点值*，都能找到，代表祖先是根节点 let r = lowestCommonAncestor(root.right,p,q); if(l &amp;&amp; r) return root; //两棵子树中情况 return l ? l : r; //在一颗子树上&#125;; //若查找2/4结点，运行完，l=2,r=null,返回l结点 结点值唯一的条件特别重要其实就是往左右子树找这两个数的过程，对这些值进行一些判断返回答案 7.二叉搜索树的插入 1234567891011var insertIntoBST = function (root, val) &#123; if (root == null) &#123; return new TreeNode(val); //将新节点传给上层函数 &#125; if (val &lt; root.val) &#123; root.left = insertIntoBST(root.left, val); //用节点承接才能加上新节点 &#125; else &#123; root.right = insertIntoBST(root.right, val); &#125; return root; //返回根节点&#125;; 7.将有序数组转换为二叉搜索树x 123456789101112//取中间值赋给新建空结点，再截取数组，递归赋值var sortedArrayToBST = function(nums) &#123; if(nums.length === 0) return null; let len = nums.length; let mid = Math.floor(len/2); //注意js的向下取整，**直接折半** let node = new TreeNode(nums[mid]); //创建一个根节点 let left_nums = nums.slice(0,mid); //分成两个数组 let right_nums = nums.slice(mid + 1); //mid+1除去根节点了 node.left = sortedArrayToBST(left_nums); //递归执行赋给左右子树 node.right = sortedArrayToBST(right_nums); return node;&#125;; js向下取整Math.floor()向上取整Math.ceil()直接运算是带小数的slice方法(m,n)取下标从m至n-1slice(m)取下标为m到结尾的值，若m大于最大下标则返回空数组 8.有序链表转换二叉搜索树 123456789101112131415161718192021222324//多一步链表转数组var sortedListToBST = function (head) &#123; function transe(head)&#123; //该方法链表转数组 if(head instanceof Array) return head; let nums = []; while(head !== null)&#123; nums[nums.length] = head.val; //数组变长赋值，并用val取值 head = head.next; &#125; return nums; &#125; let nums = transe(head); if (nums.length === 0) return null; let len = nums.length; let mid = Math.floor(len / 2); let node = new TreeNode(nums[mid]); let left_nums = nums.slice(0, mid); let right_nums = nums.slice(mid + 1); node.left = sortedListToBST(left_nums); node.right = sortedListToBST(right_nums); return node;&#125;; 跟上一题思路相同，就是转化一下为数组即可 9.两数之和 IV - 输入 BST 1234567891011121314//查找某些值是否存在，存在返回true--使用map存储var findTarget = function(root, k) &#123; let map=new Map(); //定义一个map let flag=false; function inorder(root,k)&#123; //递归中序遍历 if(!root) return false; inorder(root.left,k); if(map.has(k-root.val)) flag=true; map.set(root.val,root.val); //设置下标和值 inorder(root.right,k); &#125; inorder(root,k); return flag;&#125;; 注意map的用法这个题其实是不是二叉搜索树都没有关系，因为有可能左右子树都有 10.二叉搜索树的最小绝对差x 12345678910111213141516//二叉搜索树多考虑中序遍历，遍历完是递增序列，对两相邻元素，只需定义pre变量即可，在根节点处进行逻辑判断var getMinimumDifference = function (root) &#123; let pre; let max = Number.MAX_VALUE; function inorder(root) &#123; if (!root) return null; inorder(root.left); if (pre !== null &amp;&amp; root.val - pre &lt; max) &#123; max = root.val - pre; &#125; pre = root.val; inorder(root.right); &#125; inorder(root); return max;&#125;; 其实就是运用中序遍历的性质即可 11.二叉搜索树中的众数 12345678910111213141516171819202122232425262728//可以中序遍历后存到hash表中，不过多用了一个O(n)的空间，代码量大，重要度小var findMode = function (root) &#123; let ans = [] //输出的承接数组 let temp = 1 //相同元素个数的承载变量 let pre //前一个元素 let count = 1 //计数有多少相同的 function inorder(root) &#123; if (!root) return [] inorder(root.left) //******逻辑处理部分，可单独抽成一个函数****** if (root.val == pre) &#123; //逐个与前一个比较，相同加一，不同重置 count++ &#125; else &#123; count = 1; &#125; pre = root.val //后移一位 if (temp &lt; count) &#123; temp = count ans=[root.val] &#125;else if(temp == count)&#123; ans.push(root.val) &#125; //******逻辑处理部分****** inorder(root.right) &#125; inorder(root); return ans;&#125;; 注意最后一次的记录要再识别一次 链表基础之删除链表 1234567891011121314151617//创建头结点便于删除和返回新链表var removeElements = function (head, val) &#123; //若要判断是否为空，需返回元素本身，不能返回[] let node = new ListNode(); //创建虚拟头节点，指针不动用以返回最后输出结果 let pre = node; //用以移动的指针 let curr = head; //同理 node.next = head; while (curr) &#123; if (curr.val == val) &#123; pre.next = curr.next; curr = pre.next; //删除后当前指针后移 &#125; else &#123; pre=curr; //两指针都后移 curr=curr.next; &#125; &#125; return node.next;&#125;; 链表题多采用：改指针指向、递归、栈、双指针等方式，循环使用while 1.相交链表-160* 12345678910//让a走完a链表后再走b链表，让b走完b链表后再走a链表，会在交点相遇var getIntersectionNode = function(headA, headB) &#123; let a = headA; let b = headB; while(a !== b)&#123; a = (a === null) ? headB : a.next; b = (b === null) ? headA : b.next; &#125; return a;&#125;; 设 A 的长度为 a + c，B 的长度为 b + c，其中 c 为尾部公共部分长度，可知 a + c + b = b + c + a。 当访问 A 链表的指针访问到链表尾部时，令它从链表 B 的头部开始访问链表 B；同样地，当访问 B 链表的指针访问到链表尾部时，令它从链表 A 的头部开始访问链表 A。这样就能控制访问 A 和 B 两个链表的指针能同时访问到交点。 如果不存在交点，那么 a + b = b + a，以下实现代码中 l1 和 l2 会同时为 null，从而退出循环。 2. 反转链表x-剑指24* 递归：x1234567var reverseList = function(head) &#123; if(head === null || head.next === null) return head; let newNode = reverseList(head.next);//实际上这个newNode是为了保存最后一个结点的位置好返回最后的结果 head.next.next = head; head.next = null; return newNode; //返回开始节点-&gt;5&#125;; 递归式： 以下一个结点为开头的结点进行反转然后再改变这一个结点的指针指向 迭代x 123456789101112//往前指即可，三个变量，pre、current、temp保存下一个值var reverseList = function (head) &#123; let prev = null; let curr = head,temp; while (curr) &#123; temp=curr.next; //保存后一个节点值 curr.next=prev; //改变指针指向，反向指 prev=curr; //prev节点后移 curr=temp; //curr节点后移 &#125; return prev;&#125;; 3.合并两个有序链表** 123456789101112//递归比较开始节点值，若l1小，l1.next=递归(l1.next,l2),反之l2.next=...var mergeTwoLists = function(l1, l2) &#123; if(l1 === null) return l2; //这里的l1和l2仅代表一个节点 if(l2 === null) return l1; if(l1.val &lt; l2.val)&#123; l1.next = mergeTwoLists(l1.next,l2); return l1; &#125;else&#123; l2.next = mergeTwoLists(l1,l2.next); return l2; &#125;&#125;; 一种排序的新思路，因为指针只需要改变指向即可，所以在这里用这种递归改变指针的方法就会更快不需要新创建结点 4.删除排序链表中的重复元素xx 很妙的递归解法： 1234567891011121314151617181920var deleteDuplicates = function (head) &#123; if (!head || !head.next) return head; head.next = deleteDuplicates(head.next); if (head.val === head.next.val) head.next = head.next.next; return head;&#125;;*************************************************************************************//迭代算法var deleteDuplicates = function (head) &#123; if (!head || !head.next) return head; let current = head; while (current != null &amp;&amp; current.next != null) &#123; if (current.val == current.next.val) &#123; current.next = current.next.next; &#125; else &#123; current = current.next; &#125; &#125; return head;&#125;;//也可以快慢指针 若从程序执行的角度考虑就是递归到最后一个结点然后往回进行对比，递归解决链表的问题可以很好的解决由于指针的指向问题的改变引发的问题因为是从后往前进行修改若从递归的角度看：递归式就是将本次的next改为以下一个指针开头的不重复排序链表，然后对比这个结点的值和这个不重复链表的开头的结点的值返回结果。递归的思考方式只需要考虑递归式 5.删除链表的倒数第N个节点xx* 1234567891011121314151617//我们可以设想假设设定了双指针 p 和 q 的话，当 q 指向末尾的 NULL，p 与 q 之间相隔的元素个数为 n 时，那么删除掉 p 的下一个指针就完成了要求。var removeNthFromEnd = function (head, n) &#123; if(!head) return head let preHead = new ListNode(0) //创建头结点 preHead.next = head //头结点指向开始节点，**关键** let p = preHead, q = preHead for (let i = 0; i &lt; n + 1; i++) &#123; //q指针后移n+1位置 q=q.next &#125; while(q)&#123; //p,q一起后移到q==null，此时p后面的即为要删除的元素 p=p.next q=q.next &#125; p.next=p.next.next //改变指针指向 let returnHead=preHead.next //将新的链表赋给新节点 return returnHead&#125;; 利用双指针找到要删除的结点的前一个结点进行删除，若删除的是头结点可以特判 6.两两交换链表中的节点 12345678//类似4，递归法var swapPairs = function(head) &#123; if (!head || !head.next) return head; //!head代表没节点，!head.next代表只有一个节点 let newHead=head.next //原链表第二个节点存起来 head.next=swapPairs(newHead.next) //新链表第二个节点指向递归内容（原链表第二个节点的后一节点），递归位置不能变，递归写在前面代表从后向前执行 newHead.next=head //新链表第一个结点指向原链表第一个结点，写在递归之后 return newHead //这是新返回的第一个节点&#125;; 和前面的题的递归思路很想，也可以用迭代重新生成一个链的方式来解决 7.链表求和 123456789101112131415161718192021222324252627//使用栈空间，因为要逆序运算var addTwoNumbers = function (l1, l2) &#123; let stack1 = []; let stack2 = []; let carry = 0; //进制，非0即1 let dummy = new ListNode();//头结点，传不传0都可** while (l1) &#123; stack1.push(l1.val); //节点值入栈**，注意val l1 = l1.next; &#125; while (l2) &#123; stack2.push(l2.val); //节点值入栈** l2 = l2.next; &#125; //进行相加 while (stack1.length || stack2.length || carry) &#123; //carry为1的话，也要再执行一次，例[5][5]** let stack1Num = stack1.pop() || 0;//解决个数不匹配问题 let stack2Num = stack2.pop() || 0; let current = (stack1Num + stack2Num + carry) % 10; carry = Math.floor((stack1Num + stack2Num + carry) / 10); let newNode = new ListNode(current); //current为节点值，创建一个节点值为current的节点 newNode.next = dummy.next; //注意用头插法插入结点保证顺序，两步走** dummy.next = newNode; &#125; return dummy.next;&#125;; 使用栈来进行逆序的运算的思想 8.回文链表xx 1234567891011121314151617181920212223242526272829303132333435363738var isPalindrome = function (head) &#123; //递归反转链表 function reverseList(head)&#123; let pre = null; let next = null; while(head)&#123; next = head.next head.next = pre; pre = head; head = next &#125; return pre; &#125; function cut(head,cutNode)&#123;//cut一个list while(head.next != cutNode)&#123; head = head.next; &#125; head.next = null; &#125; function isEqual(head1,head2)&#123;//判断两个list是否相等 while(head1 &amp;&amp; head2)&#123; if(head1.val != head2.val) return false; head1 = head1.next; head2 = head2.next; &#125; return true; &#125; if(head === null || head.next === null) return true; //找到要cut的结点即中间的结点！！！ let fast = head; let slow = head; while(fast &amp;&amp; fast.next)&#123; fast = fast.next.next; slow = slow.next; &#125; cut(head,slow); return isEqual(head,reverseList(slow))&#125;; 一定要注意怎么去找的cut的结点，通过快指针比慢指针快一步的这种方法：对于奇数个的链表fast会指向最后一个结点，slow会指向中间的结点对于偶数个的链表fast会指向null, slow会指向中间偏右一个的结点 是把cutnode的前一个结点的next设置为null,从而让前半部分保持正序 后半部分是先以slow为起点，但是反转了过后就是以尾为起点 在比较两个list的时候只比较相同的个数所以不用管奇数个结点时多出来的那一个结点9.分隔链表xxx12345678910111213141516171819202122232425262728293031323334var splitListToParts = function(root, k) &#123; let ans = []; function helper(root,length,k)&#123; if(k === 0) return; if(length === 0)&#123; ans.push(null); helper(root,length,k-1); return; &#125;else&#123; //要分的个数 let temp = Math.ceil(length/k); let newNode = root; let head = newNode; let i = 1; while(i &lt;= temp - 1)&#123;//剪下来这一段 root = root.next; i++; &#125; let next = root.next; root.next = null;//直接剪下来就好不需要重新生成 ans.push(newNode); helper(next,length - temp,k-1); &#125; &#125; //求出链表的长度 let p = root; let length = 0; while(p)&#123; length++; p = p.next; &#125; helper(root,length,k); return ans;&#125;; 10.奇偶链表xx-328 1234567891011121314var oddEvenList = function(head) &#123; if(!head) return head; let odd = head; let even = head.next; let temp = even; while(even &amp;&amp; even.next)&#123; odd.next = odd.next.next; odd = odd.next; even.next = even.next.next; even = even.next; &#125; odd.next = temp;//最后连接奇数表和偶数表 return head;&#125;; 11.链表中间结点* 12345678910//思路和判断链表是否有环一样：双指针法var middleNode = function (head) &#123; //快指针每次两格，慢指针每次一格，快指针到尾，慢指针正好中间 let slow = head, fast = head while (fast &amp;&amp; fast.next) &#123; slow = slow.next fast = fast.next.next &#125; return slow&#125;; 队列和栈1.用栈实现队列x*-232 123456789101112131415161718192021222324252627//都是调用数组方法来实现栈和队列不同的特性，如pop(),push(),shift(),没有peek()/** * Initialize your data structure here. */var MyQueue = function() &#123; this.stack1 = []; //都用this指向** this.stack2 = [];&#125;;MyQueue.prototype.push = function(x) &#123; this.stack1.push(x);&#125;;MyQueue.prototype.pop = function() &#123; if(this.stack2.length !== 0) return this.stack2.pop(); //stack2不空，删除并返回栈顶 while(this.stack1.length !== 0) this.stack2.push(this.stack1.pop()); //栈为空先加入，再返回 return this.stack2.pop();&#125;;MyQueue.prototype.peek = function() &#123; if(this.stack2.length !== 0) return this.stack2[this.stack2.length - 1];//若stack2有元素则返回最后一个元素 else return this.stack1[0];//否则直接返回stack1的第一个元素即可&#125;;MyQueue.prototype.empty = function() &#123; return this.stack1.length === 0 &amp;&amp; this.stack2.length == 0; &#125;; 用两个栈，把第一个栈依次出栈到第二个栈实现顺序的改变从而实现先入先出 2.用队列实现栈x*-225123456789101112131415161718192021222324252627282930313233343536373839404142/** * Initialize your data structure here. */var MyStack = function() &#123;this.queue1=[];this.queue2=[];&#125;;/** * Push element x onto stack. * @param &#123;number&#125; x * @return &#123;void&#125; */MyStack.prototype.push = function(x) &#123;this.queue1.push(x);&#125;;/** * Removes the element on top of the stack and returns that element. * @return &#123;number&#125; */MyStack.prototype.pop = function() &#123;if(this.queue1.length!=0) return this.queue1.pop();else return this.queue2.shift(); &#125;;/** * Get the top element. * @return &#123;number&#125; */MyStack.prototype.top = function() &#123;if(this.queue1.length!=0) return this.queue1[this.queue1.length-1];else return this.queue2[0];&#125;;/** * Returns whether the stack is empty. * @return &#123;boolean&#125; */MyStack.prototype.empty = function() &#123;return this.queue1.length==0&amp;&amp;this.queue2.length==0&#125;; 入队后把每一个其他值都出队再入队 3.最小栈xx*123456789101112131415161718192021222324252627282930313233343536373839404142/** * initialize your data structure here. */var MinStack = function() &#123; this.minStack = []; this.stack = []; this.min = Number.MAX_SAFE_INTEGER;//最大安全值&#125;;/** * @param &#123;number&#125; x * @return &#123;void&#125; */MinStack.prototype.push = function(x) &#123; this.min = Math.min(x,this.min); this.minStack.push(this.min); this.stack.push(x);&#125;;/** * @return &#123;void&#125; */MinStack.prototype.pop = function() &#123; this.minStack.pop(); this.stack.pop(); let len = this.minStack.length; this.min = len !== 0 ? this.minStack[len - 1] : Number.MAX_SAFE_INTEGER;&#125;;/** * @return &#123;number&#125; */MinStack.prototype.top = function() &#123; return this.stack[this.minStack.length - 1];&#125;;/** * @return &#123;number&#125; */MinStack.prototype.getMin = function() &#123; return this.min;&#125;; 用两个栈去实现，一个栈正常放数，另外一个栈每次push的时候都存放栈中的最小值。pop的时候就更新最小值为minStack的栈顶元素即可，若全都pop了要重置最小值Number.MAX_SAFE_INTEGER代表了最大的安全值 4.有效的括号-20* 1234567891011121314var isValid = function (s) &#123; if (s.length % 2 === 1) return false let stack = [] for (let i = 0; i &lt; s.length; i++) &#123; if (s[i] == &apos;(&apos; || s[i] == &apos;&#123;&apos; || s[i] == &apos;[&apos;) stack.push(s[i]) //字符串可直接s[i]获取元素 else &#123; let newTop = stack[stack.length-1] //获取栈顶元素，先不出栈 if(newTop==&apos;&#123;&apos;&amp;&amp;s[i]==&apos;&#125;&apos;||newTop==&apos;(&apos;&amp;&amp;s[i]==&apos;)&apos;||newTop==&apos;[&apos;&amp;&amp;s[i]==&apos;]&apos;)&#123; stack.pop() //如果匹配就出栈 &#125;else return false //不匹配返回false &#125; &#125; return stack.length==0 //最后栈为空，就是匹配完全，返回真&#125;; 5.滑动窗口最大值* 123456789101112131415161718192021222324252627//不推荐这种var maxSlidingWindow = function (nums, k) &#123; //自己的解法，有点复杂,不可取 if(!nums.length) return [] //此处也可以写成nums.length===0，但不可以写nums===[]，会报 let ans = [] // undefined let curr=[] for(let i=0;i&lt;nums.length-k+1;i++)&#123; //此处可以写成i&lt;=nums.length-k curr=[] for(let j=i;j&lt;k+i;j++)&#123; //slice方法截取方便 curr.push(nums[j]) &#125; curr.sort((a,b)=&gt;&#123; //Math.max获取最大值方便 return a-b &#125;) ans.push(curr[k-1]) &#125; return ans&#125;;******************************************************************************//通过slice函数截取数组部分值，用math.max取最大值，值得借鉴var maxSlidingWindow = function (nums, k) &#123; if (!nums.length) return [] let res = [] for (let i = 0; i &lt;= nums.length - k; i++) &#123; res.push(Math.max(...nums.slice(i, k + i))) &#125; return res&#125;; 6.每日温度x 1234567891011121314151617181920212223242526272829常规方法：双层循环var dailyTemperatures = function (T) &#123; let result = new Array(T.length).fill(0);//注意给一个初始化解决有一些为0的问题 for (let i = 0; i &lt; T.length; i++) &#123; let current = T[i]; for (let j = i + 1; j &lt; T.length; j++) &#123; if (T[j] &gt; current) &#123; result[i] = j - i; break; //一定要结束循环，才能取到第一个大于current的数 &#125; &#125; &#125; return result;&#125;;*****************************************************************************************栈方法：var dailyTemperatures = function (T) &#123; let stack = []; let ans = new Array(T.length).fill(0);//注意给一个初始化解决有一些为0的问题 for(let i=0;i&lt;T.length;i++)&#123; //使用peek()无效，peek需要自己写方法实现 while (stack.length !== 0 &amp;&amp; T[stack[stack.length-1]] &lt; T[i]) &#123; let idx = stack.pop(); //后一位&gt;前一位，出栈，直到不大于时，后一位进栈 ans[idx] = i - idx; //下标相减 &#125; stack.push(i); //栈中存入下标***注意是下标 &#125; return ans;&#125;; 用一个栈去存储T的下标维持一个递增栈若比栈顶的元素对应的温度大就要让它出栈，并且序号之差就是相隔的距离 7.下一个更大元素 IIx 1234567891011121314var nextGreaterElements = function (nums) &#123; let stack = []; let len = nums.length; let ans = new Array(len).fill(-1); for (let i = 0; i &lt; 2 * len; i++) &#123;********** let index = i % len;//注意要取余数********* while (stack.length !== 0 &amp;&amp; nums[stack[stack.length - 1]] &lt; nums[index]) &#123; //stack存储下标值 let idx = stack.pop(); ans[idx] = nums[index]; &#125; stack.push(index); &#125; return ans;&#125;; 思路和上一个题相似，就是要遍历数组长度2倍，下标取余即可 8.逆波兰表达式求值 12345678910111213141516171819202122232425//逆波兰表达式是后缀表达式，本题要将其转成中缀表达式var evalRPN = function (tokens) &#123; let stack = []; for (let i of tokens) &#123; switch (i) &#123; case &quot;+&quot;: stack.push(stack.pop() + stack.pop()); break; case &apos;-&apos;: let sub = stack.pop(); stack.push(stack.pop() - sub); break; case &apos;/&apos;: let divider = stack.pop(); stack.push(parseInt(stack.pop() / divider,10)); //10 代表10进制,最好用Math.floor() break; case &apos;*&apos;: stack.push(stack.pop() * stack.pop()); break; default: stack.push(parseInt(i)); &#125; &#125; return stack.pop();&#125;; 注意： switch的语法 注意除法和减法的顺序 JS中floor会向下保留整数，比如-1.2变成-2，ceil向上保留整数比如1.2-2 如果只是单纯保留整数部分就直接用parseInt即可parseInt(数字或字符串，进制)，注意默认不为10进制** 9.长度最小的子数组* 123456789101112队列相加（也叫滑动窗口法），思想：逐个加入队列，直到满足条件，再逐个剔除，直到不满足条件时，再逐个往里加。var minSubArrayLen = function (s, nums) &#123; //使用两个指针，长度取指针差值，再求最小 let first = 0, end = 0, sum = 0, min = nums.length + 1 //min不存在情况 while (end &lt; nums.length) &#123; sum += nums[end++] //进入队列的加和 while (sum &gt;= s) &#123; //由题意：是 &gt;= min = Math.min(min, end - first) sum -= nums[first++] //大于s后，出队列找最短大于s值 &#125; &#125; return min == (nums.length + 1) ? 0 : min&#125;; //O(n)、O(1)使用指针不必额外数组空间 10.无重复字符的最长子串** 1234567891011121314//滑动窗口var lengthOfLongestSubstring = function (s) &#123; let ans = 0 let arr = [] for (let i = 0; i &lt; s.length; i++) &#123; let index = arr.indexOf(s[i]) if (index !== -1) &#123; //找到相同元素，删除重复元素及之前的元素 arr.splice(0, index + 1) &#125; arr.push(s[i]) //要在删除相同元素的操作后推进 ans = Math.max(ans, arr.length) &#125; return ans&#125;; 11.螺旋矩阵II 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748var generateMatrix = function (n) &#123; let res=new Array(n); //定义二维数组 for(let i=0;i&lt;n;i++)&#123; res[i]=new Array(n); &#125; let startx = 0, starty = 0; // 定义每循环一个圈的起始位置 let loop = Math.floor(n / 2); // 每个圈循环几次，例如n为奇数3，那么loop = 1 只是循环一圈，矩阵中间的值需要单独处理 let mid = Math.floor(n / 2); // 矩阵中间的位置，例如：n为3， 中间的位置就是(1，1)，n为5，中间位置为(2, 2) let count = 1; // 用来给矩阵中每一个空格赋值 let offset = 1; // 需要控制每一条边遍历的长度，第一圈最右的1个不遍历，左闭右开。 let i, j; while (loop&gt;0) &#123; loop--; i = startx; j = starty; // 下面开始的四个for就是模拟转了一圈 // 模拟填充上行从左到右(左闭右开) for (j = starty; j &lt; starty + n - offset; j++) &#123; res[startx][j] = count++; &#125; // 模拟填充右列从上到下(左闭右开) for (i = startx; i &lt; startx + n - offset; i++) &#123; res[i][j] = count++; &#125; // 模拟填充下行从右到左(左闭右开) for (; j &gt; starty; j--) &#123; res[i][j] = count++; &#125; // 模拟填充左列从下到上(左闭右开) for (; i &gt; startx; i--) &#123; res[i][j] = count++; &#125; // 第二圈开始的时候，起始位置要各自加1， 例如：第一圈起始位置是(0, 0)，第二圈起始位置是(1, 1) startx++; starty++; // offset 控制每一圈里每一条边遍历的长度 offset += 2; &#125; // 如果n为奇数的话，需要单独给矩阵最中间的位置赋值 if (n % 2==1) &#123; res[mid][mid] = count; &#125; return res;&#125;; Hash1.数组中两个数的和为给定值* 1234567891011var twoSum = function (nums, target) &#123; let map = new Map(); for (let i = 0; i &lt; nums.length; i++) &#123; let temp = map.get(target - nums[i]); if (temp !== undefined &amp;&amp; temp != i ) &#123; return new Array(temp, i); &#125; map.set(nums[i], i); &#125;&#125;;注：看双指针第一题 1.1三数之和** 1234567891011121314151617181920212223242526//双指针：定住一个，左右指针遍历，再求和判断是否满足条件var threeSum = function(nums) &#123; let ans = []; if(nums.length &lt; 3) return ans; nums.sort((a, b) =&gt; a - b); // 排序 const len = nums.length; for (let i = 0; i &lt; len ; i++) &#123; //定住的元素就是for每次循环的值 if(nums[i] &gt; 0) break; // 如果当前数字大于0，则三数之和一定大于0，所以结束循环 if(i &gt; 0 &amp;&amp; nums[i] == nums[i-1]) continue;//将定住的元素去重，满足三个元素对数组重复元素仅使用一次 let L = i+1; let R = len-1; while(L &lt; R)&#123; const sum = nums[i] + nums[L] + nums[R]; if(sum == 0)&#123; ans.push([nums[i],nums[L],nums[R]]);//推入数组形式注意([]) while (L&lt;R &amp;&amp; nums[L] == nums[L+1]) L++; // 左指针元素去重，遍历过的就不遍历了 while (L&lt;R &amp;&amp; nums[R] == nums[R-1]) R--; // 右指针去重，满足题意：避免重复三元组 L++; R--; &#125; else if (sum &lt; 0) L++; else if (sum &gt; 0) R--; &#125; &#125; return ans;&#125;; 1.2四数之和 123456789101112131415161718192021222324252627var fourSum = function (nums, target) &#123; //就是比三数多一层for循环和去重，依次5数之和，6数之和都能求 let ans = []; if (nums.length &lt; 4) return ans; nums.sort((a, b) =&gt; a - b); // 排序 const len = nums.length; for (let i = 0; i &lt; len; i++) &#123; if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) continue; //定住两个元素，遍历左右指针 for (let k = i + 1; k &lt; len; k++) &#123; if (k &gt; i + 1 &amp;&amp; nums[k] == nums[k - 1]) continue; let L = k + 1; let R = len - 1; while (L &lt; R) &#123; const sum = nums[i] + nums[k] + nums[L] + nums[R]; if (sum == target) &#123; ans.push([nums[i], nums[k], nums[L], nums[R]]);//推入数组形式注意([]) while (L &lt; R &amp;&amp; nums[L] == nums[L + 1]) L++; // 左指针元素去重 while (L &lt; R &amp;&amp; nums[R] == nums[R - 1]) R--; // 右指针去重，满足题意：避免重复三元组 L++; R--; &#125; else if (sum &lt; target) L++; else if (sum &gt; target) R--; &#125; &#125; &#125; return ans;&#125;; 1.3四数之和II 123456789101112131415161718var fourSumCount = function (A, B, C, D) &#123; let map = new Map(); let res = 0; for (let i = 0; i &lt; A.length; i++) &#123; //hash存两数和，再对比两数和 for (let j = 0; j &lt; B.length; j++) &#123; let sum=A[i]+B[j]; if(map.has(sum)) map.set(sum,map.get(sum)+1); else map.set(sum,1); &#125; &#125; for (let i = 0; i &lt; C.length; i++) &#123; for (let j = 0; j &lt; D.length; j++) &#123; let sum=-(C[i]+D[j]); if(map.has(sum)) res+=map.get(sum); &#125; &#125; return res;&#125;; //O(n^2) 2.判断数组是否含有重复元素 123456789var containsDuplicate = function(nums) &#123; let len = nums.length; let map = new Map(); for(let i = 0;i &lt; len;i++)&#123; if(map.has(nums[i])) return true; else map.set(nums[i],i); &#125; return false;&#125;; 3.数组中出现次数超一半数字* 1234567891011121314var majorityElement = function (nums) &#123; let map = new Map() for (let item of nums) &#123; if (map.has(item)) &#123; map.set(item, map.get(item) + 1) &#125; else &#123; map.set(item, 1) &#125; if (map.get(item) &gt; nums.length / 2) &#123; return item break &#125; &#125;&#125;; 4.两个数组的交集* 12345678910111213141516171819202122232425262728293031323334353637var intersection = function(nums1, nums2) &#123; let numsOne=[...new Set(nums1)] //数组去重 let numsTwo=[...new Set(nums2)] let res=[] let map=new Map() //hash表存储，只有这样定义才能使用map.get/map.set等方法 for(let i=0;i&lt;numsOne.length;i++)&#123; //数组一存入hash表 let item=numsOne[i] if(map.has(item))&#123; //这步没必要判断 map.set(item,map.get(item)+1) &#125;else&#123; map.set(item,1) &#125; &#125; for(let i=0;i&lt;numsTwo.length;i++)&#123; //数组二存入hash表时判断表中是否已有该元素。 let item=numsTwo[i] if(map.has(item))&#123; res.push(item) &#125; &#125; return res&#125;;//简化版var intersection = function(nums1, nums2) &#123; let numsOne=[...new Set(nums1)]; let numsTwo=[...new Set(nums2)]; let res=[]; let map=new Map(); for(let i of numsOne)&#123; map.set(i,1) &#125; for(let i of numsTwo)&#123; if(map.has(i))&#123; res.push(i) &#125; &#125; return res;&#125; 5. 最长和谐子序列xx-594 1234567891011var findLHS = function(nums) &#123; //此处使用数组和hash表没区别，只有处理字符串，有26个字母限制时，使用数组比 //hash表省空间 let map = []; for(num of nums)&#123; map[num] = map[num] === undefined ? 1 : map[num] + 1; &#125; let longest = 0; for(num of nums)&#123; longest = Math.max( longest , (map[num] + map[num+1]) || 0);//注意这个地方map[num + 1]可能为undefined所以要||0 &#125; return longest;&#125;; 注意看题目这个序列不一定连续 6. 最长连续序列xx 1234567891011121314151617181920212223242526var longestConsecutive = function(nums) &#123; //构建哈希表 let map = new Map(); for(num of nums)&#123; let count = map.get(num); if(count === undefined)&#123; map.set(num,1);//注意是1 &#125;else&#123; map.set(num,count + 1); &#125; &#125; let longest = 0; //再遍历一次找最长的长度 for(num of nums)&#123; //只有当这个值的前一个值没有出现时才可能是最长序列的开头，也可以先排序，但不推荐，时间复杂度太高 if(map.get(num - 1) === undefined)&#123; let count = 0; while(map.get(num) !== undefined)&#123;//不为空才执行 count++; num++; //精髓：每一趟for循环时查找最远距离 &#125; longest = Math.max(count,longest); //每次遍历完一段count就比较一次 &#125; &#125; return longest;&#125;; 注意是最长的连续序列要一直递增+1才可以 7.快乐数*12345678910111213141516//同双指针10，就是找重复元素，hash也行，双指针也行var isHappy = function (n) &#123; let map = new Map(); let sum; n = n + &apos;&apos;; while (sum != 1) &#123; sum = 0; for (let i = 0; i &lt; n.length; i++) &#123; sum += n[i] * n[i]; &#125; n=sum+&apos;&apos;; if(map.has(sum)) return false; map.set(sum,1); &#125; return true;&#125;; 数组1.数组扁平化，去重，排序123456789101112131415var arr = [ [1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [12, 13, [14] ] ] ], 10]// 扁平化(多维降到一维数组)const flat = arr.flat(Infinity);// 去重const unique = (array) =&gt; Array.from(new Set(array)) //new Set()后是类数组，如&#123;1,2,2,3&#125;，可执行数组方法 //Array.from将这种特殊的对象-类数组转成数组。// 排序const sort = (array) =&gt; array.sort((a, b) =&gt; a-b)return sort补充：flat() 方法对node版本有要求，至少需要12.0以上，通过array.some() + concat来实现这个flat()，这个对node版本的限制比较低while(arr.some(Array.isArray))&#123; arr = [].concat(...arr) &#125; //console.log(arr); 2.只出现一次数字 注：不使用额外空间，所以不用map 我们将循环的数组元素存入map中，再找某元素时，无需遍历map，只需再循环一遍数组，用map.get处理，相当于遍历了map 1234567891011121314151617181920212223242526272829var singleNumber = function(nums) &#123; //只有一个单数，其余两两出现，找出不连续的即可，符合题意 nums = nums.sort((a, b) =&gt; &#123; return a-b &#125;) for (let i = 0; i&lt;nums.length;i+=2)&#123; if (nums[i] != nums[i+1]) &#123; return nums[i] &#125; &#125;&#125;;//也可以使用两个指针，每次走两步，若两指针不相等时，返回慢指针所指的值****************************************************************************************map方法：好用但不符合题意var singleNumber = function (nums) &#123; let map = new Map() for(let i=0;i&lt;nums.length;i++)&#123; let item=nums[i] if(map.has(item))&#123; map.set(item,map.get(item)+1) &#125;else&#123; map.set(item,1) &#125; &#125; for(let item of nums)&#123; if(map.get(item)===1)&#123; return item &#125; &#125;&#125; 3.合并区间* 12345678910111213var merge = function (intervals) &#123; if (!intervals) return []; intervals.sort((a,b)=&gt; a[0]-b[0]); //按左侧,各自首部排序 let ans = [intervals[0]]; //第一项赋值作为初始化 for (let i = 1; i &lt; intervals.length; i++) &#123; // i=1开始，第二项 if (ans[ans.length - 1][1] &gt;= intervals[i][0]); //第一项尾部&gt;第二项首部时，有交集 ans[ans.length - 1][1] = Math.max(ans[ans.length - 1][1], intervals[i][1])//第1尾部比第2尾部 else ans.push(intervals[i]); &#125; return ans;&#125;;//时间复杂度：O(nlogn)，n = intervals.length。arr.sort() 使用快速排序的平均时间复杂度为 O(nlogn) 。//空间复杂度：O(n)，n = intervals.length。输出数组 res ，极端情况下包含数组 intervals 中所有元素。 4.有效三角形个数* 1234567891011121314151617var triangleNumber = function (nums) &#123; if (nums.length &lt; 3) return 0; nums.sort((a, b) =&gt; a - b); //递增数组,写&#123;&#125;就得写return，不写&#123;&#125;不写return let len = nums.length; let count = 0; for (let i = len - 1; i &gt; 1; i--) &#123;//从后往前，固定最长边，若nums[L]+nums[R]&gt;nums[i]，那么L后皆满足 let L = 0; let R = i - 1; while (L &lt; R) &#123; if ((nums[L] + nums[R]) &gt; nums[i]) &#123; //只需判断两数之和&gt;第三个数即可 count += R - L; R--; &#125; else L++; &#125; &#125; return count;&#125;; 字符串字符串多用数组表映射、转ASCII值、字符串原生方法、正则表达式 1.有效的字母异位词x* 123456789101112131415161718192021222324//因为题目所只有小写字母，考虑长度26位数组更好，使用map的空间消耗要比数组大一些的，因为map要维护红黑树或者哈希表，而且还要做哈希函数。所以数组更加简单直接有效！var isAnagram = function(s, t) &#123; let maps = new Array(26).fill(0); let mapt = new Array(26).fill(0); for(let i of s) maps[i.charCodeAt() - &apos;a&apos;.charCodeAt()]++;//注意js中字符串的相减不会自动转换为ascii码 for(let i of t) mapt[i.charCodeAt() - &apos;a&apos;.charCodeAt()]++; for(let i = 0;i &lt; 26;i++)&#123; if(maps[i] !== mapt[i]) return false; &#125; return true;&#125;;****************************************************************************************注：LeetCode-383赎金信问题，也是数组方法更优化var canConstruct = function (ransomNote, magazine) &#123; let arr = new Array(26).fill(0); for (let i of magazine) &#123; arr[i.charCodeAt() - &apos;a&apos;.charCodeAt()]++; &#125; for (let i of ransomNote) &#123; arr[i.charCodeAt() - &apos;a&apos;.charCodeAt()]--; if (arr[i.charCodeAt() - &apos;a&apos;.charCodeAt()] &lt; 0) return false; &#125; return true;&#125; 字符串和数字的相加减总结 字符串+字符串始终是字符串的拼接 数字字符串 */- 数字字符串会把字符串强制转换为Number进行计算，number≠ASCII如：’123.123’ - ‘1’ = Number(‘123.123’) - Number(‘1’) = 122.123 但是Number只会转换成功那些符合数字规范的字符串，像是’123as’就会转换成NaN,最后的结果也只会是NaN 字符串 + 数字同样也是字符串的拼接 字符串 */- 数字同样将字符串用Number()强制转换再进行运算 字符串和整数间的比较 字符串与整型数字： console.log(‘21’&gt;3) –21&gt;3 true 将字符串数字转化为对应整型数值,再进行数值的比较 字符串之间比较：比较ascll码值 console.log(‘21’&gt;’3’) –’21’&gt;’3’ false parseInt() 和 Number()的区别parseInt(数字或者字符串,基于多少进制转换*)一般为10，默认不是10parseInt()会转换字符串开头首部数字部分,也会保留浮点数的整数部分，不向上或者向下取整如：123asd =&gt; 123, asd123 =&gt; NaN,‘’123.123‘ =&gt; 123, 123.12 =&gt; 123Number()会强制转换其他类型为数字 所有类型的相加相减总结 所有类型和字符串相加都会强制转换为字符串再拼接‘123’ + 1 = ‘123’ + String(1) = ‘1231’‘123’ + NaN = ‘123NaN’‘123’ + undefined = ‘123undefined’ 其他的遇到再总结吧 2.最长回文串*注意只是用这些数字，并没有顺序 123456789101112131415161718var longestPalindrome = function (s) &#123; let maps = new Array(58).fill(0); //ASCII值是A-65，z-122，差了58位 for (i of s) maps[i.charCodeAt() - &apos;A&apos;.charCodeAt()]++; //maps数组填充0 let count = 0; //计算总回文长度 let flag = false; //对于回文中间字母仅取一次，一定要这么写 for (i of maps) &#123; if (i % 2 == 1) &#123; //i为奇数时 if (flag == false) &#123; flag = true; //关闭开关 count++; //计数加一 &#125; i--; //关键点：*i代表字符个数*，若i=1,i--为0，i=3,i--为2，这2个也可以加上 &#125; count += i; //计算总的长度 &#125; return count;&#125;;//注：不可仅计算偶数个数+1，有时可能没有多余字符，如[b,b] 注意不需要注意顺序，最长的个数就是所有值的偶数部分或者如果有奇数的话就+1 3.同构字符串-205 123456789101112var isIsomorphic = function(s, t) &#123; let maps = new Array(123).fill(-1); //z为122 let mapt = new Array(123).fill(-1); for(let i = 0;i &lt; s.length;i++)&#123; let temps = s[i].charCodeAt(); let tempt = t[i].charCodeAt(); if(maps[temps] != mapt[tempt]) return false; maps[temps] = i; mapt[tempt] = i; &#125; return true;&#125;; 用一个map存放每一个值上次出现的位置来判断值的位置相等不相等即可 4.回文子串xxx 123456789101112131415var countSubstrings = function(s) &#123; function extendSubstrings(s,start,end)&#123; while(start &gt;= 0 &amp;&amp; end &lt; s.length &amp;&amp; s[start] === s[end])&#123; ans++; start--; //start左移要-- end++; //end右移要++ &#125; &#125; let ans = 0; for(let i = 0;i &lt; s.length;i++)&#123; extendSubstrings(s,i,i); //找拥有奇数个元素的个数，1个a的个数 + 3个a的个数 + 5个a的个数... extendSubstrings(s,i,i+1); //偶数个a的个数，2个a的个数+4个a的个数... &#125; return ans;&#125;; 以每一个元素为中心（奇数）或者是以每一个元素和后一个元素一起（偶数）为中心向两侧扩展可以使用马拉车算法对这个算法进行优化，使时间复杂度降低到O(2n)即(n)的水平 马拉车算法详解 5.回文数x题目要求不能转换为字符串进行解决 123456789101112131415161718var isPalindrome = function(x) &#123; var str=x.toString();//转字符串 if((str.split(&apos;&apos;).reverse().join(&apos;&apos;))===str)&#123;//分割+翻转+组合 return true; &#125;else&#123; return false; &#125;&#125;;***********************************************************************************************var isPalindrome = function (x) &#123; //不转字符串，纯数学运算 if (x &lt; 0 || (x % 10 == 0 &amp;&amp; x != 0)) return false; //负数、结尾==0都不是回文串 let revertedNumber = 0; while (x &gt; revertedNumber) &#123; //前一半小于，等于后一半时结束循环 revertedNumber = x % 10 + revertedNumber * 10; //翻转后一半的数字 x = Math.floor(x / 10); &#125; return x == revertedNumber || x == Math.floor(revertedNumber / 10); //奇数个时可/10来消除影响&#125;; 6.计数二进制子串xxx 123456789101112131415161718192021222324252627282930313233343536var countBinarySubstrings = function (s) &#123; let pre = 0; //用变量pre承接前一组0/1的个数 let cur = 1; let ans = 0; for (let i = 1; i &lt; s.length; i++) &#123; if (s[i] === s[i - 1]) cur++; else &#123; ans += Math.min(pre, cur); pre = cur; cur = 1; &#125; &#125; ans += Math.min(pre, cur);//注意最后要再加一次 return ans;&#125;; // O(n)/O(1)********************************************************************************************var countBinarySubstrings = function(s) &#123; ************************** let count=[]; //此部分将每组0和1个数存入数组中，如[0,0,1,1,0,1,1]-count=[2,2,1,2] let num=1; let ans=0; for(let i = 0; i &lt; s.length - 1; i++)&#123; if(s[i]==s[i+1])&#123; num++; &#125;else&#123; count.push(num); num=1; &#125; &#125; count.push(num); ************************** for (let j = 0; j &lt; count.length - 1; j++) &#123; ans += Math.min(count[j], count[j + 1]); //求每两组的贡献总和 &#125; return ans;&#125;; // O(n)/O(n) 这种只需要保留前后两个值的问题可以不用全部保存，就直接用两个值保存然后更新即可 7.翻转字符串里的单词* 12345var reverseWords = function (s) &#123; //trim去除两端所有空格，split正则表达 return s.trim().split(/\\s+/g).reverse().join(&quot; &quot;) //\\s匹配空格，+匹配多个空格,g全局匹配 //return s.trim().split(&apos; &apos;).filter(v=&gt;(v !== &apos;&apos;)).reverse().join(&apos; &apos;) 过滤器也可&#125;;//时间和空间都是O(n)，空间O(n)用来存储字符串分割之后的结果 8.字符串相加* 1234567891011121314151617var addStrings = function (num1, num2) &#123; while (num1.length &gt; num2.length) num2 = &apos;0&apos; + num2; while (num2.length &gt; num1.length) num1 = &apos;0&apos; + num1; //先补0对齐 let res = &apos;&apos;; //结果字符串 let pre = 0; //进位 for (let i = num1.length - 1; i &gt;= 0; i--) &#123; let sum = +num1[i] + +num2[i] + pre; //+号将字符转数字 if (sum &gt; 9) &#123; //模10的结果 +res字符串 pre = 1; res = (sum % 10) + res; &#125; else &#123; pre = 0; res = sum + res; &#125; &#125; return pre == 1 ? &apos;1&apos; + res : res; //判断第一位是否要进位&#125;; 8.1字符串转数字方法1.字符串在运算操作中会被当做数字类型来处理：s*=1 2.字符前加‘+’：console.log(+s); 3.string的两个转换函数，只对string有效：parseInt(s); // 234 parseFloat(s); //234 4.强制类型转换：Number(s); // 234 数字转字符串：1.toString() 2.数字+任何字符串” “：console.log(num+””); 9.最长公共前缀* 123456789101112var longestCommonPrefix = function (strs) &#123; if(strs.length==0) return &apos;&apos;; if(strs.length==1) return strs[0]; let res = &apos;&apos;; for (let i = 0; i &lt; strs[0].length; i++) &#123; //横向比较，取第一个字符串 for (let j = 1; j &lt; strs.length; j++) &#123; //从第二个字符串开始比较 if (strs[0][i] != strs[j][i]) return res; &#125; res += strs[0][i]; &#125; return res;&#125;; 双指针定义左右指针，多是while循环判断 1.两数之和 II - 输入有序数组-167 12345678910111213//注意是升序的数组，且输出为index1&lt;index2var twoSum = function (numbers, target) &#123; let left = 0, right = numbers.length - 1; //双指针 while (left &lt; right) &#123; //升序数组，从最大和最小点开始遍历 if (numbers[left] + numbers[right] == target) &#123; return [left + 1, right + 1]; &#125; else if (numbers[left] + numbers[right] &lt; target) &#123; left++; &#125; else &#123; right--; &#125; &#125;&#125;; 2.两数平方和-633 12345678910111213var judgeSquareSum = function(c) &#123; let right = Math.floor(Math.sqrt(c)), left = 0; while(left &lt;= right)&#123; let sum = right * right + left * left; if(sum === c) return true; if(sum &gt; c) right--; else left++; &#125; return false;&#125;; 3.反转字符串中的元音字母-345 12345678910111213141516171819var reverseVowels = function(s) &#123; let sArray = s.split(&apos;&apos;); let map = [&apos;a&apos;,&apos;e&apos;,&apos;i&apos;,&apos;o&apos;,&apos;u&apos;,&apos;A&apos;,&apos;E&apos;,&apos;I&apos;,&apos;O&apos;,&apos;U&apos;]; let len = sArray.length; let left = 0, right = len - 1; while(left &lt; right)&#123; let flagleft = map.indexOf(s[left]), flagright = map.indexOf(s[right]); if(flagleft === -1 ) left++; if(flagright === -1) right--; if(flagright !== -1 &amp;&amp; flagleft !== -1)&#123; [sArray[left],sArray[right]] = [sArray[right],sArray[left]]; left++; right--; &#125; &#125; return sArray.join(&apos;&apos;);&#125;; 注意： 字符串不能改，要转换成array再改 字符串转array .split(‘分隔的字符串’) array转字符串 .join(‘要连接每个元素的字符’) 4.验证回文字符串 Ⅱx-680 12345678910111213141516171819202122232425262728293031var validPalindrome = function (s) &#123; //在基本的验证回文方法中，递归调用右边减一或左边加一情况。 function isPalindrome(s, left, right) &#123; while (left &lt; right) &#123; if (s[left++] != s[right--]) return false; //等价于 if (s[left] != s[right]) &#123;return false;&#125; left++;right--; &#125; return true; &#125; let left = 0, right = s.length - 1; while (left &lt; right) &#123; if (s[left++] != s[right--]) return isPalindrome(s, left - 1, right) || isPalindrome(s, left, right + 1);//注意left++和right--过后就已经改变了 &#125; return true;&#125;;*******************************************************************************************//LeetCode-125，验证回文字符串，正则+双指针var isPalindrome = function (s) &#123; s = s.replace(/[^0-9a-zA-Z]/g, &apos;&apos;).toLowerCase() //对于&quot;A man, a plan, a canal: Panama&quot;这样的 let i = 0, len = s.length, j = len - 1 //[^..]代表未包含的，用空字符代替，再转小写 while (i &lt; j) &#123; if (s[i] == s[j]) &#123; i++; j--; &#125; else &#123; return false &#125; &#125; return true&#125;; 很巧妙的写法不用再自己写代码判断，分离出一个功能 5.合并两个有序数组x-88* 123456789101112131415161718192021//双指针法,从后往前比较，填充m+n的数组，若从前到后也可，不过需要将nums1先存起来，时间复杂度O(m+n),O(m)var merge = function (nums1, m, nums2, n) &#123; let p1 = m - 1, p2 = n - 1, MAX_Length = m + n - 1; while (p1 &gt;= 0 &amp;&amp; p2 &gt;= 0) &#123; if (nums1[p1] &lt; nums2[p2]) nums1[MAX_Length--] = nums2[p2--]; else nums1[MAX_Length--] = nums1[p1--]; &#125; //若nums1中的值比较小，p1很快就到0索引，我们要将nums2合并到nums1中，所以此处为p2 while(p2&gt;=0) nums1[MAX_Length--] = nums2[p2--]; return nums1; //该题最后只能返回nums1，不能返回其他额外数组&#125;;时间复杂度O(m+n),O(1),最优解********************************************************************************************//巧妙的数组排序var merge = function (nums1, m, nums2, n) &#123; nums1.splice(m);//由题意得:初始化nums1和nums2数组值，splice直接对原数组修改，所以不用slice(会生成新数组) nums2.splice(n);//删除index==n开始及之后的值 nums1.push(...nums2); nums1.sort((a, b) =&gt; a - b);&#125;;时间复杂度O((m+n)log(m+n)),O(1) 从后往前遍历这样就可以不用多用一个数组来存储遍历后的值 6.判断链表是否有环** 1234567891011121314151617181920212223242526272829303132333435var hasCycle = function (head) &#123; if (!head) return false let fast = head.next let slow = head while (fast &amp;&amp; fast.next) &#123; //后面要用到fast.next.next，此处要判断fast.next是否为空 slow = slow.next fast = fast.next.next if (fast == slow) &#123; return true &#125; &#125; return false&#125;;//加强版，要求返回环入口的节点var detectCycle = function (head) &#123; if (!head) return head; let fast = head; let slow = head; while (fast &amp;&amp; fast.next) &#123; slow = slow.next fast = fast.next.next if (fast == slow) &#123; //没有环就不可能再相遇，相遇必在环内。 fast = head; while (true) &#123; if (slow == fast) &#123; return slow; &#125; fast = fast.next; slow = slow.next; &#125; &#125; &#125; return null&#125;; 相遇时，慢指针走的距离：D+S1假设相遇时快指针已经绕环 n 次，它走的距离：D+n(S1+S2)+S1因为快指针的速度是 2 倍，所以相同时间走的距离也是 2 倍：D+n(S1+S2)+S1 = 2(D+S1)即 (n-1)S1+ nS2=D(n−1)S1+nS2=D我们不关心绕了几次环，取 n = 1 这种特定情况，消掉 S1：D=S2 怎么利用 D=S2 求入环点在循环的过程中，快慢指针相遇，位置相同了，可以确定出相遇点为了确定「入环点」，我们「人为制造」快慢指针在入环点相遇让快指针从头节点出发，速度改为和慢指针一样，慢指针留在首次相遇点，同时出发因为 D = S2D=S2 ，二者速度相同，所以会同时到达入环点。 7.通过删除字母匹配到字典里最长单词x 12345678910111213141516171819202122232425262728293031var findLongestWord = function (s, d) &#123; let maxlen = 0; let maxS = &apos;&apos;; function isEqual(s1, s2) &#123; let p1 = 0, p2 = 0; let len1 = s1.length, len2 = s2.length; if (maxlen &gt; len2 || len2 &gt; len1) return false; while (p1 &lt; len1 &amp;&amp; p2 &lt; len2)&#123; if(s1[p1] === s2[p2])&#123; p1++; p2++; &#125;else&#123; p1++; &#125; &#125; if(p2 === len2) return true; else return false; &#125; for(let s2 of d)&#123; if(isEqual(s,s2))&#123; if(s2.length === maxS.length) maxS = maxS &lt; s2 ? maxS : s2; else&#123; maxS = s2; maxlen = s2.length; &#125; &#125; &#125; return maxS;&#125;; 8.接雨水* 123456789101112131415161718192021222324252627282930//双指针法var trap = function (height) &#123; let ans = 0; let left = 0, right = height.length - 1; let left_max = 0, right_max = 0; while (left &lt; right) &#123; //左指针和右指针相遇为界，一次遍历 if(height[left]&lt;=height[right])&#123; //找出左右较小的那一个 *************************************************************************** if(height[left]&gt;left_max)&#123; //找出局部中左侧高于当前位置的index left_max=height[left]; //因为右侧已经高于左侧，所以会形成积水 &#125;else&#123; ans+=left_max-height[left]; //用左侧最大值减去当前块为积水量 &#125; *************************************************************************** 上面if、else区域可替换成： left_max = Math.max(left_max, height[left]); ans += left_max - height[left]; *************************************************************************** left++; //@@@left++写在外面 &#125;else&#123; if(height[right]&gt;right_max)&#123; //右侧同理 right_max=height[right]; &#125;else&#123; ans+=right_max-height[right]; &#125; right--; &#125; &#125; return ans; //时间复杂度O(n),空间复杂度O(1)&#125;; 9.移除元素* 12345678910111213141516171819202122232425262728293031323334353637383940414243//数组的元素在内存地址中是连续的，不能单独删除数组中的某个元素，只能覆盖***.var removeElement = function (nums, val) &#123; //双层for循环，但时间复杂度高 let len = nums.length; for (let i = 0; i &lt; len; i++) &#123; if (nums[i] == val) &#123; for (let j = i + 1; j &lt; len; j++) &#123; nums[j-1]=nums[j]; &#125; i--; len--; &#125; &#125; return len;&#125;;****************************************************************************************//优化：双指针法：最后返回的数组长度，但打印的是删除后的数组var removeElement = function (nums, val) &#123; let len = nums.length; let slow = 0;let fast = 0; while(fast &lt; len) &#123; //快慢指针一起移动，快指针所指覆盖慢指针值 if(nums[fast]!==val)&#123; nums[slow]=nums[fast]; slow++; &#125; fast++; &#125; return slow;&#125;;**************************************************************************//LeetCode-80，删除有序数组中的重复项II：使每个元素最多出现两次 ，返回删除后数组的新长度。使用 O(1) 额外空间var removeDuplicates = function(nums) &#123; let len = nums.length; for (let i = 0; i &lt; len-2; i++) &#123; if (nums[i] == nums[i+2]) &#123; for (let j = i + 2; j &lt; len; j++) &#123; nums[j-1]=nums[j]; &#125; i--; len--; &#125; &#125; return len;&#125;; 10.快乐数* 123456789101112131415161718var isHappy = function (n) &#123; function getsum(n) &#123; //平方和算法 n = n + &apos;&apos;; let len = n.length; let sum = 0; for (let i = 0; i &lt; len; i++) &#123; sum += n[i] ** 2; &#125; return sum; &#125; let slow = n; //双指针移动 let fast = getsum(n); while (fast != 1 &amp;&amp; slow != fast) &#123; slow = getsum(slow); fast = getsum(getsum(fast)); &#125; return fast == 1&#125;; 排序1.排序的方式总结(JS)选择排序 思想第一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，然后再从剩余的未排序元素中寻找到最小（大）元素，然后放到已排序的序列的末尾。 以此类推，直到全部待排序的数据元素的个数为零。 选择排序是不稳定的排序方法。 代码 12345678910111213function selectSort(arr) &#123; let len = arr.length; for (let i = 0; i &lt; len - 1; i++) &#123; let minIndex = i; for (let j = i + 1; j &lt; len; j++) &#123; if (arr[j] &lt; arr[minIndex]) minIndex = j; &#125; [arr[minIndex], arr[i]] = [arr[i], arr[minIndex]]; &#125;&#125;let arr = [4,3,2,1];selectSort(arr);console.log(arr); 分析 时间复杂度* O(n2) * 最好最坏都是O(n2) 空间* O(1) 不稳定 插入排序 思想 代码 12345678910111213141516function insertSort(arr) &#123; let len = arr.length; for (let i = 1; i &lt; len; i++) &#123; let temp = arr[i]; let j; for (j = i - 1; j &gt;= 0; j--) &#123; if(temp &lt; arr[j]) [arr[j],arr[j + 1]] = [arr[j + 1], arr[j]]; else break; &#125; arr[j + 1] = temp; &#125;&#125;let arr = [20,3,4,2,51,23,45];insertSort(arr);console.log(arr); 分析 时间复杂度* 平均： O(n2) * 最差：O(n2) * 最优：O(n)已经有序 空间复杂度* O(1) 稳定冒泡 1.思想就是n-1趟排序，把最大的值浮上去2.代码 没有优化的 123456789101112function bubbleSort(arr) &#123; let len = arr.length; for (let i = 1; i &lt; len; i++) &#123;//总共排序len - 1趟 for (let j = 0; j &lt; len - i; j++) &#123; //长度-1 if (arr[j] &gt; arr[j + 1]) [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]]; &#125; &#125;&#125;let arr = [4,3,2,1,1,2,5,25,6,22];bubbleSort(arr);console.log(arr); 优化后的冒泡排序就是加个标识：如果某一趟排序没有交换顺序说明已经有序无须再继续 1234567891011121314151617function bubbleSort(arr) &#123; let len = arr.length; for (let i = 1; i &lt; len; i++) &#123;//总共排序len - 1趟 let flag = true; for (let j = 0; j &lt; len - i; j++) &#123; if (arr[j] &gt; arr[j + 1])&#123; [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]]; flag = false; &#125; &#125; if(flag) break; &#125;&#125;let arr = [4,3,2,1,1,2,5,25,6,22]bubbleSort(arr);console.log(arr); 分析(优化后) 时间复杂度* O(n2) * O(n) 最优 * O(n2)最差 稳定二路归并x 思想把一个数组二分，先对左边进行二路归并，再对右边进行二路归并使左右两边有序，再把左右两边组合为一个连续的数组。需要把一个数组的连续的两个有序的部分组合称为一个有序的部分。 代码 1234567891011121314151617181920212223242526272829303132function mergeSort(arr, left, right) &#123; function merge(arr, l1, r1, l2, r2) &#123; let p1 = l1, p2 = l2; let temp = []; while (p1 &lt;= r1 &amp;&amp; p2 &lt;= r2) &#123; if (arr[p1] &lt; arr[p2]) temp.push(arr[p1++]); else temp.push(arr[p2++]); &#125; while (p1 &lt;= r1) temp.push(arr[p1++]); while (p2 &lt;= r2) temp.push(arr[p2++]); for (let i = 0; i &lt; temp.length; i++) &#123; arr[i + l1] = temp[i]; &#125; &#125; let mid = Math.floor((left + right) / 2); if (left &lt; right) &#123; mergeSort(arr, left, mid); mergeSort(arr, mid + 1, right); merge(arr, left, mid, mid + 1, right); &#125;&#125;arr = [4, 3, 2, 1, 1, 2, 5, 25, 6, 22]mergeSort(arr,0,arr.length - 1);console.log(arr); 分析 时间复杂度* O(nlogn) 空间复杂度* O(n) 稳定 快排 思想调整一个序列的第一个值的位置使得让其左边的值都小于等于它，右边的值都大于等于它，然后再最左边和右边进行递归，双while循环 实现 12345678910111213141516171819202122function quickSort(arr, left, right) &#123; function partition(arr, left, right) &#123; let temp = arr[left]; while (left &lt; right) &#123; while (arr[right] &gt;= temp &amp;&amp; left &lt; right) right--; arr[left] = arr[right]; while (arr[left] &lt;= temp &amp;&amp; left &lt; right) left++; //left&lt;right要存在 arr[right] = arr[left]; &#125; arr[left] = temp; return left; &#125; //调用分区方法 if (left &lt; right) &#123; let mid = partition(arr, left, right); quickSort(arr, left, mid - 1); quickSort(arr, mid + 1, right); &#125;&#125;let arr = [4, 3, 2, 1, 1, 2, 5, 25, 6, 22]quickSort(arr, 0, arr.length - 1);console.log(arr); 分析 时间复杂度* O(nlogn) 不稳定堆排序 思想先建立一个大顶堆，再进行堆排序，注意堆是一棵完全二叉树，下标要从1开始，所以要调整一下下标 实现 12345678910111213141516171819202122232425262728293031323334353637function heapSort(arr) &#123; //向下调整 function downAdjust(left, right) &#123; let lchild = left * 2; let rchild = lchild + 1; if (lchild &gt; right) return; //找到lchild和rchild中的较大值，并把较大的值赋给lchild if (rchild &lt;= right &amp;&amp; arr[lchild] &lt; arr[rchild]) [lchild, rchild] = [rchild, lchild]; //与这个结点比较 if (arr[left] &lt; arr[lchild]) &#123; [arr[left], arr[lchild]] = [arr[lchild], arr[left]]; downAdjust(lchild, right); &#125; &#125; //假设arr不从1下标开始 arr.push(arr[0]); var len = arr.length - 1; //从倒数第一个非叶子结点开始向下调整得到大顶堆 for (let i = Math.floor(len / 2); i &gt; 0; i--) &#123; downAdjust(i, len); &#125; //再进行堆排序 for(let i = len; i &gt; 0;i--)&#123; [arr[i],arr[1]] = [arr[1],arr[i]]; downAdjust(1,i-1); &#125; //再去掉这个空值 arr.shift();&#125;arr = [2, 3, 12, 41, 32, 12, 3];heapSort(arr);console.log(arr); 分析 时间复杂度* O(nlogn) 不稳定排序方式比较 2.调数组顺序使奇数在偶数前* 123456789101112131415161718var exchange = function (nums) &#123; //快速排序 let r = nums.length - 1; let temp; let i = 0, j = r; while (i &lt; j) &#123; while (i &lt; j &amp;&amp; nums[i] % 2 == 1) i++; while (i &lt; j &amp;&amp; nums[j] % 2 == 0) &#123; j--; &#125; if (i &lt; j) &#123; temp=nums[j]; nums[j] = nums[i]; nums[i]=temp; &#125; &#125; return nums;&#125;; 3.数组中的第K个最大元素** 解法1:直接用js内置的sort()**注意：内置sort会把所有的东西都转换为字符串进行比较，所以要转换成数字比较 1234567var findKthLargest = function (nums, k) &#123; nums.sort((a,b)=&gt;&#123; //转为数值比较 ***不写大括号的直接a-b return a-b &#125;) let len=nums.length return nums[len-k] //len-k为第k大的数&#125;; 解法2:使用大/小顶堆 123456789101112131415161718192021222324252627282930var findKthLargest = function (nums, k) &#123; //创建大顶堆 //向下调整 function downAdjust(nums, low, high) &#123; let lchild = low * 2; let rchild = lchild + 1; if (lchild &gt; high) return; if (rchild &lt;= high &amp;&amp; nums[lchild] &lt; nums[rchild]) [lchild, rchild] = [rchild, lchild]; if (nums[low] &lt; nums[lchild]) &#123; [nums[lchild], nums[low]] = [nums[low], nums[lchild]]; downAdjust(nums, lchild, high); &#125; &#125; //调整为大顶堆 nums.push(nums[0]); let len = nums.length - 1; for (let i = Math.floor(len / 2); i &gt; 0; i--) &#123; downAdjust(nums, i, len); &#125; //通过大顶堆排序取第k个值，不用全部都排，只排到第k个即可 for (let i = len; i &gt; len - k; i--) &#123; [nums[1], nums[i]] = [nums[i], nums[1]]; downAdjust(nums, 1, i - 1); &#125; return nums[len - k + 1];&#125;;console.log(findKthLargest([3,2,3,1,2,4,5,5,6,7,7,8,2,3,1,1,1,10,11,5,6,2,4,7,8,5,6],2)); 解法3:快排 12345678910111213141516171819202122232425262728var findKthLargest = function (nums, k) &#123; //快排逆序 //实现分配函数使nums第一个值的左边都大于它，右边都小于它，一遍快排 let len = nums.length function partition(nums, l, r) &#123; let temp = nums[l] //存的是左值，不能写0 let first = l, end = r while (first &lt; end) &#123; while (first &lt; end &amp;&amp; nums[end] &gt; temp) end--; nums[first] = nums[end] while (first &lt; end &amp;&amp; nums[first] &lt;= temp) first++; nums[end] = nums[first] &#125; nums[first] = temp return first //返回的是分界下标 &#125; //递归进行快排，实现全部排序 function quick(nums, l, r) &#123; if (l &gt; r) return let curr = partition(nums, l, r) quick(nums, l, curr - 1) quick(nums, curr + 1, r) &#125; quick(nums, 0, len - 1) return nums[len - k]&#125;; 4.出现频率最多的 k 个元素(桶排序)x 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768var topKFrequent = function (nums, k) &#123; //首先建立每个值的频率键值对 let map = new Map(); nums.forEach(function (item) &#123; //注意只能通过.get去访问map中的值 if (map.has(item)) map.set(item,map.get(item)+1); else map.set(item, 1 ); &#125;) //以频率为数组下标放入一个数组中 **遍历map方法** let arr = []; map.forEach(function (value, key) &#123; if (!arr[value]) arr[value] = []; arr[value].push(key); &#125;) //逆序遍历数组取k个元素放入result数组 let result = []; let len = arr.length - 1; let count = 0; for(let i = len;i &gt; 0;i--)&#123; if(arr[i])&#123; //注意因为答案唯一所以不用在此处再进行一次遍历判断是否已经达到了k个 result.push(...arr[i]); count += arr[i].length; &#125; if(count == k) break; &#125; return result;&#125;;//方法二：//1.遍历数组，将数组的值作为 key, 值的个数作为 value，存入一个 map 中//2.遍历 map，将 map 里面的 key 和 value，作为一个对象 &#123;key:key,value:value&#125; 存入一个数组中//3.将对象数组根据 value 从大到小排序//4.截取对象数组的前 K 个值，返回其 key 组成的数组即可var topKFrequent = function(nums, k) &#123; // 1.遍历数组，将所有结果存储到 map 中 let map = new Map() for (let item of nums) &#123; if (map.has(item)) &#123; let count = map.get(item) + 1 map.set(item, count) &#125; else &#123; map.set(item, 1) &#125; &#125; // 2.把数据存入一个对象数组 let array = [] for (let [key, value] of map) &#123; array.push(&#123; key, value &#125;) &#125; // 3.将对象数组根据 value 从大到小排序 array.sort((a, b) =&gt; &#123; return b.value - a.value &#125;) // 4.截取前k个，返回其key值组成的数组，这里map为数组遍历方法 return array.slice(0,k).map(item =&gt; &#123; return item.key &#125;) //和第四步同理 //let res = [] //for (let item of arr.slice(0,k)) &#123; // res.push(item.key) //&#125; //return res&#125;; 5.根据字符出现频率排序 123456789101112131415161718192021222324var frequencySort = function (s) &#123; let map = new Map(); let len = s.length; for (let i = 0; i &lt; len; i++) &#123; if (map.has(s[i])) map.set(s[i], map.get(s[i]) + 1); else map.set(s[i], 1); &#125; let arr = []; map.forEach(function (val, key) &#123; if (!arr[val]) arr[val] = []; //有多个相同个数的字符，push到一个数组中 arr[val].push(key); &#125;) let ans = &apos;&apos;; for (let i = arr.length - 1; i &gt; 0; i--) &#123; if (arr[i]) &#123; // 新数组有空位，要判断是否存在 arr[i].forEach(function (item) &#123; //一个数组中多个字符分别遍历 for (let j = 0; j &lt; i; j++) ans += item; //对每一个元素都加上对应的频率次 &#125;) &#125; &#125; return ans;&#125;; 6.颜色分类(荷兰国旗问题) 三路快排 123456789101112131415161718192021222324252627282930313233343536var sortColors = function (nums) &#123; let zero = 0, one = 0, two = nums.length - 1; while (one &lt;= two) &#123; if (nums[one] === 0) &#123; [nums[one], nums[zero]] = [nums[zero], nums[one]]; one++; zero++; &#125; else if (nums[one] === 1) &#123; one++; &#125; else &#123; [nums[one], nums[two]] = [nums[two], nums[one]]; two--; &#125; &#125; return nums;&#125;;***************************************************************************************方法二：var sortColors = function (nums) &#123; //使用数组方法将0删除再插到头部，将2删除再接到尾部 let len = nums.length for (let i = 0; i &lt; len; i++) &#123; if (nums[i] === 0) &#123; nums.splice(i, 1) nums.unshift(0) //每次插到头部时，指针指向新插入元素 &#125; if (nums[i] === 2) &#123; nums.splice(i, 1) nums.push(2) len-- // i-- //每次删除一元素，指针不动，后一元素补上 &#125; &#125; return nums&#125;; 贪心1.分发饼干-455* 123456789101112131415var findContentChildren = function (g, s) &#123; let Glen = g.length, Slen = s.length; g.sort((a, b) =&gt; a - b); //对g，s排序 s.sort((a, b) =&gt; a - b); let count = 0; for (let i = 0, j = 0; i &lt; Glen &amp;&amp; j &lt; Slen; i++ , j++) &#123; while (j &lt; Slen &amp;&amp; g[i] &gt; s[j]) &#123; //需求大于饼干量，该饼干量无法满足任何人，作废 j++; &#125; if (j &lt; Slen) &#123; count++; &#125; &#125; return count;&#125;; 2.无重叠区间x 12345678910111213141516//找不重叠的区间，对右区间排序var eraseOverlapIntervals = function (intervals) &#123; if (intervals.length == 0) return 0 intervals.sort((a, b) =&gt; a[1] - b[1]) //移除区间数量最少，让每个子区间右值越小，其余的空闲区间就越大 let right = intervals[0][1] let count = 0 for (let i = 1; i &lt; intervals.length; i++) &#123; if (intervals[i][0] &gt;= right) &#123; right = intervals[i][1] //不重叠改变指针 &#125; else &#123; count++ //重叠时i指针后移，自动过滤右值大的子区间 &#125; &#125; return count&#125;;若是用左值来排序，要考虑[[1,100],[1,10],[2,20]]这种包含关系，做出判断，并删除右值大的一项[1,100] 3.用最少数量的箭引爆气球 1234567891011121314151617181920//找不重叠区间即可，不重叠就加一，重叠继续var findMinArrowShots = function(points) &#123; if(!points[0]) return 0; //先排序 points.sort((x,y)=&gt;&#123; return x[1] - y[1]; &#125;) //再找不重叠区间 let account = 1; let end = points[0][1]; for(let i = 1;i &lt; points.length;i++)&#123; if(end &lt; points[i][0])&#123; account++; end = points[i][1]; &#125; &#125; return account;&#125;; 思路与上一个题类似，都是对重叠区间的处理问题 4.根据身高重建队列xx-406 12345678910111213141516171819//先按身高从大到小排序，按照身高排序之后，优先按身高高的people的k来插入，后序插入节点也不会影响前面已经插入的节点var reconstructQueue = function(people) &#123; //按照身高降序排序，若身高相同按K升序来排序*** people.sort((x,y)=&gt;&#123; if(x[0] !== y[0]) return y[0] - x[0]; else return x[1] - y[1]; &#125;) let ans = []; //插入空数组 people.forEach(function(person)&#123; ans.splice(person[1],0,person); //注意splice方法进行插入，删除数组的用法 &#125;); //等同于 //for (let i = 0; i &lt; people.length; i++) &#123; // ans.splice(people[i][1], 0, people[i]) //&#125; return ans;&#125;; 5.买卖股票的最佳时机xx-121* 123456789var maxProfit = function(prices) &#123; let profit = 0; let minPrice = 9999999; prices.forEach(function(price)&#123; minPrice = Math.min(minPrice,price); profit = Math.max(profit,price - minPrice); &#125;) return profit;&#125;; 6.买卖股票的最佳时机 II* 12345678var maxProfit = function (prices) &#123; let ans = 0; let len = prices.length; for (let i = 0; i &lt; len-1; i++) &#123; ans += prices[i+1] - prices[i] &gt; 0 ? prices[i+1] - prices[i] : 0; &#125; return ans;&#125;; 能获得的最大收益就是所有的涨，不用考虑买入。找到递增的时间段，累加即可； 7.种花问题x 123456789101112131415161718var canPlaceFlowers = function (flowerbed, n) &#123; let i = 0; let account = 0; let len = flowerbed.length; while (i &lt; len) &#123; if (flowerbed[i] === 1) i = i + 2; else &#123; let pre = i === 0 ? 0 : flowerbed[i - 1]; //i为索引值，判断左右边界情况 let next = i === len - 1 ? 0 : flowerbed[i + 1]; if (pre === 0 &amp;&amp; next === 0) &#123; account++; flowerbed[i] = 1; i = i + 2; &#125;else i++; &#125; &#125; return account &gt;= n;&#125;; 8.判断子序列x 123456789101112131415//子序列 是不要求连续的,子数组和子串一样，是需要连续的var isSubsequence = function(s, t) &#123; let len = s.length; let flag = true; for(let i = 0;i &lt; len;i++)&#123; let index = t.indexOf(s[i]); if(index == -1)&#123; flag = false; break; &#125;else&#123; t = t.substring(index + 1); &#125; &#125; return flag;&#125;; 9.非递减数列x 12345678910111213141516171819202122//题中非递减数列定义的是：递增数列+等于，所以数组中只能有一对相邻的递减值，同时考虑改变这对值时，对前后序列的影响//如[3,4,2,3]就不能单纯找一对递减的[4,2]var checkPossibility = function (nums) &#123; //要想递增，要么前一项缩小，要么后一项增大 let flag = nums[0] &gt; nums[1] ? false : true; //后悔数，用于标识改变元素一次--此处判断因后续要用到i-1 for (let i = 1; i &lt; nums.length; i++) &#123; if (nums[i] &gt; nums[i + 1]) &#123; //找到递减的一对 if (flag) &#123; //若为true，代表还没改变过 if(nums[i-1]&lt;nums[i+1])&#123; //i的后一项大于i的前一项，改i值可递增（瞻前顾后法） nums[i]=nums[i+1]; flag=false; &#125; else if(nums[i-1]&gt;nums[i+1])&#123; nums[i+1]=nums[i]; flag=false; &#125; &#125;else&#123; //一次机会用完，还有其他递减对，所以flase return false; &#125; &#125; &#125; return true;&#125;; 10.最大子序和x* 123456789101112131415//动态规划解法var maxSubArray = function (nums) &#123; let pre = nums[0]; //数组为[-1]单个元素时 let max = pre; let len = nums.length; for (let i = 1; i &lt; len; i++) &#123; if (pre &lt; 0) &#123; pre = nums[i]; &#125; else &#123; pre += nums[i]; &#125; max = Math.max(pre, max); &#125; return max;&#125;; 11.划分字母区间xxx 12345678910111213141516171819202122232425262728293031323334353637383940414243//找到每个字符的最远距离，若索引i==最远距离索引，一段结束。var partitionLabels = function (S) &#123; let len = S.length; let pos = []; let l = 0, r = 0; let ans = []; //用一个数组存储所有的字符最后一次出现的下标 for (let i = 0; i &lt; len; i++) &#123; pos[S[i].charCodeAt() - 97] = i; //97是小写字母a的ASCII值 &#125; for (let i = 0; i &lt; len; i++) &#123; //更新一个区间的右边界 r = Math.max(r, pos[S[i].charCodeAt() - 97]); //如果更新了过后仍然处在右边界上说明找到了一个区间 if (i === r) &#123; ans.push(r - l + 1); l = i + 1; r = i + 1; &#125; &#125; return ans;&#125;;**********************************************************************************//自己的方法var partitionLabels = function (S) &#123; let index = 0; //存储最远下标 let len = S.length; let ans = []; for (let i = 0; i &lt; len; i++) &#123; let indexEnd = S.lastIndexOf(S[i]); //找到当前字符最远下标 index = Math.max(index, indexEnd); //记录最远下标 if (index == i) &#123; //一段结束 ans.push(i + 1); continue; &#125; &#125; //此时ans是累加长度 for (let j = ans.length - 1; j &gt; 0; j--) &#123; //截取长度 ans[j] = ans[j] - ans[j - 1]; &#125; return ans;&#125;; 12.盛最多水的容器 双指针+贪心 12345678910111213141516171819202122232425262728293031323334353637var maxArea = function (height) &#123; function computeArea(x, y) &#123; //求积水面积方法 let temp = Math.min(height[x], height[y]); return temp * (y - x); &#125; let left = 0; let right = height.length - 1; let max = 0; while(left &lt; right)&#123; max = Math.max(computeArea(left,right),max); if(height[left] &lt; height[right])&#123; left++; &#125;else&#123; right--; &#125; &#125; return max;&#125;;********************************************************************************//自己的方法：求面积最大，从坐标最长开始，有短边的，改变短边坐标，math.max记录最大var maxArea = function (height) &#123; let max = 0; //记录最大面积 let l = 0; let r = height.length - 1; let len = height.length - 1; //起始和终点坐标长度 while (l &lt; r) &#123; if (height[l] &lt;= height[r]) &#123; //左边较小 max = Math.max(max, height[l] * len); //纪录最大面积 l++; //左边前进一位 len--; //长边短一位 &#125; else &#123; max = Math.max(max, height[r] * len); r--; len--; &#125; &#125; return max;&#125;; 二分查找题目让我们查找某个数优先考虑二分查找，基础是排好序的数组，时间复杂度O(logn) 因为向下取整，所以左侧一定要+1，右侧看情况： 1.若要找的值在目标值左侧，如第一题，输入8，目标值2.82842，要找的是2，那么l&lt;=r; r=mid-1，return r，最后两指针一定重合执行最后一次; 2.若要找的值在目标值右侧，如第7题，[1,3,5,6]，目标值2，找到3对应的索引，l&lt;r; r=mid，return l或r都行;两指针一定相邻执行最后一次；3.若单纯找某值，默认使用l&lt;r结构； 边界问题：题5 1.x 的平方根x* 12345678910111213141516171819//二分查找多是这个结构，while(l&lt;r),let mid=...var mySqrt = function(x) &#123; let l = 0; let r = x; while(l &lt;= r)&#123; //要向下取整 let mid = Math.floor((l + r) / 2); let powerMin = mid * mid; if(powerMin &gt; x)&#123; r = mid - 1; &#125;else if(powerMin &lt; x)&#123; l = mid + 1; &#125;else&#123; return mid; &#125; &#125; //注意最后都要返回r return r;&#125;; 原理在于总有一次在+1或者-1后左边界或者右边界会跨过真实的平方值，而跨过之后谁跨过就不会再发生变化直到l &gt; r，此时r指向的是真实平方值的整数部分 2.寻找比目标字母大的最小字母x 我的： 1234567891011121314var nextGreatestLetter = function (letters, target) &#123; let ans = &apos;&apos;; for (let i = 0; i &lt; letters.length; i++) &#123; if (letters[i] &gt; target) &#123; //可以直接比，无需转ASCII-str.charCodeAt() ans = letters[i]; break; &#125; else &#123; continue; &#125; &#125; if (ans == &apos;&apos;) ans = letters[0]; return ans;&#125;;//时间复杂度O(n),可采用二分查找 二分查找： 12345678910111213141516171819var nextGreatestLetter = function (letters, target) &#123; let l = 0; let h = letters.length - 1; //因为h=mid没有-1所以只能用l &lt; h而不能取等否则会死循环 //最后退出循环的条件一定是l===h,此时l代表着唯一有可能满足条件的位置 //所以去判断l是否满足条件就可以判断是否存在这样的元素 while(l &lt; h)&#123; let mid = Math.floor((l + r) / 2); //注意此处是找到第一个大于target的值，所以是大于符号 if(letters[mid] &gt; target)&#123; //这个值有可能就是第一个大于target的值，所以不-1 h = mid; &#125;else&#123; l = mid + 1; &#125; &#125; return letters[l] &gt; target ? letters[l] : letters[0]; //都小于目标值，循环返回第一个&#125;;//时间复杂度O(logn) 3.有序数组中的单一元素xx 12345678910111213141516var singleNonDuplicate = function(nums) &#123; let l = 0; let h = nums.length - 1; while(l &lt; h)&#123; let mid = l + Math.floor((h - l)/2); if(mid % 2 === 1 )&#123; mid--; &#125; if(nums[mid] === nums[mid + 1])&#123; l = mid + 2; &#125;else&#123; h = mid; &#125; &#125; return nums[l];&#125;; 4.第一个错误的版本 123456789101112131415var solution = function(isBadVersion) &#123; return function(n) &#123; let l = 1; let h = n; while(l &lt; h)&#123; let mid = Math.floor((l + h)/2); if(isBadVersion(mid))&#123; h = mid; &#125;else&#123; l = mid + 1; &#125; &#125; return l; &#125;;&#125;; 5.寻找旋转排序数组中的最小值 把这个数组看成两个部分，l和h各指向一个部分，最小值只能在右边那个部分，取mid发现若发现比nums[h]小则说明mid在l部分，要+1，否则说明mid在h部分并且可能是最小值 123456789101112131415var findMin = function (nums) &#123; let l = 0; let h = nums.length - 1; if(nums[0] &lt; nums[h]) return nums[0]; while (l &lt; h) &#123; //此时l&lt;r，没有等号时，L进一，h不退，返回时就是nums[l] //有等号时，都会进位，l=mid+1;h=mid-1;返回nums[h+1] let mid = Math.floor((l + h) / 2); if(nums[mid] &gt; nums[h])&#123; l = mid + 1; //若L不进一，最后剩两位时，会死循环，例[4,5,6,7,0,1,2] &#125;else&#123; h = mid; &#125; &#125; return nums[l]; //最后l和r指针重合&#125;; 6.在排序数组中查找元素的第一个和最后一个位置 12345678910111213141516171819202122232425var searchRange = function (nums, target) &#123; function binarySearch(nums, target) &#123;//第一个值为target的可能的位置 let l = 0; //注意下标从nums.length开始，因为target+1的值可能比所有的值都大，而我们要找的是target+1的位置，所以target+1的位置是可能在nums.length的，所以要从nums.length开始 //并且mid的值在此处是不可能取到nums[length]的，因为是向下取整，r又至少比l大1，并且循环条件是不取等，所以r至少比mid大1 let r = nums.length; while (l &lt; r) &#123; let mid = l + Math.floor((r - l)/2); //防溢出 if (nums[mid] &lt; target) &#123; l = mid + 1; &#125; else &#123; r = mid; &#125; &#125; return l; &#125; //找到第一个值为target的下标 let index1 = binarySearch(nums,target); if(nums[index1] !== target)&#123; return [-1,-1]; &#125; let index2 = binarySearch(nums,target + 1); return [index1,index2 - 1];&#125;; 7.搜索插入位置 1234567891011121314var searchInsert = function (nums, target) &#123; let len=nums.length; if(target&gt;nums[len-1]) return len; //最后一个元素单独判断 let l = 0, r = nums.length - 1; while (l &lt; r) &#123; let mid = Math.floor(l + ((r - l) / 2)); // 防止溢出 等同于(left + right)/2; if (nums[mid] &lt; target) &#123; l = mid+1; &#125; else &#123; r = mid; &#125; &#125; return l;&#125;; 分治（先pass）1.为运算表达式设计优先级 1.基本分治方法 123456789101112131415161718192021222324252627282930var diffWaysToCompute = function (input) &#123; let len = input.length; let ans = []; for (let i = 0; i &lt; len; i++) &#123; if (input[i] === &apos;+&apos; || input[i] === &apos;-&apos; || input[i] === &apos;*&apos;) &#123; let l = diffWaysToCompute(input.substring(0, i)); let r = diffWaysToCompute(input.substring(i + 1)); for (let j = 0; j &lt; l.length; j++) &#123; for (let k = 0; k &lt; r.length; k++) &#123; switch (input[i]) &#123; case &apos;+&apos;: ans.push(l[j] + r[k]); break; case &apos;-&apos;: ans.push(l[j] - r[k]); break; case &apos;*&apos;: ans.push(l[j] * r[k]); &#125; &#125; &#125; &#125; &#125; //如果全部都为数字，那就直接把这个字符串转换了过后放入数组 //也相当于递归边界 if(ans.length === 0)&#123; ans.push(parseInt(input)); &#125; return ans;&#125;; 2.使用一个map记录每一个input的值防止重复递归 1234567891011121314151617181920212223242526272829303132333435var diffWaysToCompute = function (input) &#123; let map = new Map(); function helper(input) &#123; let temp = map.get(input); if(temp) return temp; let len = input.length; let ans = []; for (let i = 0; i &lt; len; i++) &#123; if (input[i] === &apos;+&apos; || input[i] === &apos;-&apos; || input[i] === &apos;*&apos;) &#123; let l = diffWaysToCompute(input.substring(0, i)); let r = diffWaysToCompute(input.substring(i + 1)); for (let j = 0; j &lt; l.length; j++) &#123; for (let k = 0; k &lt; r.length; k++) &#123; switch (input[i]) &#123; case &apos;+&apos;: ans.push(l[j] + r[k]); break; case &apos;-&apos;: ans.push(l[j] - r[k]); break; case &apos;*&apos;: ans.push(l[j] * r[k]); &#125; &#125; &#125; &#125; &#125; if (ans.length === 0) &#123; ans.push(parseInt(input)); &#125; map.set(input,ans); return ans; &#125; return helper(input);&#125;; 2.不同的二叉搜索树 IIx 思路与上一个题类似 1234567891011121314151617181920212223242526272829var generateTrees = function (n) &#123; //如果n小于1则特判 if(n &lt; 1) return []; function helper(l, r) &#123;//由l-r组成的二叉搜索树 let ans = []; for (let i = l; i &lt;= r; i++) &#123; let leftChildren = helper(l,i - 1); let rightChildren = helper(i + 1,r); for(let j = 0;j &lt; leftChildren.length;j++)&#123; for(let k = 0;k &lt; rightChildren.length;k++)&#123; let root = new TreeNode(i); root.left = leftChildren[j]; root.right = rightChildren[k]; ans.push(root); &#125; &#125; &#125;//如果没有生成结点则要push一个null if(ans.length === 0)&#123; ans.push(null); &#125; return ans; &#125; return helper(1,n);&#125;; 搜索BFS1.二进制矩阵中的最短路径 1234567891011121314151617181920212223242526272829303132/** * @param &#123;number[][]&#125; grid * @return &#123;number&#125; */var shortestPathBinaryMatrix = function (grid) &#123; let directions = [[1, -1], [1, 0], [1, 1], [0, -1], [0, 1], [-1, -1], [-1, 0], [-1, 1]]; if (grid[0][0] === 1) return -1; if(grid[0][0] === 0 &amp;&amp; grid.length === 1) return 1; let queue = []; queue.push([0, 0]); let dis = 1; while (queue.length !== 0) &#123; let len = queue.length; dis++; for (let i = 0; i &lt; len; i++) &#123; let head = queue.shift(); [x, y] = head; for (let i = 0; i &lt; directions.length; i++) &#123; let direction = directions[i]; [new_x, new_y] = [x + direction[0], y + direction[1]]; if (new_x === grid.length - 1 &amp;&amp; new_y === grid.length - 1 &amp;&amp; grid[new_x][new_y] === 0) &#123; return dis; &#125; if (new_x &gt;= 0 &amp;&amp; new_x &lt; grid.length &amp;&amp; new_y &gt;= 0 &amp;&amp; new_y &lt; grid.length &amp;&amp; grid[new_x][new_y] === 0) &#123; queue.push([new_x, new_y]); grid[new_x][new_y] = 1; &#125; &#125; &#125; &#125; return -1;&#125;; 2.完全平方数x 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * @param &#123;number&#125; n * @return &#123;number&#125; */var numSquares = function (n) &#123; //首先打表获得小于等于n的完全平方数 function generateSquares(n) &#123; let squares = []; for (let i = 1; i * i &lt;= n; i++) &#123; squares.push(i * i); &#125; return squares; &#125; let squares = generateSquares(n); //再BFS找到个数 let q = []; let marked = []; q.push(n); marked[n] = false; let ans = 0; while (q.length !== 0) &#123; let len = q.length; ans++; for (let i = 0; i &lt; len; i++) &#123; let head = q.shift(); for (let j = 0; j &lt; squares.length; j++) &#123; let temp = head - squares[j]; //因为递增所以一旦开始小于0后面的也小于0 if(temp &lt; 0)&#123; break; &#125; if(temp === 0)&#123; return ans; &#125; if(marked[temp] === undefined)&#123; marked[temp] = false; q.push(temp); &#125; &#125; &#125; &#125; return ans;&#125;; 3.单词接龙x 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677/** * @param &#123;string&#125; beginWord * @param &#123;string&#125; endWord * @param &#123;string[]&#125; wordList * @return &#123;number&#125; */var ladderLength = function (beginWord, endWord, wordList) &#123; wordList.push(beginWord); //先判断一下endWord在词典中的位置，如果没有返回0 let end = 0; let start = wordList.length - 1; for (; end &lt; wordList.length; end++) &#123; if (wordList[end] === endWord) &#123; break; &#125; &#125; if (end === wordList.length) &#123; return 0; &#125; //再进行BFS let g = buildGraphic(wordList);//打一张临接表存储 let q = []; let marked = []; q.push(start); marked[start] = false; let ans = 0; while (q.length !== 0) &#123; ans++; let len = q.length; for (let i = 0; i &lt; len; i++) &#123; let f = q.shift(); if (f === end) &#123; return ans; &#125; for (let temp of g[f]) &#123; if (marked[temp] === undefined) &#123; marked[temp] = false; q.push(temp); &#125; &#125; &#125; &#125; return 0; //打表生成一个邻接表来存储每一个在wordList中的单词的连接关系 function buildGraphic(wordList) &#123; let graph = []; for (let i = 0; i &lt; wordList.length; i++) &#123; graph[i] = []; for (let j = 0; j &lt; wordList.length; j++) &#123; if (isConnect(wordList[i], wordList[j])) &#123;//如果相连 graph[i].push(j); &#125; &#125; &#125; return graph; &#125; //判断两个字符串能否改变一个字符就相等 //注意：完全相等返回false function isConnect(x, y) &#123; let temp = 0; for (let i = 0; i &lt; x.length; i++) &#123; if (x[i] !== y[i]) &#123; if (temp &gt; 1) &#123; return false; &#125; else &#123; temp++; &#125; &#125; &#125; return temp === 1; &#125;&#125;; DFS1.岛屿的最大面积* 123456789101112131415161718192021222324252627var maxAreaOfIsland = function (grid) &#123; directions = [[1, 0], [-1, 0], [0, 1], [0, -1]]; let m = grid.length; let n = grid[0].length; let result = 0; for (let i = 0; i &lt; m; i++) &#123; for (let j = 0; j &lt; n; j++) &#123; result = Math.max(result, dfs(grid, i, j)); &#125; &#125; return result; function dfs(grid, x, y) &#123; if (x &lt; 0 || y &lt; 0 || x &gt;= grid.length || y &gt;= grid[0].length || grid[x][y] === 0) &#123; return 0; &#125; grid[x][y] = 0; let ans = 1; for (let direction of directions) &#123; let new_x = x + direction[0]; let new_y = y + direction[1]; ans += dfs(grid, new_x, new_y); &#125; return ans; &#125;&#125;; 2.岛屿数量 12345678910111213141516171819202122232425262728293031/** * @param &#123;character[][]&#125; grid * @return &#123;number&#125; */var numIslands = function (grid) &#123; directions = [[1, 0], [-1, 0], [0, 1], [0, -1]]; let m = grid.length; let n = grid[0] ? grid[0].length : 0; let result = 0; for (let i = 0; i &lt; m; i++) &#123; for (let j = 0; j &lt; n; j++) &#123; result += dfs(grid, i, j); &#125; &#125; return result; function dfs(grid, x, y) &#123; if (x &lt; 0 || y &lt; 0 || x &gt;= m || y &gt;= n || grid[x][y] === &apos;0&apos;) &#123; return 0; &#125; grid[x][y] = &apos;0&apos;; for (let direction of directions) &#123; let new_x = x + direction[0]; let new_y = y + direction[1]; dfs(grid, new_x, new_y); &#125; return 1; &#125;&#125;; 3.朋友圈x 注意1:这个是一个nXn的对称矩阵2:朋友的传递看的是整行或整列不是矩阵相邻 123456789101112131415161718192021222324252627/** * @param &#123;number[][]&#125; M * @return &#123;number&#125; */var findCircleNum = function (M) &#123; let len = M.length; let result = 0; let visited = []; for (let i = 0; i &lt; len; i++) &#123; if (visited[i] === undefined) &#123; dfs(M, i); result++; &#125; &#125; return result; function dfs(M, x) &#123; visited[x] = true; for (let i = 0; i &lt; len; i++) &#123; if (M[x][i] === 1 &amp;&amp; visited[i] === undefined) &#123; M[x][i] = 0; dfs(M, i); &#125; &#125; &#125;&#125;; 4.被围绕的区域x 1234567891011121314151617181920212223242526272829303132333435363738/** * @param &#123;character[][]&#125; board * @return &#123;void&#125; Do not return anything, modify board in-place instead. */var solve = function (board) &#123; let directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]; let m = board.length; let n = board[0] ? board[0].length : 0; for (let i = 0; i &lt; m; i++) &#123; dfs(board, i, 0); dfs(board, i, n - 1); &#125; for (let i = 0; i &lt; n; i++) &#123; dfs(board, 0, i); dfs(board, m - 1, i); &#125; for (let i = 0; i &lt; m; i++) &#123; for (let j = 0; j &lt; n; j++) &#123; if (board[i][j] === &apos;T&apos;) &#123; board[i][j] = &apos;O&apos;; &#125; else if (board[i][j] === &apos;O&apos;) &#123; board[i][j] = &apos;X&apos;; &#125; &#125; &#125; return board; function dfs(board, x, y) &#123; if (x &lt; 0 || x &gt;= m || y &lt; 0 || y &gt;= n || board[x][y] !== &apos;O&apos;) &#123; return; &#125; board[x][y] = &apos;T&apos;; for (let direction of directions) &#123; dfs(board, x + direction[0], y + direction[1]); &#125; &#125;&#125;; 注意：1:边界上的O和与边界O相连的O是不会被围绕的，剩下的都是会被围绕的2:所以可以先求出所有边界O组成的联通区域先设成T，再遍历一次矩阵把O改为X，T改为O 5.太平洋大西洋水流问题x 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * @param &#123;number[][]&#125; matrix * @return &#123;number[][]&#125; */var pacificAtlantic = function (matrix) &#123; if (matrix == null || matrix.length === 0) &#123; return []; &#125; let directions = [[1, 0], [-1, 0], [0, 1], [0, -1]]; let m = matrix.length; let n = matrix[0].length; let ans = []; let canReachPcf = generateArray(m, n); let canReachAlt = generateArray(m, n); for (let i = 0; i &lt; m; i++) &#123; dfs(i, 0, canReachPcf); dfs(i, n - 1, canReachAlt); &#125; for (let i = 0; i &lt; n; i++) &#123; dfs(0, i, canReachPcf); dfs(m - 1, i, canReachAlt); &#125; for (let i = 0; i &lt; m; i++) &#123; for (let j = 0; j &lt; n; j++) &#123; if (canReachPcf[i][j] === true &amp;&amp; canReachAlt[i][j] === true) &#123; ans.push([i, j]); &#125; &#125; &#125; return ans; function generateArray(m, n) &#123; let res = []; for (let i = 0; i &lt; m; i++) &#123; res.push([]); &#125; return res; &#125; function dfs(x, y, canReach) &#123; if (canReach[x][y] === true) &#123; return; &#125; canReach[x][y] = true; for (let direction of directions) &#123; let new_x = x + direction[0]; let new_y = y + direction[1]; if (new_x &lt; 0 || new_x &gt;= m || new_y &lt; 0 || new_y &gt;= n || matrix[x][y] &gt; matrix[new_x][new_y]) &#123; continue; &#125; dfs(new_x, new_y, canReach); &#125; &#125;&#125;; 注意二维数组的创建问题同样是从边缘出发，找到能流到边缘的类 回溯一种优先搜索算法，枚举搜索尝试过程中找到解决方法，时间复杂度O(2^n)。 1.电话号码的字母组合* 123456789101112131415161718192021222324252627var letterCombinations = function(digits) &#123; if(digits.length === 0) return []; let hash = [0,1,&apos;abc&apos;,&apos;def&apos;,&apos;ghi&apos;,&apos;jkl&apos;,&apos;mno&apos;,&apos;pqrs&apos;,&apos;tuv&apos;,&apos;wxyz&apos;]; let ans = []; let temp = []; dfs(digits); return ans; //写个递归函数 function dfs(digits)&#123; //给一个递归终止条件 if(digits.length === 0)&#123; ans.push(temp.join(&apos;&apos;)); //数组转字符串 return; &#125; let c = digits[0]; let s = hash[parseInt(c)]; let len = s.length; for(let i = 0;i &lt; len;i++)&#123; temp.push(s[i]); dfs(digits.substring(1)); //(start,end)不包括end截取 temp.pop(); //在原数组上删除最后一个，若有变量承接，承接删除的元素 &#125; &#125;&#125;; 2.复原IP地址* 123456789101112131415161718192021222324252627282930313233var restoreIpAddresses = function(s) &#123; let ans = []; let temp = []; backTracking(s,0); return ans; function backTracking(s,intNumber)&#123; //若已有4组数且无剩余数字则添加返回，否则结束函数执行 if(intNumber === 4)&#123; if(s.length === 0)&#123; ans.push(temp.join(&apos;.&apos;)); &#125; return; &#125; let len = s.length; for(let i = 0;i &lt; len;i++)&#123; let part = s.substring(0,i + 1); //此处注意 //注意不能有两位数是0开头的 if(part[0] === &apos;0&apos; &amp;&amp; part.length &gt; 1)&#123; break; &#125; part = parseInt(part); //&gt;255则剪枝 if(part &gt; 255)&#123; break; &#125; temp.push(part); backTracking(s.substring(i + 1),intNumber + 1); temp.pop(); &#125; &#125;&#125;; 3.单词搜索x 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * @param &#123;character[][]&#125; board * @param &#123;string&#125; word * @return &#123;boolean&#125; */var exist = function (board, word) &#123; let directions = [[1, 0], [-1, 0], [0, 1], [0, -1]]; let m = board.length; let n = board[0].length; let visited = generateArray(m, n); //遍历整个board利用回溯法解决该问题 for (let i = 0; i &lt; m; i++) &#123; for (let j = 0; j &lt; n; j++) &#123; if (backtracking(visited, i, j, 0)) &#123; return true; &#125;; &#125; &#125; return false; //以某一个字母开始能不能通过DFS找到字符串的方式 function backtracking(visited, i, j, index) &#123; if (i &gt;= m || i &lt; 0 || j &gt;= n || j &lt; 0 || visited[i][j] === true || board[i][j] !== word[index]) &#123; return false; &#125; //为true的递归边界 if (index === word.length - 1) &#123; return true; &#125; visited[i][j] = true; for (let d of directions) &#123; let new_i = i + d[0]; let new_j = j + d[1]; if (backtracking(visited, new_i, new_j, index + 1)) &#123; return true; &#125;; &#125; //因为是有可能从一个起点开始只能满足部分的要求，所以如果这个点不行的话要把visited修改为false; visited[i][j] = false; return false; &#125; function generateArray(m, n) &#123; let res = []; for (let i = 0; i &lt; m; i++) &#123; res.push(new Array(n).fill(false)); &#125; //记得返回 return res; &#125;&#125;; 4.二叉树的所有路径** 12345678910111213141516171819202122232425262728293031323334353637383940414243var binaryTreePaths = function(root) &#123; let ans = []; let temp = []; helper(root); return ans; //回溯：回溯的本质就是遍历，就是在遍历的过程中去增加一些条件来筛选排序或者返回到上一层 //这种依托于另外一个功能的实现，在这个实现的基础上进行调整或者功能的组合在树中是应用得非常广泛的 function helper(root)&#123; if(!root)&#123; return; &#125; if(!root.left &amp;&amp; !root.right)&#123; temp.push(root.val); ans.push(temp.join(&quot;-&gt;&quot;)); temp.pop(); return; &#125; temp.push(root.val); helper(root.left); helper(root.right); temp.pop(); &#125;&#125;;*******************************************************************************//前序遍历更简单点var binaryTreePaths = function (root) &#123; let ans = []; function dfs(root, path) &#123; //传了参数，就不需要剪枝了，每层函数path不同的 if (root) &#123; path += root.val.toString(); if (root.left == null &amp;&amp; root.right == null) &#123; ans.push(path); &#125; else &#123; path += &apos;-&gt;&apos;; dfs(root.left, path); dfs(root.right, path); &#125; &#125; &#125; dfs(root, &apos;&apos;); return ans;&#125;; 5.全排列 12345678910111213141516171819202122232425var permute = function (nums) &#123; let len = nums.length; let pos = new Array(len).fill(0); let temp = []; let ans = []; backtracking(0);//添加参数 return ans; function backtracking(index) &#123; if(index &gt;= len)&#123; //注意push进去的是指针，要重新创建一个一样的数组放进去才行 let t = temp.slice(0); ans.push(t); return; &#125; for (let i = 0; i &lt; len; i++) &#123; if(pos[i] === 0)&#123; temp[i] = nums[index]; pos[i] = 1; backtracking(index + 1); pos[i] = 0; &#125; &#125; &#125;&#125;; 6.有重复值的全排列 12345678910111213141516171819202122232425262728293031323334var permuteUnique = function (nums) &#123; let len = nums.length; let visited = new Array(len).fill(0); nums.sort(function(x,y)&#123; return x - y; &#125;) let ans = []; let temp = []; backtracking(0); return ans; function backtracking(index) &#123; if (index &gt;= len) &#123; ans.push(temp.slice(0)); return; &#125; //对index位选一个数字放进去 for (let i = 0; i &lt; len; i++) &#123; // 防止重复 if (i !== 0 &amp;&amp; nums[i] === nums[i - 1] &amp;&amp; !visited[i - 1]) &#123; continue; &#125; //如果下标为i的数字没有放进去 if (visited[i] === 0) &#123; visited[i] = 1; temp.push(nums[i]); //然后递归排下一个位置 backtracking(index + 1); temp.pop(); visited[i] = 0; &#125; &#125; &#125;&#125;; 7.组合 123456789101112131415161718var combine = function (n, k) &#123; let result = []; let temp = []; backtracking(n, 1, 1 ,k); return result; function backtracking(n, num, start, k) &#123; if (num &gt; k) &#123; result.push(temp.slice(0)); return; &#125; for (let i = start; i &lt;= n; i++) &#123; temp.push(i); backtracking(n, num + 1, i + 1, k); temp.pop(); &#125; &#125;&#125;; 递归从这一次的数字+1开始，即start = i + 1 8.组合求和 1234567891011121314151617181920212223242526272829303132333435/** * @param &#123;number[]&#125; candidates * @param &#123;number&#125; target * @return &#123;number[][]&#125; */var combinationSum = function(candidates, target) &#123; candidates.sort(function(x,y)&#123; return x - y; &#125;) let len = candidates.length; let temp = []; let ans = []; let marked = new Array(len).fill(0); backtracking(0,0); return ans; function backtracking(sum,start)&#123; if(sum === target)&#123; ans.push(temp.slice(0)); return; &#125; if(sum &gt; target) return; for(let i = start;i &lt; len;i++)&#123; if(i &gt; 0 &amp;&amp; candidates[i] === candidates[i-1] &amp;&amp; marked[i - 1] === 0)&#123; continue; &#125; marked[i] = 1; temp.push(candidates[i]); backtracking(sum + candidates[i],i); temp.pop(); marked[i] = 0; &#125; &#125;&#125;; 9.组合总和 IIx 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * @param &#123;number[]&#125; candidates * @param &#123;number&#125; target * @return &#123;number[][]&#125; */var combinationSum2 = function (candidates, target) &#123; let temp = []; let ans = []; let len = candidates.length; let marked = new Array(len).fill(0); candidates.sort(function (x, y) &#123; return x - y; &#125;) backtracking(0, 0); return ans; function backtracking(start, sum) &#123; if (sum === target) &#123; ans.push(temp.slice(0)); return; &#125; for (let i = start; i &lt; len; i++) &#123; if (i &gt; 0 &amp;&amp; candidates[i - 1] === candidates[i] &amp;&amp; marked[i - 1] === 0) &#123; continue; &#125; if (sum &lt; target) &#123; temp.push(candidates[i]); sum += candidates[i]; marked[i] = 1; backtracking(i + 1, sum); temp.pop(); sum -= candidates[i]; marked[i] = 0; &#125; &#125; &#125;&#125;; 10.组合总和 III 123456789101112131415161718192021222324252627282930313233343536373839/** * @param &#123;number&#125; k * @param &#123;number&#125; n * @return &#123;number[][]&#125; */var combinationSum3 = function (k, n) &#123; let result = []; let temp = []; backtracking(n, 0, 1, k, 0); return result; function backtracking(n, num, start, k, sum) &#123; if (num === k) &#123; if (sum === n) &#123; result.push(temp.slice(0)); &#125; return; &#125; if (sum &gt; n) &#123; return; &#125; for (let i = start; i &lt;= 9; i++) &#123; if (sum &lt; n) &#123; temp.push(i); backtracking(n, num + 1, i + 1, k, sum + i); temp.pop(); &#125; &#125; &#125;&#125;; 11.子集 12345678910111213141516171819202122232425/** * @param &#123;number[]&#125; nums * @return &#123;number[][]&#125; */var subsets = function(nums) &#123; let temp = []; let ans = []; let len = nums.length; backtracking(0); return ans; function backtracking(i)&#123; if(i === len)&#123; ans.push(temp.slice(0)); return; &#125; temp.push(nums[i]); backtracking(i + 1); temp.pop(); backtracking(i + 1); &#125;&#125;; 12.子集 II 1234567891011121314151617181920212223242526272829303132333435363738394041/** * @param &#123;number[]&#125; nums * @return &#123;number[][]&#125; */var subsetsWithDup = function (nums) &#123; nums.sort(function (x, y) &#123; return x - y; &#125;) let len = nums.length; let temp = []; let ans = []; let marked = new Array(len).fill(0); backtracking(0,0); return ans; function backtracking(k,start) &#123;//已经放了k个位置和起始下标 if(k === len)&#123; ans.push(temp.slice(0)); return; &#125; for (let i = start; i &lt;= len; i++) &#123; if(i &gt; 0 &amp;&amp; nums[i] === nums[i - 1] &amp;&amp; marked[i - 1] === 0)&#123; continue; &#125; if (i === len) &#123; backtracking(k + 1,i); &#125; else &#123; temp.push(nums[i]); marked[i] = 1; backtracking(k + 1, i + 1); temp.pop(); marked[i] = 0; &#125; &#125; &#125;&#125;; 重复元素的处理套路，先排序，如果这个数和前一个相等并且前一个没有用到则跳过避免重复，这里使用了一个i === len来判断是否需要在k位置放入元素 13.分割回文串方法1: 使用了回溯法，遍历每一个子字符串长度为1，2，3…情况即第一个字符串长度1，2，3…len第二个为2,3,4…len… 1234567891011121314151617181920212223242526272829303132333435363738/** * @param &#123;string&#125; s * @return &#123;string[][]&#125; */var partition = function (s) &#123; let temp = []; let ans = []; let len = s.length; backtracking(0, len - 1); return ans; function backtracking(start, end) &#123; if (start &gt; end) &#123; ans.push(temp.slice(0)); return; &#125; for (let i = start; i &lt;= end; i++) &#123; if (isPalindrome(start, i)) &#123; temp.push(s.slice(start, i + 1)); backtracking(i + 1, end); temp.pop(); &#125; &#125; &#125; function isPalindrome(start, i) &#123; while (start &lt; i) &#123; if (s[start] !== s[i]) &#123; return false; &#125; start++; i--; &#125; return true; &#125;&#125;; 方法2:分治 将大问题分解为小问题，利用小问题的结果，解决当前大问题。 这道题的话，举个例子。 aabb先考虑在第 1 个位置切割，a | abb这样我们只需要知道 abb 的所有结果，然后在所有结果的头部把 a 加入abb 的所有结果就是 [a b b] [a bb]每个结果头部加入 a，就是 [a a b b] [a a bb] aabb再考虑在第 2 个位置切割，aa | bb这样我们只需要知道 bb 的所有结果，然后在所有结果的头部把 aa 加入bb 的所有结果就是 [b b] [bb]每个结果头部加入 aa,就是 [aa b b] [aa bb] aabb再考虑在第 3 个位置切割，aab|b因为 aab 不是回文串，所有直接跳过 aabb再考虑在第 4 个位置切割，aabb |因为 aabb 不是回文串，所有直接跳过 最后所有的结果就是所有的加起来[a a b b] [a a bb] [aa b b] [aa bb] 1234567891011121314151617181920212223242526272829303132333435363738394041/** * @param &#123;string&#125; s * @return &#123;string[][]&#125; */var partition = function (s) &#123; return partitionHelper(s); function partitionHelper(s) &#123; let ans = []; let len = s.length; for (let i = 0; i &lt; len; i++) &#123; let l = s.slice(0, i + 1); if (isPalindrome(l) === false) continue; let r = partitionHelper(s.slice(i + 1, len)); for (let j = 0; j &lt; r.length; j++) &#123; r[j].unshift(l); let temp = r[j]; ans.push(temp.slice(0)); &#125; &#125; if (ans.length === 0) ans.push([]); return ans; &#125; function isPalindrome(s) &#123; let start = 0; let end = s.length - 1; while (start &lt; end) &#123; if (s[start] !== s[end]) &#123; return false; &#125; start++; end--; &#125; return true; &#125;&#125;; 方法3:分治 + 动态规划先打表生成dp数组存储位置start,end的对应字符串是否是回文的就是利用了动态规划的思想判断是否一个字符串是回文字符串 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * @param &#123;string&#125; s * @return &#123;string[][]&#125; */var partition = function (s) &#123; let dp = generateArray(s.length, s.length); //生成dp[start][end]是否为回文序列的dp数组 for (let len = 1; len &lt;= s.length; len++) &#123;//长度为len for (let i = 0; i &lt;= s.length - len; i++) &#123;//起始下标为i let j = i + len - 1; dp[i][j] = s[i] === s[j] &amp;&amp; (len &lt; 3 || dp[i + 1][j - 1]) ? 1 : 0; &#125; &#125; return partitionHelper(0, s.length - 1); function partitionHelper(start, end) &#123; let ans = []; for (let i = start; i &lt;= end; i++) &#123; let l = s.slice(start, i + 1); if (dp[start][i] === 0) continue; let r = partitionHelper(i + 1, end); for (let j = 0; j &lt; r.length; j++) &#123; r[j].unshift(l); let temp = r[j]; ans.push(temp.slice(0)); &#125; &#125; if (ans.length === 0) ans.push([]); return ans; &#125; function generateArray(m, n) &#123; let res = []; for (let i = 0; i &lt; m; i++) &#123; res.push(new Array(n).fill(0)); &#125; return res; &#125;&#125;; 动态规划(DP)斐波那契数列*1.斐波那契数列* 1234567891011121314151617181920212223var fib = function (n) &#123; if(n&lt;=1) return n; let dp = []; dp[0] = 0; dp[1] = 1; for (let i = 2; i &lt;= n; i++) &#123; dp[i] = dp[i - 1] + dp[i - 2]; &#125; return dp[n];&#125;;//时间复杂度O(n),空间复杂度O(n),因为需要记录整个序列。var fib = function (n) &#123; if (n &lt;= 1) return n; let dp = []; dp[0] = 0; dp[1] = 1; for (let i = 2; i &lt;= n; i++) &#123; let sum = dp[0] + dp[1]; //仅用两个值即可 dp[0] = dp[1]; dp[1] = sum; &#125; return dp[1];&#125;;//时间复杂度O(n),空间复杂度O(1)。 2.爬楼梯 方法1:若n=5，爬1级，则剩下4级要爬；爬2级，则剩下3级要爬；爬4级有几种方式？爬3级有几种方式？于是，爬 5 级楼梯的方式数 = 爬 4 级楼梯的方式数 + 爬 3 级楼梯的方式数。逐渐向下划分：1级时，1种，2级时，2种，作为基础层。题目要求正整数，所以不划分0级和1级。 123456789101112131415var climbStairs = function (n) &#123; let dip = []; dip[1] = 1; dip[2] = 2; //基础层 for (let i = 3; i &lt;= n; i++) &#123; //向上一直找到n dip[i] = dip[i - 1] + dip[i - 2]; &#125; return dip[n];&#125;;//时间复杂度O(n),空间复杂度O(n)//面试官要求优化的话：for (let i = 3; i &lt;= n; i++) &#123; let sum = dp[1] + dp[2]; //仅用两个值即可 dp[1] = dp[2]; dp[2] = sum; &#125; 递归式：f(n) = f(n-1) + f(n-2); 3.最小花费爬楼梯 123456789101112131415var minCostClimbingStairs = function (cost) &#123; let dp = []; let len = cost.length; dp[0] = cost[0]; //数组下标从0开始 dp[1] = cost[1]; for (let i = 2; i &lt;= len; i++) &#123; dp[i] = Math.min(dp[i - 1], dp[i - 2]) + cost[i]; &#125; return Math.min(dp[len - 1], dp[len - 2]); //注意最后一步可以理解为不用花费，所以取倒数第一步，第二步的最小值&#125;; //同样的，for循环中还可以优化成，空间复杂度O(n)let dpi = min(dp[0], dp[1]) + cost[i]; dp[0] = dp[1]; // 记录一下前两位 dp[1] = dpi; 4.打家劫舍 正向递推（最优） 此处动态规划方程：dp[n] = MAX( dp[n-1], dp[n-2] + num )，num为最后一位。 1234567891011var rob = function (nums) &#123; let len = nums.length; if (len == 0) return 0; let dp = []; dp[0] = 0; dp[1] = nums[0]; for (let i = 2; i &lt;= len; i++) &#123; dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i - 1]); &#125; return dp[len];&#125;; 4.打家劫舍 II 12345678910111213141516171819202122//掐头去尾，考虑两种情况：偷第1间；不偷第1间，偷最后1间，这两种情况就包括了两间都不偷的情况。所以我们可以将数组分为含有第1间房和不含第1间房的两个数组。var rob = function (nums) &#123; let len = nums.length; if (len == 0) return 0; if (len == 1) return nums[0]; //特殊情况 let nums1 = nums.slice(0, len - 1); let nums2 = nums.slice(1); //在两个数组上运用常规打家劫舍问题 function rober(nums) &#123; let dp = []; dp[0] = 0; dp[1] = nums[0]; for (let i = 2; i &lt;= nums.length; i++) &#123; dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i - 1]); &#125; return dp[nums.length]; &#125; let ans1 = rober(nums1); let ans2 = rober(nums2); return Math.max(ans1, ans2);&#125;; 与上一个题的思路类似，只是分成两种情况来比大小 5.母牛生产每一年成熟的牛 = 去年成熟的牛 + 3年前成熟的牛生产出的牛（3年后成熟了） 12345678910var rob = function (n) &#123; let dp = []; dp[1] = 1; //第一年1头 dp[2] = 2; //第二年2头 dp[3] = 3; //第三年3头 for (let i = 4; i &lt;= n; i++) &#123; dp[i] = dp[i - 1] + dp[i - 3]; &#125; return dp[n];&#125; 矩阵的最小路径和1.找第一行，第一列的边界情况——2.双层for循环——3.动态方程 1.最小路径和 12345678910111213141516171819202122//动态规划方程：当前项最小路径和 = 当前项值 + 上项或左项中的最小值// grid[i][j] += Math.min( grid[i - 1][j], grid[i][j - 1] )var minPathSum = function (grid) &#123; let row = grid.length; //行数 let col = grid[0].length; //列数 let dp = grid; //二维数组没办法直接定义 //grid的第一行与第一列 分别没有上项与左项 故单独处理计算起项最小路径和，第一行： for (let j = 1; j &lt; col; j++) &#123; dp[0][j] += dp[0][j - 1]; &#125; //第一列： for (let i = 1; i &lt; row; i++) &#123; dp[i][0] += dp[i - 1][0]; &#125; //二维数组，双循环 for (let i = 1; i &lt; row; i++) &#123; //首先行数 for (let j = 1; j &lt; col; j++) &#123; dp[i][j] += Math.min(dp[i - 1][j], dp[i][j - 1]); &#125; &#125; return dp[row - 1][col - 1];&#125;; 方法2:正向递推 一维dp 1234567891011121314151617181920var minPathSum = function (grid) &#123; let m = grid.length; let n = grid[0].length; //只需要用一个一维的数组保存纵向上的结果即可 let dp = new Array(n).fill(0); for (let i = 0; i &lt; m; i++) &#123; for (let j = 0; j &lt; n; j++) &#123; if (j === 0) &#123; dp[j] = dp[j]; &#125; else if (i === 0) &#123; dp[j] = dp[j - 1]; &#125;else&#123; dp[j] = Math.min(dp[j],dp[j - 1]); &#125; dp[j] += grid[i][j]; &#125; &#125; return dp[n-1];&#125;; 也可以选择直接在原数组上修改就不占多余的空间 2.不同路径 12345678910111213141516171819202122232425262728//第一行和第一列都可以设置为1，此方法从第二行第二列开始逐行向右计算路径。var uniquePaths = function (m, n) &#123; let dp = new Array(n).fill(1); for (let i = 1; i &lt; m; i++) &#123; for (let j = 1; j &lt; n; j++) &#123; dp[j] += dp[j - 1]; &#125; &#125; return dp[n - 1];&#125;; //时间复杂度(m*n)，空间复杂度O(n)//和上题思路一样var uniquePaths = function (m, n) &#123; let dp = new Array(m); //构建二维数组，先构建一维数组，再for循环 for (let i = 0; i &lt; m; i++) &#123; dp[i] = new Array(n); dp[i][0] = 1; &#125; for (let s = 1; s &lt; n; s++) &#123; //从1开始了 dp[0][s] = 1; &#125; for (let i = 1; i &lt; m; i++) &#123; for (let j = 1; j &lt; n; j++) &#123; dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; &#125; &#125; return dp[m - 1][n - 1];&#125;; //时间复杂度(m*n)，空间复杂度O(m*n) 3.有障碍的不同路径 12345678910111213141516171819202122232425262728293031var uniquePathsWithObstacles = function (obstacleGrid) &#123; let m = obstacleGrid.length; let n = obstacleGrid[0].length; let dp = obstacleGrid; if (dp[0][0] == 1) return 0; //第一格有障碍情况，特殊处理 dp[0][0] = 1; //第一格单独提出赋值 for (let i = 1; i &lt; m; i++) &#123; //第二格起遍历该列 if (dp[i][0] == 0) &#123; dp[i][0] = dp[i - 1][0]; //遇到0，把前值赋给它————此处有利于处理一列有多个障碍情况** &#125; else &#123; dp[i][0] = 0; //遇到1，赋值为0 &#125; &#125; for (let j = 1; j &lt; n; j++) &#123; //第一行处理 if (dp[0][j] == 0) &#123; dp[0][j] = dp[0][j - 1]; &#125; else &#123; dp[0][j] = 0; &#125; &#125; for (let i = 1; i &lt; m; i++) &#123; //第二行第二列起逐行遍历 for (let j = 1; j &lt; n; j++) &#123; if (dp[i][j] == 1) &#123; dp[i][j] = 0; continue; &#125; dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; &#125; &#125; return dp[m - 1][n - 1];&#125; 数组区间(未看)1.区域和检索 - 数组不可变 12345678910111213141516171819202122232425/** * @param &#123;number[]&#125; nums */var NumArray = function (nums) &#123; this.nums = nums; this.sum = [nums[0]]; for (let i = 1; i &lt; nums.length; i++) &#123; this.sum[i] = this.sum[i - 1] + nums[i]; &#125;&#125;;/** * @param &#123;number&#125; i * @param &#123;number&#125; j* @return &#123;number&#125;*/NumArray.prototype.sumRange = function (i, j) &#123; return this.sum[j] - this.sum[i] + this.nums[i];&#125;;/** * Your NumArray object will be instantiated and called as such: * var obj = new NumArray(nums) * var param_1 = obj.sumRange(i,j) */ i - j的区间和等于 0-j的和 减去 0-i的和 + nums[i] 2.等差数列划分方法一：参照求回文字符串的方法，但是这里这种方法很慢是O（n2）级别的 12345678910111213141516171819202122/** * @param &#123;number[]&#125; A * @return &#123;number&#125; */var numberOfArithmeticSlices = function (A) &#123; let len = A.length; let dp = new Array(len).fill(1); let ans = 0; for (let l = 3; l &lt;= len; l++) &#123;//l为len for (let i = 0; i &lt; len - l + 1; i++) &#123;//起始位置为i let gap1 = A[i + l - 1] - A[i + l - 2]; let gap2 = A[i + 1] - A[i]; dp[i] = gap1 === gap2 &amp;&amp; dp[i] === 1 ? 1 : 0; if (dp[i] === 1) &#123; ans++; &#125; &#125; &#125; return ans;&#125;; 方法二：起始不需要关心起点在哪里，只需要关心终点在哪里就可以了递归式：以i为结束的等差子数组个数:dp[i] = dp[i - 1] + 1如果A[i] - A[i - 1] === A[i - 1] - A[i - 2]，这里的1是指A[i] A[i-1] A[i - 2]否则就为0 1234567891011121314151617181920/** * @param &#123;number[]&#125; A * @return &#123;number&#125; */var numberOfArithmeticSlices = function (A) &#123; let len = A.length; let dp = new Array(len).fill(0); let ans = 0; for (let i = 2; i &lt; len; i++) &#123;//以i为结尾的字符串 if (A[i] - A[i - 1] === A[i - 1] - A[i - 2]) &#123; dp[i] = dp[i - 1] + 1; ans += dp[i]; &#125; else &#123; dp[i] = 0; &#125; &#125; return ans;&#125;; 分割整数1.定义数组——2.初始化dp[0]/dp[1]——3.双层for循环——4.动态方程 1. 整数拆分x 方法1:用数组保存结果，但是过不了时间 12345678910111213141516var integerBreak = function (n) &#123; let dp = []; function helper(n) &#123; if (n === 2) return 1; if(dp[n] !== undefined)&#123; return dp[n]; &#125; let ans = 0; for (let i = 1; i &lt; n; i++) &#123; ans = Math.max(integerBreak(n - i) * i, (n - i) * i, ans); &#125; dp[n] = ans; return ans; &#125; return helper(n);&#125;; 方法2:正向递推,从递推边界开始向上走 1234567891011//此题公式：dp[i] = Math.max(dp[i],dp[i - j] * j,j * (i - j)); 为何j不用拆分，不写成dp[j]的形式，因j是从1开始遍历，拆分j的情况，在遍历j的过程中其实都计算过了。var integerBreak = function (n) &#123; let dp = new Array(n + 1).fill(0); //后面用dp[i]，此处不能dp=[]，要赋初始值0. dp[2] = 1; //dp[0]dp[1]在拆分中是没有意义的，不做定义 for(let i = 3;i &lt;= n;i++)&#123; //该遍历用于计算从3到n，每个数的最大乘积 for(let j = 1;j &lt; i;j++)&#123; //该遍历用于计算具体某个数的最大乘积 dp[i] = Math.max(dp[i],dp[i - j] * j,j * (i - j)); //此处用了dp[i]来比，所以要给dp初始值 &#125; &#125; return dp[n];&#125;;O(n^2)和O(n) 2.完全平方数x方法: 使用dp 12345678910111213141516171819202122var numSquares = function (n) &#123; //首先获得小于等于n的完全平方数 function generateSquares(n) &#123; let squares = []; for (let i = 1; i * i &lt;= n; i++) &#123; squares.push(i * i); &#125; return squares; &#125; let squares = generateSquares(n); let dp = new Array(n + 1).fill(9999999); dp[0] = 0; dp[1] = 1; dp[2] = 2;//给一个初始值 for (let i = 3; i &lt;= n; i++) &#123;//从3开始的每一个数都要求一次 for (let j = 0; squares[j] &lt;= i; j++) &#123;//遍历所有小于i的完全平方数 dp[i] = Math.min(dp[i - squares[j]] + 1, dp[i]); &#125; &#125; return dp[n];&#125;; 方法2:贪心 + DP（以后再看） 3.解码方法 1234567891011121314151617181920212223242526272829303132/** * @param &#123;string&#125; s * @return &#123;number&#125; */var numDecodings = function (s) &#123; if (s[0] === &apos;0&apos;) return 0; let len = s.length; let dp = new Array(len).fill(0); dp[0] = s[0] === &apos;0&apos; ? 0 : 1; for (let i = 1; i &lt; len; i++) &#123; let temp = parseInt(s[i - 1] + s[i]); if (s[i] === &apos;0&apos;) &#123; if (s[i - 1] === &apos;0&apos; || temp &gt; 26) &#123; return 0; &#125; dp[i] = dp[i - 2] || 1; &#125;else&#123; if(s[i - 1] === &apos;0&apos; || temp &gt; 26)&#123; dp[i] = dp[i - 1]; &#125;else&#123;//注意若没有0且可以组成新数的递归关系，即s[i]都可以加到dp[i-1]中，s[i] + s[i-1]都可以加到dp[i-2]中 dp[i] = dp[i - 1] + (dp[i - 2]||1); &#125; &#125; &#125; return dp[len - 1];&#125;; 最长递增子序列1. 最长上升子序列方法1:DP 123456789101112131415161718192021/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var lengthOfLIS = function (nums) &#123; if(nums.length === 0) return 0; let dp = new Array(nums.length).fill(1); dp[0] = 1; let ans = 1; for (let i = 1; i &lt; nums.length; i++) &#123; let temp = 0; for(let j = 0;j &lt; i;j++)&#123; if(nums[i] &gt; nums[j])&#123; temp = Math.max(temp,dp[j]); &#125; &#125; dp[i] = temp + 1; ans = Math.max(ans,dp[i]); &#125; return ans;&#125;; 方法2: 二分查找（之后补上） 2. 最长数对链思路与上一题类似，但是需要先排序 1234567891011121314151617181920212223242526/** * @param &#123;number[][]&#125; pairs * @return &#123;number&#125; */var findLongestChain = function (pairs) &#123; let len = pairs.length; //首先以每一个pair的第一个元素排序 pairs.sort(function (x, y) &#123; return x[0] - y[0]; &#125;) let dp = new Array(len).fill(1); let ans = 1; for (let i = 0; i &lt; len; i++) &#123; for (let j = i - 1; j &gt;= 0; j--) &#123; if (pairs[i][0] &gt; pairs[j][1]) &#123; dp[i] = Math.max(dp[j] + 1, dp[i]); ans = Math.max(ans,dp[i]); &#125; &#125; &#125; return ans;&#125;; 3.摆动序列x方法1:与上一个题思路类似的解法 12345678910111213141516171819202122232425262728/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var wiggleMaxLength = function (nums) &#123; if(nums.length === 0) return 0; let len = nums.length; let dp = new Array(len).fill(0); dp[0] = 1; let ans = 1; for (let i = 1; i &lt; len; i++) &#123; for (let j = i - 1; j &gt;= 0; j--) &#123; let sub1 = nums[i] - nums[j]; let sub2 = j &lt; 1 ? -sub1 : nums[j] - nums[j - 1]; if (sub1 * sub2 &lt; 0)&#123; dp[i] = Math.max(dp[j] + 1,dp[i]); ans = Math.max(ans,dp[i]); &#125; &#125; &#125; return ans;&#125;; 方法2:up[i] 存的是目前为止最长的以第 i 个元素结尾的上升摆动序列的长度(不一定要取i)。down[i] 记录的是目前为止最长的以第 i 个元素结尾的下降摆动序列的长度(不一定要取i)。 1234567891011121314151617181920212223/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var wiggleMaxLength = function (nums) &#123; if(nums.length === 0) return 0; let up = 1; let down = 1; let len = nums.length; for(let i = 1;i &lt; len;i++)&#123; if(nums[i] &gt; nums[i - 1])&#123; up = down + 1; &#125;else if(nums[i] &lt; nums[i-1])&#123; down = up + 1; &#125; &#125; return Math.max(up,down);&#125;; 方法：贪心（之后补充） 最长公共子序列1.最长公共子序列 注意这类问题要确定最后一个元素是确定取还是不取 12345678910111213141516171819202122232425var longestCommonSubsequence = function (text1, text2) &#123; let len1 = text1.length; let len2 = text2.length; let dp = generateArray(len1 + 1, len2 + 1); for (let i = 0; i &lt; len1; i++) &#123; for (let j = 0; j &lt; len2; j++) &#123; if (text1[i] === text2[j]) &#123; dp[i + 1][j + 1] = dp[i][j] + 1; &#125; else &#123; dp[i + 1][j + 1] = Math.max(dp[i][j + 1], dp[i + 1][j]); &#125; &#125; &#125; return dp[len1][len2]; function generateArray(m, n) &#123; let res = []; for (let i = 0; i &lt; m; i++) &#123; res.push(new Array(n).fill(0)); &#125; return res; &#125;&#125;; 01背包有一个容量为 N 的背包，要用这个背包装下物品的价值最大，这些物品有两个属性：体积 w 和价值 v。 定义一个二维数组 dp 存储最大价值，其中 dp[i][j] 表示前 i 件物品体积不超过 j 的情况下能达到的最大价值。设第 i 件物品体积为 w，价值为 v，根据第 i 件物品是否添加到背包中，可以分两种情况讨论： 第 i 件物品没添加到背包，总体积不超过 j 的前 i 件物品的最大价值就是总体积不超过 j 的前 i-1 件物品的最大价值，dp[i][j] = dp[i-1][j]。第 i 件物品添加到背包中，dp[i][j] = dp[i-1][j-w] + v。第 i 件物品可添加也可以不添加，取决于哪种情况下最大价值更大。因此，0-1 背包的状态转移方程为： 1.二维的01背包 12345678910111213141516171819202122232425262728293031//二维01背包问题// W 为背包总体积// N 为物品数量// weights 数组存储 N 个物品的重量// values 数组存储 N 个物品的价值function knapsack(W, N, weights, values) &#123; let dp = generate2DimentionArray(N,W); for (let i = 1; i &lt;= N; i++) &#123; let w = weights[i - 1]; let val = values[i - 1]; for (let j = 1; j &lt;= W; j++) &#123; if (j &gt;= w) &#123; //不拿 //拿了 dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - w] + val); &#125; else &#123; dp[i][j] = dp[i-1][j]; //不拿该物体 &#125; &#125; &#125; return dp[N][W]; function generate2DimentionArray(N,W) &#123; let arr = new Array(N + 1); for (let i = 0; i &lt; N + 1; i++) &#123; arr[i] = (new Array(W + 1).fill(0)); &#125; return arr; &#125;&#125;console.log(knapsack(10,4,[3,4,10,2],[1,2,100,4])); 2.空间优化（注意对体积要从大到小遍历） 123456789101112131415function knapsack(W, N, weights, values) &#123; let dp = new Array(W + 1).fill(0); for (let i = 1; i &lt;= N; i++) &#123; let w = weights[i - 1]; let v = values[i - 1]; for (let j = W; j &gt;= 1; j--) &#123; if (j &gt;= w) &#123; dp[j] = Math.max(dp[j], dp[j - w] + v); &#125; &#125; &#125; return dp[W];&#125;console.log(knapsack(10, 4, [3, 4, 10, 2], [1, 2, 100, 4])); 1.分割等和子集 1234567891011121314151617181920var canPartition = function (nums) &#123; let len = nums.length; let sum = 0; for (let i = 0; i &lt; len; i++) &#123; sum += nums[i]; &#125; if (sum % 2 === 1) return false; let W = sum / 2; let dp = new Array(W + 1).fill(false);//注意是重量 dp[0] = true; //如果使用一维dp数组，物品遍历的for循环放在外层，遍历背包的for循环放在内层，且内层for循环倒叙遍历！ for (let i = 1; i &lt; len; i++) &#123; for (let j = W; j &gt;= nums[i]; j--) &#123; // 每一个元素一定是不可重复放入，所以从大到小遍历 dp[j] = Math.max(dp[j], dp[j - nums[i]] + nums[i]); &#125; &#125; if (dp[W] == W) return true; return false;&#125;; //O(n)和O(n) 2.目标和 方法1:DFS 1234567891011121314151617181920var findTargetSumWays = function (nums, S) &#123; let len = nums.length; let ans = 0; dfs(0,0); function dfs(i, sum) &#123; if (i === len) &#123; if (sum === S) &#123; ans++; &#125; return; &#125; sum += nums[i]; dfs(i + 1, sum); sum = sum - nums[i] * 2; dfs(i + 1, sum); &#125; return ans;&#125;; 方法2:动态规划该问题可以转换为 Subset Sum 问题，从而使用 0-1 背包的方法来求解。 可以将这组数看成两部分，P 和 N，其中 P 使用正号，N 使用负号，有以下推导： sum(P) - sum(N) = targetsum(P) + sum(N) + sum(P) - sum(N) = target + sum(P) + sum(N) 2 * sum(P) = target + sum(nums) 因此只要找到一个子集，令它们都取正号，并且和等于 (target + sum(nums))/2，就证明存在解。 123456789101112131415161718192021var findTargetSumWays = function (nums, S) &#123; let len = nums.length; let sum = 0; for (let i = 0; i &lt; len; i++) &#123; sum += nums[i]; &#125; if (sum &lt; S || (sum + S) % 2 === 1) return 0;//如果sum &lt; S也不可能达成目标并且避免了数组开的过大 let W = (sum + S) / 2; let dp = new Array(W + 1).fill(0); dp[0] = 1;//这里是数个数所以是从1开始 for (let i = 0; i &lt; len; i++) &#123; for (let j = W; j &gt;= nums[i]; j--) &#123; dp[j] = dp[j] + dp[j - nums[i]];//注意递归式，不选的个数加上选的个数 &#125; &#125; return dp[W];&#125;; 3.一和零资源为多维的01背包 1234567891011121314151617181920212223242526272829303132333435363738/** * @param &#123;string[]&#125; strs * @param &#123;number&#125; m * @param &#123;number&#125; n * @return &#123;number&#125; */var findMaxForm = function (strs, m, n) &#123; function generateArray(m, n) &#123; let res = []; for (let i = 0; i &lt; m; i++) &#123; res.push(new Array(n).fill(0)); &#125; return res; &#125; let len = strs.length; let dp = generateArray(m + 1, n + 1); for (let i = 0; i &lt; len; i++) &#123; //数str中的01个数 let ones = 0; let zeros = 0; for (let item of strs[i]) &#123; if (item === &apos;0&apos;) zeros++; else ones++; &#125; for (let j = m; j &gt;= zeros; j--) &#123;//多维也要从后往前遍历 for (let k = n; k &gt;= ones; k--) &#123; dp[j][k] = Math.max(dp[j][k], dp[j - zeros][k - ones] + 1); &#125; &#125; &#125; return dp[m][n];&#125;; 4.零钱兑换完全背包问题:背包容量无限 123456789101112131415161718192021/** * @param &#123;number[]&#125; coins * @param &#123;number&#125; amount * @return &#123;number&#125; */var coinChange = function (coins, amount) &#123; if(amount === 0) return 0; let dp = new Array(amount + 1).fill(0); for(let coin of coins)&#123; for(let i = coin;i &lt;= amount;i++)&#123; if(i === coin)&#123; dp[i] = 1; &#125;else if(dp[i] === 0 &amp;&amp; dp[i - coin] !== 0)&#123; dp[i] = dp[i - coin] + 1; &#125;else if(dp[i] !== 0 &amp;&amp; dp[i - coin] !== 0)&#123; dp[i] = Math.min(dp[i],dp[i - coin] + 1); &#125; &#125; &#125; return dp[amount] == 0 ? -1 : dp[amount];&#125;; 递推式：dp[coin][i] = Math.min(dp[coin - 1][i],dp[coin][i-coins[amount]] + 1) 5.零钱兑换 II/** @param {number} amount @param {number[]} coins @return {number} /var change = function (amount, coins) { let dp = new Array(amount + 1).fill(0); dp[0] = 1; for (let coin of coins) { for (let i = coin; i &lt;= amount; i++) { dp[i] += dp[i - coin]; } } return dp[amount]; }; 6.单词拆分 123456789101112131415161718/** * @param &#123;string&#125; s * @param &#123;string[]&#125; wordDict * @return &#123;boolean&#125; */var wordBreak = function(s, wordDict) &#123; let len = s.length; let dp = new Array(len + 1).fill(false); dp[0] = true; for(let i = 1;i &lt;= len;i++)&#123;//要从包的容量遍历起，这样才能考虑顺序 for(let word of wordDict)&#123; if(i &gt;= word.length &amp;&amp; s.slice(i - word.length, i) === word)&#123; dp[i] = dp[i] || dp[i - word.length]; &#125; &#125; &#125; return dp[len];&#125;; 7.组合总和 Ⅳ 1234567891011121314151617/** * @param &#123;number[]&#125; nums * @param &#123;number&#125; target * @return &#123;number&#125; */var combinationSum4 = function(nums, target) &#123; let dp = new Array(target + 1).fill(0); dp[0] = 1; for(let i = 1;i &lt;= target;i++)&#123; for(let num of nums)&#123; if(num &lt;= i)&#123; dp[i] += dp[i - num]; &#125; &#125; &#125; return dp[target];&#125;; 股票问题base case：dp[-1][k][0] = dp[i][0][0] = 0dp[-1][k][1] = dp[i][0][1] = -infinity 状态转移方程：dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]) k=1(也可以用贪心来解决)dp[i][1][0] = max(dp[i-1][1][0], dp[i-1][1][1] + prices[i])dp[i][1][1] = max(dp[i-1][1][1], dp[i-1][0][0] - prices[i]) = max(dp[i-1][1][1], -prices[i])解释：k = 0 的 base case，所以 dp[i-1][0][0] = 0。 现在发现 k 都是 1，不会改变，即 k 对状态转移已经没有影响了。可以进行进一步化简去掉所有 k：dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])dp[i][1] = max(dp[i-1][1], -prices[i]) 12345678910111213/** * @param &#123;number[]&#125; prices * @return &#123;number&#125; */var maxProfit = function (prices) &#123; let dp_0 = 0; let dp_1 = Number.MIN_SAFE_INTEGER;//因为第0天还没有开始交易又持有的情况不可能发生 prices.forEach(function (price) &#123; dp_0 = Math.max(dp_0, dp_1 + price); dp_1 = Math.max(dp_1, -price); &#125;) return dp_0;&#125;; k=无穷(也可以用贪心来解决)dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])dp[i][1] = max(dp[i-1][1], dp[i-1][0]-prices[i]) 1234567891011121314/** * @param &#123;number[]&#125; prices * @return &#123;number&#125; */var maxProfit = function(prices) &#123; let dp_0 = 0; let dp_1 = Number.MIN_SAFE_INTEGER; prices.forEach((price)=&gt;&#123; let temp = dp_0; dp_0 = Math.max(dp_0,dp_1 + price); dp_1 = Math.max(dp_1,temp - price); &#125;) return dp_0;&#125;; k = +infinity with cooldowndp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])dp[i][1] = max(dp[i-1][1], dp[i-2][0]-prices[i]) 12345678910111213141516/** * @param &#123;number[]&#125; prices * @return &#123;number&#125; */var maxProfit = function(prices) &#123; let dp_0 = 0; let dp_1 = Number.MIN_SAFE_INTEGER; let dp_pre_0 = 0; prices.forEach((price)=&gt;&#123; let temp = dp_0; dp_0 = Math.max(dp_0,dp_1+price); dp_1 = Math.max(dp_1,dp_pre_0-price); dp_pre_0 = temp; &#125;) return dp_0;&#125;; k = +infinity with feedp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i] - fee)dp[i][1] = max(dp[i-1][1], dp[i-1][0]-prices[i]) 123456789101112131415/** * @param &#123;number[]&#125; prices * @param &#123;number&#125; fee * @return &#123;number&#125; */var maxProfit = function(prices, fee) &#123; let dp_0 = 0; let dp_1 = Number.MIN_SAFE_INTEGER; prices.forEach(function(price)&#123; let temp = dp_0; dp_0 = Math.max(dp_0,dp_1 + price - fee); dp_1 = Math.max(dp_1,temp - price); &#125;) return dp_0;&#125;; k=2dp[i][2][0] = max(dp[i-1][2][0], dp[i-1][2][1] + prices[i])dp[i][2][1] = max(dp[i-1][2][1], dp[i-1][1][0] - prices[i])dp[i][1][0] = max(dp[i-1][1][0], dp[i-1][1][1] + prices[i])dp[i][1][1] = max(dp[i-1][1][1], - prices[i])根据公示只需要4个变量就可以，并且先算k=2，再算k=1会有更好的效果，不用一个临时变量来进行存储 1234567891011121314151617/** * @param &#123;number[]&#125; prices * @return &#123;number&#125; */var maxProfit = function (prices) &#123; let dp_2_0 = 0; let dp_2_1 = Number.MIN_SAFE_INTEGER; let dp_1_0 = 0; let dp_1_1 = Number.MIN_SAFE_INTEGER; prices.forEach(function (price) &#123; dp_2_0 = Math.max(dp_2_0, dp_2_1 + price); dp_2_1 = Math.max(dp_2_1, dp_1_0 - price); dp_1_0 = Math.max(dp_1_0, dp_1_1 + price); dp_1_1 = Math.max(dp_1_1, -price); &#125;) return dp_2_0;&#125;; k=任意值 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * @param &#123;number&#125; k * @param &#123;number[]&#125; prices * @return &#123;number&#125; */var maxProfit = function (k, prices) &#123; let temp = prices.length / 2; if (k &gt;= temp) &#123;//如果k值大于prices的长度除2，问题退化为k为无限 let dp_0 = 0; let dp_1 = Number.MIN_SAFE_INTEGER; prices.forEach(function (price) &#123; let temp = dp_0; dp_0 = Math.max(dp_0, dp_1 + price); dp_1 = Math.max(dp_1, temp - price); &#125;) return dp_0; &#125; else &#123; let len = prices.length; let dp = createArray(len + 1, k + 1); //初始化dp[0][k][1] = -infinity,dp[i][0][1] = -infinity for (let i = 0; i &lt;= k; i++) &#123; dp[0][i][1] = Number.MIN_SAFE_INTEGER; &#125; for (let i = 0; i &lt;= len; i++) &#123; dp[i][0][1] = Number.MIN_SAFE_INTEGER; &#125; //再计算最优解 for (let i = 1; i &lt;= len; i++) &#123; for (let j = k; j &gt;= 1; j--) &#123;//从大到小从小到大都可以 dp[i][j][1] = Math.max(dp[i - 1][j][1], dp[i - 1][j - 1][0] - prices[i - 1]); dp[i][j][0] = Math.max(dp[i - 1][j][0], dp[i - 1][j][1] + prices[i - 1]); &#125; &#125; //返回结果 return dp[len][k][0]; &#125; function createArray(m, n) &#123; return (new Array(m).fill(0)).map(() =&gt; &#123; return (new Array(n).fill(0)).map(() =&gt; &#123; return (new Array(2).fill(0)); &#125;) &#125;) &#125;&#125;; 字符串编辑 两个字符串的删除操作1234567891011121314151617181920212223242526272829/** * @param &#123;string&#125; word1 * @param &#123;string&#125; word2 * @return &#123;number&#125; */var minDistance = function(word1, word2) &#123; let len1 = word1.length; let len2 = word2.length; let dp = createArray(len1+1,len2+1); //求解最大公共子串 for(let i = 1;i &lt;= len1;i++)&#123; for(let j = 1;j &lt;= len2;j++)&#123; if(word1[i-1] === word2[j-1])&#123; dp[i][j] = Math.max(dp[i-1][j-1] + 1,dp[i-1][j]); &#125;else&#123; dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]); &#125; &#125; &#125; return len1 + len2 - 2 * dp[len1][len2];//最小删除数是总长度-2*最大公共子串 function createArray(m,n)&#123; return (new Array(m).fill(0)).map(function()&#123; return new Array(n).fill(0); &#125;) &#125;&#125;; 编辑距离 123456789101112131415161718192021222324252627282930313233/** * @param &#123;string&#125; word1 * @param &#123;string&#125; word2 * @return &#123;number&#125; */var minDistance = function (word1, word2) &#123; let len1 = word1.length; let len2 = word2.length; let dp = createArray(len1 + 1, len2 + 1); //初始化dp[0][i] = i, dp[i][0] = i for (let i = 0; i &lt;= len1; i++) &#123; dp[i][0] = i; &#125; for (let i = 0; i &lt;= len2; i++) &#123; dp[0][i] = i; &#125; for (let i = 1; i &lt;= len1; i++) &#123; for (let j = 1; j &lt;= len2; j++) &#123; if(word1[i - 1] === word2[j - 1])&#123; dp[i][j] = Math.min(dp[i-1][j-1],dp[i-1][j] + 1,dp[i][j-1]+1); &#125;else&#123; dp[i][j] = Math.min(dp[i-1][j-1]+1,dp[i-1][j] + 1,dp[i][j-1]+1); &#125; &#125; &#125; return dp[len1][len2]; function createArray(m, n) &#123; return (new Array(m).fill(0)).map(function () &#123; return new Array(n).fill(0); &#125;) &#125;&#125;; 只有两个键的键盘 123456789101112131415161718192021var minSteps = function(n) &#123; //递归边界 if(n === 1) return 0; //先找到n的最大因子 let mid = Math.ceil(Math.sqrt(n)); let factor1 = 1; let factor2 = n; for(let i = n - 1;i &gt;= mid;i--)&#123; if(n % i === 0)&#123; factor2 = i; factor1 = n / i; break; &#125; &#125; //若该因子为n即该数为素数，则直接返回n if(factor2 === n)&#123; return n; &#125;else&#123;//如果不为素数，则递归 return factor1 + minSteps(factor2); &#125;&#125;;","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://zhi.com/tags/LeetCode/"},{"name":"算法","slug":"算法","permalink":"http://zhi.com/tags/算法/"}]},{"title":"markdown语法","slug":"markdown语法","date":"2021-04-12T06:37:12.000Z","updated":"2021-05-08T08:44:44.642Z","comments":true,"path":"2021/04/12/markdown语法/","link":"","permalink":"http://zhi.com/2021/04/12/markdown语法/","excerpt":"Markdown语法总结笔记神器","text":"Markdown语法总结笔记神器 1、标题一个#是一级标题，二个#是二级标题，以此类推。支持六级标题。 注：标准语法一般在#后跟个空格再写文字，貌似简书不加空格也行。 123456# 这是一级标题## 这是二级标题### 这是三级标题#### 这是四级标题##### 这是五级标题###### 这是六级标题 2、字体1234**这是加粗的文字***这是倾斜的文字*`***这是斜体加粗的文字***~~这是加删除线的文字~~ 3、引用123&gt;这是引用的内容&gt;&gt;这是引用的内容&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容 效果图： 这是引用的内容 这是引用的内容 4、分割线1234-------******** 5、图片1234![图片alt](图片地址 &apos;&apos;图片title&apos;&apos;)图片alt就是显示在图片下面的文字，相当于对图片内容的解释。图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加 6、超链接12[超链接名](超链接地址 &quot;超链接title&quot;)title可加可不加 示例： 12[简书](http://jianshu.com)[百度](http://baidu.com) 如果想在新页面打开： 1234&lt;a href=&quot;超链接地址&quot; target=&quot;_blank&quot;&gt;超链接名&lt;/a&gt;示例&lt;a href=&quot;https://www.jianshu.com/u/1f5ac0cf6a8b&quot; target=&quot;_blank&quot;&gt;简书&lt;/a&gt; 7、列表7.1、有序列表数字加点 123451. 列表内容2. 列表内容3. 列表内容注意：序号跟内容之间要有空格 效果如下： 列表内容 列表内容 列表内容 7.2、无序列表12345- 列表内容+ 列表内容* 列表内容注意：- + * 跟内容之间都要有一个空格 效果如下： 列表内容 列表内容 列表内容 8、表格1234567891011表头|表头|表头---|:--:|---:内容|内容|内容内容|内容|内容第二行分割表头和内容。- 有一个就行，为了对齐，多加了几个文字默认居左-两边加：表示文字居中-右边加：表示文字居右注：原生的语法两边都要用 | 包起来。此处省略 9、代码单行代码：代码之间分别用一个反引号包起来 1`代码内容` 代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行 1​ 代码… 代码… 代码…​12345```## 10、一些特殊语法空格符： 从小到大：小：&amp;nbsp 中：ensp 大：emsp 居中的内容 就像使用html一样，使用标签或者在末尾敲击两个空格，然后回车 我是黑体字我是红色我是5号大小我是黑体，绿色，尺寸为5 --- ### 以上就是比较常用的Markdown语法，日常生活一定够用了，特殊情况请找无所不知的百度大明白！","categories":[],"tags":[{"name":"markdown","slug":"markdown","permalink":"http://zhi.com/tags/markdown/"}]},{"title":"Canvas绘图及描框","slug":"Canvas绘图及描框","date":"2021-03-22T09:15:07.000Z","updated":"2021-05-08T08:45:20.862Z","comments":true,"path":"2021/03/22/Canvas绘图及描框/","link":"","permalink":"http://zhi.com/2021/03/22/Canvas绘图及描框/","excerpt":"canvas绘制图片和画识别框问题canvas知识","text":"canvas绘制图片和画识别框问题canvas知识 前言先说一下业务需求，此处的功能是用于微信OCR文字识别的PC端和小程序端应用。要求上传本地图片后，图片以及识别结果能够展示，为便于测试要求在识别图片上对识别的文字用矩形框及序号框出，与结果一一对应。 记录下此处的实现方法及难点： 1、首先图片显示不要使用img标签，使用canvas来描绘，我们需要得到的是img的宽高属性。小程序使用：wx.getImageInfo，vue中直接new Image() 2、我们要知道两个比例：（1）图片与画布的比例，用于图片自适应画布大小。（2）图片自身缩放比例，用于识别框同比例缩放。 3、计算居中显示的偏移量：（画布-图片）/2；调用canvas的api接口绘图ctx.drawImage 4、根据后台返回的坐标点（原图）进行描框和缩放ctx.strokeRect，对序号框字体进行优化，自适应框的大小，此处小程序和pc不同。 分别附带小程序及vue的完整代码小程序：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135canvasToFile(ctx) &#123; const cWidth = 640, cHeight = 480; console.log(&apos;画布宽：&apos; + cWidth) console.log(&apos;画布高：&apos; + cHeight) wx.getImageInfo(&#123; src: SRC, success: res =&gt; &#123; console.log(res) // 原始图大小 let imgWidth = res.width, imgHeight = res.height; // 相对画布等比例缩放 let n = 1; if (imgWidth &gt; imgHeight) &#123; n = imgWidth / cWidth; imgWidth = cWidth; imgHeight = imgHeight / n; &#125; else &#123; n = imgHeight / cHeight; imgHeight = cHeight; imgWidth = imgWidth / n; &#125; // 图片自身缩放比例 let widthScal = imgWidth / res.width console.log(widthScal) console.log(&apos;imgWidth:&apos; + imgWidth) console.log(&apos;imgHeight:&apos; + imgHeight) console.log(cWidth) console.log(cHeight) let zoom = &#123; width: widthScal, height: widthScal &#125; // 偏移x,y位移量 let right_move = (cWidth - imgWidth) / 2; let bottom_move = (cHeight - imgHeight) / 2; console.log(&apos;right_move:&apos; + right_move) console.log(&apos;bottom_move:&apos; + bottom_move) // 获取预览画布上下文 const c_t_x = wx.createCanvasContext(&apos;canvas_pre&apos;) // 缩放展示画布图片 ctx.scale(0.5, 0.5) ctx.drawImage(SRC, right_move, bottom_move, imgWidth, imgHeight) c_t_x.drawImage(SRC, right_move, bottom_move, imgWidth, imgHeight) ctx.draw() c_t_x.draw() // 画矩形识别框 setTimeout(function() &#123; let value = wx.getStorageSync(&apos;ocr&apos;) if (value.hasOwnProperty(&apos;items&apos;)) &#123; console.log(value) let length = value.items.length let item = value.items for (let i = 0; i &lt; length; i++) &#123; let show = item[i] // 原图坐标 let X1 = show.pos.left_top.x let Y1 = show.pos.left_top.y let X2 = show.pos.right_bottom.x let Y2 = show.pos.right_bottom.y let startPoint = [X1, Y1], endPoint = [X2, Y2]; // console.log(startPoint) // console.log(endPoint) // 等比例缩放坐标 let Num_x = startPoint[0] * zoom.width + right_move let Num_y = startPoint[1] * zoom.height + bottom_move let Num_width = (endPoint[0] - startPoint[0]) * zoom.width let Num_height = (endPoint[1] - startPoint[1]) * zoom.height ctx.setStrokeStyle(&apos;blue&apos;) c_t_x.setStrokeStyle(&apos;blue&apos;) // 分别画两个画布的矩形框 c_t_x.strokeRect(Num_x, Num_y, Num_width, Num_height) ctx.strokeRect(Num_x, Num_y, Num_width, Num_height); // 区分文字横向，竖向展示时，数字框位置 if (Num_width &lt; Num_height) &#123; let top_x = Num_x let top_y = (startPoint[1] - (endPoint[0] - startPoint[0])) * zoom.height + bottom_move let w_h = Num_width ctx.setFontSize(w_h) c_t_x.setFontSize(w_h) ctx.setStrokeStyle(&apos;#006bff&apos;) c_t_x.setStrokeStyle(&apos;#006bff&apos;) ctx.setFillStyle(&apos;#006bff&apos;) c_t_x.setFillStyle(&apos;#006bff&apos;) ctx.fillText(i + 1, Num_x + (w_h / 2), Num_y, w_h) c_t_x.fillText(i + 1, Num_x + (w_h / 2), Num_y, w_h) ctx.strokeRect(top_x, top_y, w_h, w_h) c_t_x.strokeRect(top_x, top_y, w_h, w_h) ctx.setTextAlign(&apos;center&apos;) c_t_x.setTextAlign(&apos;center&apos;) &#125; else &#123; let left_X = (startPoint[0] - (endPoint[1] - startPoint[1])) * zoom.width + right_move let left_Y = Num_y let W_H = Num_height ctx.setFontSize(W_H) ctx.setStrokeStyle(&apos;#006bff&apos;) ctx.setFillStyle(&apos;#006bff&apos;) ctx.fillText(i + 1, left_X + W_H / 2, left_Y + W_H, W_H) ctx.strokeRect(left_X, left_Y, W_H, W_H) ctx.setTextAlign(&apos;center&apos;) c_t_x.setFontSize(W_H) c_t_x.setStrokeStyle(&apos;#006bff&apos;) c_t_x.setFillStyle(&apos;#006bff&apos;) c_t_x.fillText(i + 1, left_X + W_H / 2, left_Y + W_H, W_H) c_t_x.strokeRect(left_X, left_Y, W_H, W_H) c_t_x.setTextAlign(&apos;center&apos;) &#125; &#125; ctx.draw(true) // 导出图片到url数组中，注意像素值 c_t_x.draw(true, setTimeout(function() &#123; let dpr = wx.getSystemInfoSync().pixelRatio console.log(dpr) wx.canvasToTempFilePath(&#123; x: right_move, y: bottom_move, width: imgWidth, height: imgHeight, destWidth: imgWidth * dpr, destHeight: imgHeight * dpr, canvasId: &apos;canvas_pre&apos;, success(res) &#123; console.log(res) url.push(res.tempFilePath) &#125; &#125;) &#125;, 100)); &#125; &#125;, 1200) &#125; &#125;) &#125;, 这里有两个canvas，是因为公司新加的一个需求：点击图片放大预览，同时识别框也要放大。但是在同一画布内使用wx.canvasToTempFilePath导成图片后，预览的图片很模糊，网上也有些方法，但并不起作用。所以我使用两个画布，一个画布展示图片和识别框，另一个定位在屏幕外用于预览图片，预览画布宽高是展示画布的2倍。即可解决模糊问题。 在onload调用该方法并初始化： 1234const ctx = wx.createCanvasContext(&apos;canvas&apos;)ctx.clearRect(0, 0, 320, 240)ctx.draw()this.canvasToFile(ctx) vue中实现：调canvas组件： 1234567891011121314151617181920212223&lt;template&gt; &lt;Canvas @upload=&quot;upload&quot; :result_show=&quot;result_title&quot; :list=&quot;ocr_comm&quot; :show=&quot;loading&quot; :err=&quot;err&quot;&gt;&lt;/Canvas&gt;&lt;/template&gt;&lt;script&gt; import Canvas from &apos;components/HomeChildren/Canvas/Canvas&apos; export default &#123; name: &quot;ocr_comm&quot;, components: &#123; Canvas &#125;, data() &#123; return &#123; CW: &apos;400px&apos;, CH: &apos;400px&apos;, result_title: &apos;通用OCR识别结果&apos;, ocr_comm: [], loading: false, err: false &#125; &#125;, 图片自适应及绘图，使用async解决异步影响： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748async upload(file, canvas) &#123; // console.log(file) if (!file) return; // 加载图标显示 this.loading = true // 图片缩放比例 let widthScal = 0 // 先基于FileReader进行文件的读取 let fileExample = new FileReader(); // console.dir(fileExample) fileExample.readAsDataURL(file); fileExample.onload = ev =&gt; &#123; // 创建新图片 // console.dir(ev) this.IMAGE = new Image(); this.IMAGE.src = ev.target.result; this.IMAGE.onload = () =&gt; &#123; this.IW = this.IMAGE.width; this.IH = this.IMAGE.height; const NCW = parseInt(this.CW); const NCH = parseInt(this.CW); // 重新按照比例计算宽高 let n = 1; if (this.IW &gt; this.IH) &#123; n = this.IW / NCW; this.IW = NCW; this.IH = this.IH / n; &#125; else &#123; n = this.IH / NCH; this.IH = NCH; this.IW = this.IW / n; &#125; this.IL = (NCW - this.IW) / 2; this.IT = (NCH - this.IH) / 2; widthScal = this.IW / this.IMAGE.width; // console.log(zoom.width) // 绘制图片 this.CTX = canvas.getContext(&quot;2d&quot;); // 清空画布 this.CTX.clearRect(0, 0, parseInt(this.CW), parseInt(this.CH)); // 绘制图片 this.CTX.drawImage(this.IMAGE, this.IL, this.IT, this.IW, this.IH); &#125;; &#125; //上传文件 await this.uploadImg(file) this.strokeRect(widthScal) &#125;, 描框代码，这里的序号字体自适应使用字符串拼接形式： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152strokeRect(widthScal) &#123; if (this.ocr_comm.length !== 0) &#123; for (let i = 0; i &lt; this.ocr_comm.length; i++) &#123; // console.log(this.ocr_comm) let show = this.ocr_comm[i] // 原图坐标 // console.log(show) let X1 = show.pos.left_top.x let Y1 = show.pos.left_top.y let X2 = show.pos.right_bottom.x let Y2 = show.pos.right_bottom.y let startPoint = [X1, Y1], endPoint = [X2, Y2]; let Num_x = startPoint[0] * widthScal + this.IL let Num_y = startPoint[1] * widthScal + this.IT let Num_width = (endPoint[0] - startPoint[0]) * widthScal let Num_height = (endPoint[1] - startPoint[1]) * widthScal this.CTX.strokeStyle = &apos;blue&apos;; this.CTX.strokeRect(Num_x, Num_y, Num_width, Num_height); if (Num_width &lt; Num_height) &#123; let top_x = Num_x let top_y = (startPoint[1] - (endPoint[0] - startPoint[0])) * widthScal + this.IT let w_h = Num_width // console.log(w_h) let fontsize=w_h+&apos;px&apos; let fontFamily=&quot;宋体&quot; let Num_font=fontsize+&apos; &apos;+fontFamily this.CTX.font=Num_font this.CTX.strokeStyle = &apos;#006bff&apos; this.CTX.fillStyle = &apos;#006bff&apos; this.CTX.fillText(i + 1, Num_x + (w_h / 2), Num_y, w_h) this.CTX.strokeRect(top_x, top_y, w_h, w_h) this.CTX.textAlign = &apos;center&apos; &#125; else &#123; let left_X = (startPoint[0] - (endPoint[1] - startPoint[1])) * widthScal + this.IL let left_Y = Num_y let W_H = Num_height let fontsize=W_H+&apos;px&apos; let fontFamily=&quot;宋体&quot; let Num_font=fontsize+&apos; &apos;+fontFamily this.CTX.font=Num_font this.CTX.strokeStyle = &apos;#006bff&apos; this.CTX.fillStyle = &apos;#006bff&apos; this.CTX.fillText(i + 1, left_X + W_H / 2, left_Y + W_H, W_H) this.CTX.strokeRect(left_X, left_Y, W_H, W_H) this.CTX.textAlign = &apos;center&apos; &#125; &#125; &#125; else &#123; console.log(&quot;数据未取到&quot;) &#125; &#125;, 上传代码到后台服务器，前端使用api代理解决跨域问题： 123456789101112131415161718192021222324async uploadImg(file) &#123; var forms = new FormData(); forms.append(&apos;file&apos;, file) let config = &#123; headers: &#123;&apos;Content-Type&apos;: &apos;multipart/form-data&apos;&#125; &#125;; await this.$axios.post(&apos;/apidebug_imagequery?action=ocr_comm&apos;, forms, config) .then(res =&gt; &#123; console.log(res); this.loading = false if (res.data.ocrcomm_res.items.length !== 0) &#123; this.ocr_comm = res.data.ocrcomm_res.items console.log(this.ocr_comm) this.err = false &#125; else &#123; this.ocr_comm = [] this.err = true &#125; // resolve(this.ocr_comm) &#125;).catch(err =&gt; &#123; //补充异常处理代码 console.log(err) &#125;) &#125;, 至此！canvas的相关实现就是这些，图片预览仅用于小程序中，解决模糊问题是难点。canvas远比自己想的强大，现在所知也是九牛一毛，以后再会~！","categories":[],"tags":[{"name":"html5","slug":"html5","permalink":"http://zhi.com/tags/html5/"},{"name":"canvas","slug":"canvas","permalink":"http://zhi.com/tags/canvas/"}]},{"title":"节流和防抖","slug":"节流和防抖","date":"2020-12-01T06:10:07.000Z","updated":"2021-05-08T08:45:45.821Z","comments":true,"path":"2020/12/01/节流和防抖/","link":"","permalink":"http://zhi.com/2020/12/01/节流和防抖/","excerpt":"性能优化问题Js知识","text":"性能优化问题Js知识 防抖与节流防抖与节流是前端最基本的优化技巧，实现很简单，为了记录下，可供学习参考。 防抖概念：防抖就是在持续触发事件的时候，只有当不触发事件一段时间后才会执行处理的函数，当触发一次事件后，在规定事件内再次触发， 就会清除上次的定时任务，重新创建定时任务。 实现方式：每次触发事件时设置一个延迟调用方法，并且取消之前的延时调用方法 缺点：如果事件在规定的时间间隔内被不断的触发，则调用方法会被不断的延迟 12345678910111213141516171819//防抖debounce代码：function debounce(fn,delay) &#123; var timeout = null; // 创建一个标记用来存放定时器的返回值 return function (e) &#123; // 每当用户输入的时候把前一个 setTimeout clear 掉 clearTimeout(timeout); // 然后又创建一个新的 setTimeout, 这样就能保证interval 间隔内如果时间持续触发，就不会执行 fn 函数 timeout = setTimeout(() =&gt; &#123; fn.apply(this, arguments); &#125;, delay); &#125;;&#125;// 处理函数function handle() &#123; console.log(&apos;防抖：&apos;, Math.random());&#125; //滚动事件window.addEventListener(&apos;scroll&apos;, debounce(handle,500)); 节流概念：节流就是在持续触发事件的时候，利用标志位进行控制处理函数是否执行，比如为 true 执行，为 false 不执行通过指定间隔时间修改标志位的值即可实现在指定时间内只触发一次处理函数 实现方式：每次触发事件时，如果当前有等待执行的延时函数，则直接return12345678910111213141516171819202122//节流throttle代码：function throttle(fn,delay) &#123; let canRun = true; // 通过闭包保存一个标记 return function () &#123; // 在函数开头判断标记是否为true，不为true则return if (!canRun) return; // 立即设置为false canRun = false; // 将外部传入的函数的执行放在setTimeout中 setTimeout(() =&gt; &#123; // 最后在setTimeout执行完毕后再把标记设置为true(关键)表示可以执行下一次循环了。 // 当定时器没有执行的时候标记永远是false，在开头被return掉 fn.apply(this, arguments); canRun = true; &#125;, delay); &#125;;&#125; function sayHi(e) &#123; console.log(&apos;节流：&apos;, e.target.innerWidth, e.target.innerHeight);&#125;window.addEventListener(&apos;resize&apos;, throttle(sayHi,500)); 总结函数防抖：将多次操作合并为一次操作进行。原理是维护一个计时器，规定在delay时间后触发函数，但是在delay时间内再次触发的话，就会取消之前的计时器而重新设置。这样一来，只有最后一次操作能被触发。函数节流：使得一定时间内只触发一次函数。原理是通过判断是否有延迟调用函数未执行。区别： 函数节流不管事件触发有多频繁，都会保证在规定时间内一定会执行一次真正的事件处理函数，而函数防抖只是在最后一次事件后才触发一次函数。 比如在页面的无限加载场景下，我们需要用户在滚动页面时，每隔一段时间发一次 Ajax 请求，而不是在用户停下滚动页面操作时才去请求数据。这样的场景，就适合用节流技术来实现。","categories":[],"tags":[{"name":"Js","slug":"Js","permalink":"http://zhi.com/tags/Js/"},{"name":"Js封装","slug":"Js封装","permalink":"http://zhi.com/tags/Js封装/"}]},{"title":"Js同步与异步","slug":"JS同步与异步","date":"2020-11-05T04:43:57.000Z","updated":"2021-05-08T08:46:06.340Z","comments":true,"path":"2020/11/05/JS同步与异步/","link":"","permalink":"http://zhi.com/2020/11/05/JS同步与异步/","excerpt":"Js的同步与异步问题Js知识","text":"Js的同步与异步问题Js知识 前言如果有人问你Js的同步异步问题，你该怎么回答？理解一个问题无非是what-why-how，js同步和异步问题是什么–&gt;为什么会产生异步问题–&gt;如何解决。 首先，我们要知道Js是单线程的，同一时间只处理一个任务，这已经成这门语言的核心特征。 同步与异步（重点）同步就是任务放入到队列中后按照顺序执行；异步就是同时进行多个任务。举个例子：比方说你要烧水做菜，如果你先烧水，等着水烧开，再去做菜，这就是同步操作；但如果你边烧着水，同时准备做菜材料，同时进行，这就是异步操作；&nbsp;js单线程是执行同步操作的，但有时也需要异步操作，防止某一块解析时间过长，造成“卡死”情况。那么，js单线程又是如何实现异步的呢? ——是通过事件循环实现“异步”js中，最基础的异步是setTimeout和setInterval函数，还有onclick, ajax等异步操作。 123456 console.log(&apos;1&apos;)setTimeout(function()&#123; console.log(&apos;2&apos;)&#125;,0)console.log(&apos;3&apos;) //输出 1，3，2 promise解决异步问题promise解决嵌套回调的问题，将嵌套的回调函数改成.then()的连缀使用。Promise有这些特征：只能决议一次，决议值只能有一个，决议之后无法改变。任何then中的回调也只会被调用一次。Promise的特征保证了Promise可以解决信任问题。 promise 的使用 首先通过new Promise（function）创建一个promise对象，接收一个函数参数，并且在函数中传入resolve以及reject两个参数； 1234567var p = new Promise(function(resolve, reject)&#123; //做一些异步操作 setTimeout(function()&#123; console.log(&apos;这是一个异步操作&apos;); resolve(&apos;异步操作成功并且结束&apos;); &#125;, 1000); &#125;); then() 接收两个函数，分别是对promise的resolve及reject状态处理的函数，并且处理结束之后返回promise对象 1234567891011121314151617181920212223242526272829303132333435363738function fn1() &#123; console.log(&quot;第一个函数开始执行&quot;); var p = new Promise(function (resolve, reject) &#123; setTimeout(function () &#123; console.log(&apos;第一个函数执行完毕&apos;); resolve(&apos;接下来进入第二个函数&apos;); &#125;, 1000); &#125;); return p; &#125; function fn2(data) &#123; console.log(data); console.log(&apos;第二个函数开始执行&apos;); var p = new Promise(function (resolve, reject) &#123; setTimeout(function () &#123; var num = Math.ceil(Math.random() * 10); // 生成随机数 console.log(num); //num = 0；设置num=0 if (num === 0) &#123; console.log(&apos;第二个函数执行完毕&apos;); resolve(&apos;所有函数执行完毕&apos;); &#125; else&#123; reject(&quot;执行函数2失败&quot;); &#125; &#125;, 2000); &#125;); return p; &#125; fn1() .then(function (data) &#123; return fn2(data); &#125;) .then(function (data) &#123; console.log(data); &#125;) 第一个函数开始执行 第一个函数执行完毕 接下来进入第二个函数 第二个函数开始执行 第二个函数执行完毕 所有函数执行完毕&emsp;&emsp;调用reslove .all() 接收一个函数数组，进行并发操作，并将每个函数的结果以数组的形式返回。.race()接收函数数组，函数先执行完成之后先进入下一个回调函数中。.catch() 当then中出现错误时不会中止整个函数，catch能够获取到错误并进行提示。 这几种方法不做详述啦！会用即可，好了！今天先到这里，我们下期见!","categories":[],"tags":[{"name":"Js","slug":"Js","permalink":"http://zhi.com/tags/Js/"},{"name":"解决异步","slug":"解决异步","permalink":"http://zhi.com/tags/解决异步/"}]},{"title":"Vue双向绑定原理","slug":"Vue双向绑定原理","date":"2020-10-23T05:45:49.000Z","updated":"2021-05-08T08:46:29.142Z","comments":true,"path":"2020/10/23/Vue双向绑定原理/","link":"","permalink":"http://zhi.com/2020/10/23/Vue双向绑定原理/","excerpt":"详述Vue的数据双向绑定原理前端知识","text":"详述Vue的数据双向绑定原理前端知识 Vue实现双向数据绑定的原理就是利用了 Object.defineProperty() 这个方法重新定义了对象获取属性值(get)和设置属性值(set)的操作来实现的。 另一种说法：vue的双向绑定是由数据劫持结合发布者－订阅者模式实现的。（这里不懂没关系，接着往下看…）首先，我们我们需要一个监听器Observer来给所有的属性设置set函数。如果属性发生了变化，就要通知所有的订阅者Watcher。而这些Watcher统一存放在消息订阅器Dep中，这样比较方便统一管理。Watcher接受到来自Dep的通知后就执行相应的操作去更新视图。&nbsp; Observer 监听器的核心代码如下： 1234567891011121314151617181920212223242526272829function observe(data) &#123; if (!data || typeof data !== &apos;object&apos;) &#123; return; &#125; Object.keys(data).forEach(function(key) &#123; // 遍历属性，递归设置set函数 defineReactive(data, key, data[key]); &#125;);&#125;function defineReactive(data, key, val) &#123; observe(val) var dep = new Dep() Object.defineProperty(data, key, &#123; enumerable: true, configurable: true, get: function() &#123; if (Dep.target) &#123; dep.addSub(Dep.target) // 添加watcher &#125; return val &#125;, set: function(newVal) &#123; if (val === newVal) &#123; return; &#125; val = newVal; dep.notify() // 通知dep &#125; &#125;)&#125; 通过调用observe（）函数来递归地给data对象设置set和get函数，在data的属性被get时添加watcher，被set时通知dep，dep的notify会接着通知所有的watcher去执行更新操作。&nbsp;这里需要对defineProperty做一个补充，上述的observe递归过程，在value值为对象时会继续递归，只有当value值是非对象时才return，然后调用definePropery。所以对于data里面的数组arr，vue实际监听的是arr[0]、arr[1]…arr[n]，而不是arr本身。所以对于改变arr的操作，arr[0] = 9这样是可以被监听到的，而arr.push(‘123’)这样是不行的，因为push方法本质上只是改变了arr[n+1]的值，而这个值本身是没有被监听的，即没有设置set函数。vue为了方便我们对数组的操作，对数组的一些常用方法进行额外的封装，即对vue的data的属性的原型赋值为封装层，当我们使用this.arr.push时，根据原型链向上找会先找到封装层的push，而不会使用原生的push。封装层的push做的事情是先触发原生push方法，然后再监听新push的项，再触发消息订阅器dep的notify方法，从而提醒watcher去更新视图。&nbsp; Dep 消息订阅器的核心代码如下： 1234567891011121314function Dep() &#123; this.subs = [] // 订阅者数组&#125;Dep.prototype = &#123; addSub: function(sub) &#123; this.subs.push(sub) &#125;, notify: function() &#123; this.subs.forEach(function(sub) &#123; sub.update() &#125;) &#125;&#125;Dep.target = null 消息订阅器比较简单，就是维护一个subs数组。当监听新属性时把它push进subs数组中，然后dep被通知时触发notify函数，从而触发subs数组中每个watcher的update操作。&nbsp; Watcher1234567891011121314151617181920212223242526function Watcher(vm, exp, cb) &#123; this.cb = cb this.vm = vm this.exp = exp this.value = this.get()&#125;Watcher.prototype = &#123; update: function() &#123; this.run() &#125;, run: function() &#123; var value = this.vm.data[this.exp] var oldVal = this.value if (value !== oldVal) &#123; this.value = value this.cb.call(this.vm, value, oldVal) // 执行更新时的回调函数 &#125; &#125;, get: function() &#123; Dep.target = this var value = this.vm.data[this.exp] // 读取data的属性，从而执行属性的get函数 Dep.target = null return value &#125;&#125; Watcher的主要功能是去触发属性的get函数，从而添加watcher到Dep的subs数组中。另外就是在update()中更新属性的值并触发更新回调函数。使用Watcher的方法如下： 12345var el = document.getElementById(&apos;XXX&apos;)observe(data)new Watcher(vm, exp, function(value) &#123; // vm表示某个实例,exp表示属性名 el.innerHTML = value&#125;) 为了使用时的整洁，我们需要把代码稍微包装下。 SimpleVue1234567891011121314151617181920212223242526272829function SimpleVue (data, el, exp) &#123; var self = this this.data = data Object.keys(data).forEach(function(key) &#123; self.proxyKeys(key) &#125;) observe(data) el.innerHTML = this.data[exp] new Watcher(this, exp, function(value) &#123; el.innerHTML = value &#125;) return this&#125;SimpleVue.prototype = &#123; proxyKeys: function(key) &#123; var self = this Object.defineProperty(this, key, &#123; enumerable: false, configurable: true, get: function() &#123; return self.data[key] &#125;, set: function(newVal) &#123; self.data[key] = newVal &#125; &#125;) &#125;&#125; SimpleVue做的事情就是使用observe递归地给data的每个属性都加上get和set，然后对于要监听的属性exp新建一个Watcher对象去监听。（Watcher对象触发属性exp的get函数从而添加订阅事件到Dep，而且会在属性的update方法里面触发监听回调函数）使用如下： 123456789// html&lt;h1 id=&quot;name&quot;&gt;&#123;&#123;name&#125;&#125;&lt;/h1&gt; //这个&#123;&#123;name&#125;&#125;暂时没用// jsvar el = document.querySelector(&apos;#name&apos;)var selfVue = new SimpleVue(&#123; name: &apos;hello&apos;&#125;, el, &apos;name&apos;)setTimeout(function() &#123; selfVue.name = &apos;123&apos;&#125;, 2000) 需要注意的是SimpleVue原型的proxyKeys是为了将selfVue.data.name这种操作代理为selfVue.name。这下我们就可以直接通过selfVue.name = “XXX”来改变数据了，并且视图也会相应变化。 Compile1234567891011121314151617181920212223242526272829303132nodeToFragement: function(el) &#123; var fragment = document.createDocumentFragment() var child = el.firstChild // 将dom节点移到fragment while(child) &#123; fragment.appendChild(child) child = el.firstChild &#125; return fragment &#125;, compileElement: function(el) &#123; var childNodes = el.childNodes var self = this; [].slice.call(childNodes).forEach(function(node) &#123; var reg = /\\&#123;\\&#123;(.*)\\&#125;\\&#125;/ var text = node.textContent if (self.isTextNode(node) &amp;&amp; reg.test(text)) &#123; self.compileText(node, reg.exec(text)[1]) &#125; if (node.childNodes &amp;&amp; node.childNodes.length) &#123; self.compileElement(node) // 递归遍历子节点 &#125; &#125;); &#125;, compileText: function(node, exp) &#123; var self = this var initText = this.vm[exp] this.updateText(node, initText) new Watcher(this.vm, exp, function(value) &#123; self.updateText(node, value) &#125;) &#125;, compile将dom节点移入DocumentFragment中去，并递归调用compileElement函数来遍历所有子节点，compileText函数创建新的watcher。 1234567891011function SimpleVue (options) &#123; var self = this this.vm = this this.data = options.data Object.keys(this.data).forEach(function(key) &#123; self.proxyKeys(key) &#125;) observe(this.data) new Compile(options.el, this.vm) return this&#125; &nbsp; 好了！以上就是全部内容啦~~希望可以帮到你！！！","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://zhi.com/tags/Vue/"},{"name":"前端","slug":"前端","permalink":"http://zhi.com/tags/前端/"}]},{"title":"小程序开发和Vue组件化开发的使用区别","slug":"小程序与Vue区别","date":"2020-09-21T06:04:46.000Z","updated":"2021-05-08T08:46:42.468Z","comments":true,"path":"2020/09/21/小程序与Vue区别/","link":"","permalink":"http://zhi.com/2020/09/21/小程序与Vue区别/","excerpt":"总结一下二者的共同点和区别前端知识","text":"总结一下二者的共同点和区别前端知识 写了vue项目和小程序，发现二者有许多相同之处，在此想总结一下二者的共同点和区别。 1.生命周期 vue生命周期： 小程序生命周期: 相比之下，小程序的钩子函数要简单得多。vue的钩子函数在跳转新页面时，钩子函数都会触发，但是小程序的钩子函数，页面不同的跳转方式，触发的钩子并不一样。 onLoad: 页面加载一个页面只会调用一次，可以在 onLoad 中获取打开当前页面所调用的 query 参数。 onShow: 页面显示每次打开页面都会调用一次。 onReady: 页面初次渲染完成一个页面只会调用一次，代表页面已经准备妥当，可以和视图层进行交互。 对界面的设置如wx.setNavigationBarTitle请在onReady之后设置。详见生命周期 onHide: 页面隐藏当navigateTo或底部tab切换时调用。 onUnload: 页面卸载当redirectTo或navigateBack的时候调用。 数据请求: 在页面加载请求数据时，两者钩子的使用有些类似，vue一般会在created或者mounted中请求数据，而在小程序，会在onLoad或者onShow中请求数据。 2.数据绑定VUE:vue动态绑定一个变量的值为元素的某个属性的时候，会在变量前面加上冒号：，例：1. &lt;img :src=&quot;imgSrc&quot;/&gt;小程序：绑定某个变量的值为元素属性时，会用两个大括号括起来，如果不加括号，为被认为是字符串。例：1. &lt;image src=&quot;&quot;&gt;&lt;/image&gt; 3.列表渲染两者还是有些相似 vue： 123456789101112131415161. &lt;ul id=&quot;example-1&quot;&gt; 2. &lt;li v-for=&quot;item in items&quot;&gt; 3. &#123;&#123; item.message &#125;&#125; 4. &lt;/li&gt; 5\\. &lt;/ul&gt; 7. var example1 = new Vue(&#123; 8. el: &apos;#example-1&apos;, 9. data: &#123; 10. items: [ 11. &#123; message: &apos;苹果&apos; &#125;, 12. &#123; message: &apos;橘子&apos; &#125; 13. ] 14. &#125; 15. &#125;) 小程序: 123456789101. Page(&#123; 2. data: &#123; 3. items: [ 4. &#123; message: &apos;苹果&apos; &#125;, 5. &#123; message: &apos;橘子&apos; &#125; 6. ] 7. &#125; 8. &#125;) 10. &lt;text wx:for=&quot;&#123;&#123;items&#125;&#125;&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/text&gt; 4.显示与隐藏元素vue中，使用v-if 和v-show控制元素的显示和隐藏 小程序中，使用wx-if和hidden控制元素的显示和隐藏 5.事件处理vue：使用v-on:event绑定事件，或者使用@event绑定事件,例如: 121. &lt;button v-on:click=&quot;counter += 1&quot;&gt;Add 1&lt;/button&gt; 2\\. &lt;button v-on:click.stop=&quot;counter+=1&quot;&gt;Add1&lt;/button&gt; //阻止事件冒泡 小程序中，全用bindtap(bind+event)，或者catchtap(catch+event)绑定事件,例如： 121. &lt;button bindtap=&quot;noWork&quot;&gt;明天不上班&lt;/button&gt; 2. &lt;button catchtap=&quot;noWork&quot;&gt;明天不上班&lt;/button&gt; //阻止事件冒泡 6.数据双向绑定1.设置值 在vue中,只需要再表单元素上加上v-model,然后再绑定data中对应的一个值，当表单元素内容发生变化时，data中对应的值也会相应改变，这是vue非常nice的一点。 12345678910111. &lt;div id=&quot;app&quot;&gt; 2. &lt;input v-model=&quot;reason&quot; placeholder=&quot;填写理由&quot; class=&apos;reason&apos;/&gt; 3. &lt;/div&gt; 5. new Vue(&#123; 6. el: &apos;#app&apos;, 7. data: &#123; 8. reason:&apos;&apos; 9. &#125; 10. &#125;) 但是在小程序中，却没有这个功能。那怎么办呢？ 当表单内容发生变化时，会触发表单元素上绑定的方法，然后在该方法中，通过this.setData({key:value})来将表单上的值赋值给data中的对应值。 下面是代码，可以感受一下: 12345678910111. &lt;input bindinput=&quot;bindReason&quot; placeholder=&quot;填写理由&quot; class=&apos;reason&apos; value=&apos;&#123;&#123;reason&#125;&#125;&apos; name=&quot;reason&quot; /&gt; 2. Page(&#123; 3. data:&#123; 4. reason:&apos;&apos; 5. &#125;, 6. bindReason(e) &#123; 7. this.setData(&#123; 8. reason: e.detail.value 9. &#125;) 10. &#125; 11. &#125;) 当页面表单元素很多的时候，更改值就是一件体力活了。和小程序一比较，vue的v-model简直爽的不要不要的。2.取值 vue中，通过this.reason取值 小程序中，通过this.data.reason取值 7.绑定事件传参在vue中，绑定事件传参挺简单，只需要在触发事件的方法中，把需要传递的数据作为形参传入就可以了，例如： 1234567891. &lt;button @click=&quot;say(&apos;明天不上班&apos;)&quot;&gt;&lt;/button&gt; 2. new Vue(&#123; 3. el: &apos;#app&apos;, 4. methods:&#123; 5. say(arg)&#123; 6. consloe.log(arg) 7. &#125; 8. &#125; 9. &#125;) 在小程序中，不能直接在绑定事件的方法中传入参数，需要将参数作为属性值，绑定到元素上的data-属性上，然后在方法中，通过e.currentTarget.dataset.*的方式获取，从而完成参数的传递，很麻烦有没有… 1234567891. &lt;view class=&apos;tr&apos; bindtap=&apos;toApprove&apos; data-id=&quot;&#123;&#123;item.id&#125;&#125;&quot;&gt;&lt;/view&gt; 2. Page(&#123; 3. data:&#123; 4. reason:&apos;&apos; 5. &#125;, 6. toApprove(e) &#123; 7. let id = e.currentTarget.dataset.id; 8. &#125; 9. &#125;) 8.父子组件通信1.子组件的使用 在vue中，需要： 编写子组件在需要使用的父组件中通过import引入在vue的components中注册在模板中使用 12345678910111213141516171819202122232425262728293031323334353637383940414243444546471. //子组件 bar.vue 2. &lt;template&gt; 3. &lt;div class=&quot;search-box&quot;&gt; 4. &lt;div @click=&quot;say&quot; :title=&quot;title&quot; class=&quot;icon-dismiss&quot;&gt;&lt;/div&gt; 5. &lt;/div&gt; 6\\. &lt;/template&gt; 7. &lt;script&gt; 8. export default&#123; 9. props:&#123; 10. title:&#123; 11. type:String, 12. default:&apos;&apos; 13. &#125; 14. &#125; 15. &#125;, 17. methods:&#123; 18. say()&#123; 19. console.log(&apos;明天不上班&apos;); 20. this.$emit(&apos;helloWorld&apos;) 21. &#125; 22. &#125; 23. &lt;/script&gt; 25\\. // 父组件 foo.vue 26. &lt;template&gt; 27. &lt;div class=&quot;container&quot;&gt; 28. &lt;bar :title=&quot;title&quot; @helloWorld=&quot;helloWorld&quot;&gt;&lt;/bar&gt; 29. &lt;/div&gt; 30\\. &lt;/template&gt; 32. &lt;script&gt; 33. import Bar from &apos;./bar.vue&apos; 34. export default&#123; 35. data:&#123; 36. title:&quot;我是标题&quot; 37. &#125;, 38. methods:&#123; 39. helloWorld()&#123; 40. console.log(&apos;我接收到子组件传递的事件了&apos;) 41. &#125; 42. &#125;, 43. components:&#123; 44. Bar 45. &#125; 46. &lt;/script&gt; 在小程序中，需要：1.编写子组件2.在子组件的json文件中，将该文件声明为组件 1231. &#123; 2. &quot;component&quot;: true 3. &#125; 3.在需要引入的父组件的json文件中，在usingComponents填写引入组件的组件名以及路径 12341. &quot;usingComponents&quot;: &#123; 2. &quot;tab-bar&quot;: &quot;../../components/tabBar/tabBar&quot; 3. &#125; 4.在父组件中，直接引入即可1. &lt;tab-bar currentpage=&quot;index&quot;&gt;&lt;/tab-bar&gt;2.父子组件间通信 在vue中 父组件向子组件传递数据，只需要在子组件通过v-bind传入一个值，在子组件中，通过props接收，即可完成数据的传递，示例: 123456789101112131415161718192021222324252627282930313233341. // 父组件 foo.vue 2. &lt;template&gt; 3. &lt;div class=&quot;container&quot;&gt; 4. &lt;bar :title=&quot;title&quot;&gt;&lt;/bar&gt; 5. &lt;/div&gt; 6\\. &lt;/template&gt; 7. &lt;script&gt; 8. import Bar from &apos;./bar.vue&apos; 9. export default&#123; 10. data:&#123; 11. title:&quot;我是标题&quot; 12. &#125;, 13. components:&#123; 14. Bar 15. &#125; 16. &lt;/script&gt; 18\\. // 子组件bar.vue 19. &lt;template&gt; 20. &lt;div class=&quot;search-box&quot;&gt; 21. &lt;div :title=&quot;title&quot; &gt;&lt;/div&gt; 22. &lt;/div&gt; 23\\. &lt;/template&gt; 24. &lt;script&gt; 25. export default&#123; 26. props:&#123; 27. title:&#123; 28. type:String, 29. default:&apos;&apos; 30. &#125; 31. &#125; 32. &#125; 33. &lt;/script&gt; 子组件和父组件通信可以通过this.$emit将方法和数据传递给父组件。在小程序中 父组件向子组件通信和vue类似，但是小程序没有通过v-bind，而是直接将值赋值给一个变量，如下：1. &lt;tab-bar currentpage=&quot;index&quot;&gt;&lt;/tab-bar&gt;此处， “index”就是要向子组件传递的值在子组件properties中，接收传递的值 123456781. properties: &#123; 2. // 弹窗标题 3. currentpage: &#123; // 属性名 4. type: String, // 类型（必填），目前接受的类型包括：String, Number, Boolean, Object, Array, null（表示任意类型） 5. value: &apos;index&apos; // 属性初始值（可选），如果未指定则会根据类型选择一个 6. &#125; 7. &#125; 子组件向父组件通信和vue也很类似，代码如下: 123456789101112131415161. //子组件中 2. methods: &#123; 3. // 传递给父组件 4. cancelBut: function (e) &#123; 5. var that = this; 6. var myEventDetail = &#123; pickerShow: false, type: &apos;cancel&apos; &#125; // detail对象，提供给事件监听函数 7. this.triggerEvent(&apos;myevent&apos;, myEventDetail) //myevent自定义名称事件，父组件中使用 8. &#125;, 9. &#125; 10. //父组件中 11. &lt;bar bind:myevent=&quot;toggleToast&quot;&gt;&lt;/bar&gt; 12. // 获取子组件信息 13. toggleToast(e)&#123; 14. console.log(e.detail) 15. &#125; 如果父组件想要调用子组件的方法 vue会给子组件添加一个ref属性，通过this.$refs.ref的值便可以获取到该子组件，然后便可以调用子组件中的任意方法，例如： 123451. //子组件 2. &lt;bar ref=&quot;bar&quot;&gt;&lt;/bar&gt; 3. //父组件 4. this.$ref.bar.子组件的方法 小程序是给子组件添加id或者class，然后通过this.selectComponent找到子组件，然后再调用子组件的方法,示例： 123451. //子组件 2. &lt;bar id=&quot;bar&quot;&gt;&lt;/bar&gt; 3. // 父组件 4. this.selectComponent(&apos;#id&apos;).syaHello() 小程序和vue在这点上太相似了… 这些都是我们常用到的知识点，还有不足，以后慢慢改善~~！ 原文地址","categories":[{"name":"小程序","slug":"小程序","permalink":"http://zhi.com/categories/小程序/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://zhi.com/tags/Vue/"},{"name":"小程序","slug":"小程序","permalink":"http://zhi.com/tags/小程序/"}]}]}