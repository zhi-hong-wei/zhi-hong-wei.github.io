{"meta":{"title":"zhi","subtitle":null,"description":null,"author":"智宏伟","url":"http://zhi.com","root":"/"},"pages":[{"title":"分类","date":"2020-03-21T05:17:45.000Z","updated":"2020-03-21T05:18:27.505Z","comments":true,"path":"categories/index.html","permalink":"http://zhi.com/categories/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-03-22T12:12:56.000Z","updated":"2020-03-22T12:12:56.592Z","comments":true,"path":"categories/index-1.html","permalink":"http://zhi.com/categories/index-1.html","excerpt":"","text":""},{"title":"tags","date":"2020-03-22T12:12:08.000Z","updated":"2020-03-22T12:12:08.370Z","comments":true,"path":"tags/index-1.html","permalink":"http://zhi.com/tags/index-1.html","excerpt":"","text":""},{"title":"about","date":"2020-03-22T12:21:10.000Z","updated":"2020-03-22T12:21:10.961Z","comments":true,"path":"about/index.html","permalink":"http://zhi.com/about/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-03-21T05:13:57.000Z","updated":"2020-03-21T05:16:49.312Z","comments":true,"path":"tags/index.html","permalink":"http://zhi.com/tags/index.html","excerpt":"","text":""},{"title":"archives","date":"2020-03-22T12:20:19.000Z","updated":"2020-03-22T12:20:19.916Z","comments":true,"path":"archives/index.html","permalink":"http://zhi.com/archives/index.html","excerpt":"","text":""}],"posts":[{"title":"Vue双向绑定原理","slug":"Vue双向绑定原理","date":"2020-03-23T05:45:49.000Z","updated":"2020-03-23T07:28:00.661Z","comments":true,"path":"2020/03/23/Vue双向绑定原理/","link":"","permalink":"http://zhi.com/2020/03/23/Vue双向绑定原理/","excerpt":"详述Vue的数据双向绑定原理前端知识","text":"详述Vue的数据双向绑定原理前端知识 Vue实现双向数据绑定的原理就是利用了 Object.defineProperty() 这个方法重新定义了对象获取属性值(get)和设置属性值(set)的操作来实现的。 另一种说法：vue的双向绑定是由数据劫持结合发布者－订阅者模式实现的。（这里不懂没关系，接着往下看…）首先，我们我们需要一个监听器Observer来给所有的属性设置set函数。如果属性发生了变化，就要通知所有的订阅者Watcher。而这些Watcher统一存放在消息订阅器Dep中，这样比较方便统一管理。Watcher接受到来自Dep的通知后就执行相应的操作去更新视图。&nbsp; Observer 监听器的核心代码如下： 1234567891011121314151617181920212223242526272829function observe(data) &#123; if (!data || typeof data !== &apos;object&apos;) &#123; return; &#125; Object.keys(data).forEach(function(key) &#123; // 遍历属性，递归设置set函数 defineReactive(data, key, data[key]); &#125;);&#125;function defineReactive(data, key, val) &#123; observe(val) var dep = new Dep() Object.defineProperty(data, key, &#123; enumerable: true, configurable: true, get: function() &#123; if (Dep.target) &#123; dep.addSub(Dep.target) // 添加watcher &#125; return val &#125;, set: function(newVal) &#123; if (val === newVal) &#123; return; &#125; val = newVal; dep.notify() // 通知dep &#125; &#125;)&#125; 通过调用observe（）函数来递归地给data对象设置set和get函数，在data的属性被get时添加watcher，被set时通知dep，dep的notify会接着通知所有的watcher去执行更新操作。&nbsp;这里需要对defineProperty做一个补充，上述的observe递归过程，在value值为对象时会继续递归，只有当value值是非对象时才return，然后调用definePropery。所以对于data里面的数组arr，vue实际监听的是arr[0]、arr[1]…arr[n]，而不是arr本身。所以对于改变arr的操作，arr[0] = 9这样是可以被监听到的，而arr.push(‘123’)这样是不行的，因为push方法本质上只是改变了arr[n+1]的值，而这个值本身是没有被监听的，即没有设置set函数。vue为了方便我们对数组的操作，对数组的一些常用方法进行额外的封装，即对vue的data的属性的原型赋值为封装层，当我们使用this.arr.push时，根据原型链向上找会先找到封装层的push，而不会使用原生的push。封装层的push做的事情是先触发原生push方法，然后再监听新push的项，再触发消息订阅器dep的notify方法，从而提醒watcher去更新视图。&nbsp; Dep 消息订阅器的核心代码如下： 1234567891011121314function Dep() &#123; this.subs = [] // 订阅者数组&#125;Dep.prototype = &#123; addSub: function(sub) &#123; this.subs.push(sub) &#125;, notify: function() &#123; this.subs.forEach(function(sub) &#123; sub.update() &#125;) &#125;&#125;Dep.target = null 消息订阅器比较简单，就是维护一个subs数组。当监听新属性时把它push进subs数组中，然后dep被通知时触发notify函数，从而触发subs数组中每个watcher的update操作。&nbsp; Watcher1234567891011121314151617181920212223242526function Watcher(vm, exp, cb) &#123; this.cb = cb this.vm = vm this.exp = exp this.value = this.get()&#125;Watcher.prototype = &#123; update: function() &#123; this.run() &#125;, run: function() &#123; var value = this.vm.data[this.exp] var oldVal = this.value if (value !== oldVal) &#123; this.value = value this.cb.call(this.vm, value, oldVal) // 执行更新时的回调函数 &#125; &#125;, get: function() &#123; Dep.target = this var value = this.vm.data[this.exp] // 读取data的属性，从而执行属性的get函数 Dep.target = null return value &#125;&#125; Watcher的主要功能是去触发属性的get函数，从而添加watcher到Dep的subs数组中。另外就是在update()中更新属性的值并触发更新回调函数。使用Watcher的方法如下： 12345var el = document.getElementById(&apos;XXX&apos;)observe(data)new Watcher(vm, exp, function(value) &#123; // vm表示某个实例,exp表示属性名 el.innerHTML = value&#125;) 为了使用时的整洁，我们需要把代码稍微包装下。 SimpleVue1234567891011121314151617181920212223242526272829function SimpleVue (data, el, exp) &#123; var self = this this.data = data Object.keys(data).forEach(function(key) &#123; self.proxyKeys(key) &#125;) observe(data) el.innerHTML = this.data[exp] new Watcher(this, exp, function(value) &#123; el.innerHTML = value &#125;) return this&#125;SimpleVue.prototype = &#123; proxyKeys: function(key) &#123; var self = this Object.defineProperty(this, key, &#123; enumerable: false, configurable: true, get: function() &#123; return self.data[key] &#125;, set: function(newVal) &#123; self.data[key] = newVal &#125; &#125;) &#125;&#125; SimpleVue做的事情就是使用observe递归地给data的每个属性都加上get和set，然后对于要监听的属性exp新建一个Watcher对象去监听。（Watcher对象触发属性exp的get函数从而添加订阅事件到Dep，而且会在属性的update方法里面触发监听回调函数）使用如下： 123456789// html&lt;h1 id=&quot;name&quot;&gt;&#123;&#123;name&#125;&#125;&lt;/h1&gt; //这个&#123;&#123;name&#125;&#125;暂时没用// jsvar el = document.querySelector(&apos;#name&apos;)var selfVue = new SimpleVue(&#123; name: &apos;hello&apos;&#125;, el, &apos;name&apos;)setTimeout(function() &#123; selfVue.name = &apos;123&apos;&#125;, 2000) 需要注意的是SimpleVue原型的proxyKeys是为了将selfVue.data.name这种操作代理为selfVue.name。这下我们就可以直接通过selfVue.name = “XXX”来改变数据了，并且视图也会相应变化。 Compile1234567891011121314151617181920212223242526272829303132nodeToFragement: function(el) &#123; var fragment = document.createDocumentFragment() var child = el.firstChild // 将dom节点移到fragment while(child) &#123; fragment.appendChild(child) child = el.firstChild &#125; return fragment &#125;, compileElement: function(el) &#123; var childNodes = el.childNodes var self = this; [].slice.call(childNodes).forEach(function(node) &#123; var reg = /\\&#123;\\&#123;(.*)\\&#125;\\&#125;/ var text = node.textContent if (self.isTextNode(node) &amp;&amp; reg.test(text)) &#123; self.compileText(node, reg.exec(text)[1]) &#125; if (node.childNodes &amp;&amp; node.childNodes.length) &#123; self.compileElement(node) // 递归遍历子节点 &#125; &#125;); &#125;, compileText: function(node, exp) &#123; var self = this var initText = this.vm[exp] this.updateText(node, initText) new Watcher(this.vm, exp, function(value) &#123; self.updateText(node, value) &#125;) &#125;, compile将dom节点移入DocumentFragment中去，并递归调用compileElement函数来遍历所有子节点，compileText函数创建新的watcher。 1234567891011function SimpleVue (options) &#123; var self = this this.vm = this this.data = options.data Object.keys(this.data).forEach(function(key) &#123; self.proxyKeys(key) &#125;) observe(this.data) new Compile(options.el, this.vm) return this&#125; &nbsp; 好了！以上就是全部内容啦~~希望可以帮到你！！！","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://zhi.com/tags/Vue/"},{"name":"前端","slug":"前端","permalink":"http://zhi.com/tags/前端/"}]},{"title":"小程序开发和Vue组件化开发的使用区别","slug":"小程序与Vue区别","date":"2020-03-21T06:04:46.000Z","updated":"2020-03-23T08:37:58.022Z","comments":true,"path":"2020/03/21/小程序与Vue区别/","link":"","permalink":"http://zhi.com/2020/03/21/小程序与Vue区别/","excerpt":"总结一下二者的共同点和区别前端知识","text":"总结一下二者的共同点和区别前端知识 写了vue项目和小程序，发现二者有许多相同之处，在此想总结一下二者的共同点和区别。 1.生命周期 vue生命周期：小程序生命周期: 相比之下，小程序的钩子函数要简单得多。vue的钩子函数在跳转新页面时，钩子函数都会触发，但是小程序的钩子函数，页面不同的跳转方式，触发的钩子并不一样。 onLoad: 页面加载一个页面只会调用一次，可以在 onLoad 中获取打开当前页面所调用的 query 参数。 onShow: 页面显示每次打开页面都会调用一次。 onReady: 页面初次渲染完成一个页面只会调用一次，代表页面已经准备妥当，可以和视图层进行交互。 对界面的设置如wx.setNavigationBarTitle请在onReady之后设置。详见生命周期 onHide: 页面隐藏当navigateTo或底部tab切换时调用。 onUnload: 页面卸载当redirectTo或navigateBack的时候调用。 数据请求 在页面加载请求数据时，两者钩子的使用有些类似，vue一般会在created或者mounted中请求数据，而在小程序，会在onLoad或者onShow中请求数据。 2.数据绑定VUE:vue动态绑定一个变量的值为元素的某个属性的时候，会在变量前面加上冒号：，例：1. &lt;img :src=&quot;imgSrc&quot;/&gt;小程序：绑定某个变量的值为元素属性时，会用两个大括号括起来，如果不加括号，为被认为是字符串。例：1. &lt;image src=&quot;&quot;&gt;&lt;/image&gt; 3.列表渲染两者还是有些相似 vue： 123456789101112131415161. &lt;ul id=&quot;example-1&quot;&gt; 2. &lt;li v-for=&quot;item in items&quot;&gt; 3. &#123;&#123; item.message &#125;&#125; 4. &lt;/li&gt; 5\\. &lt;/ul&gt; 7. var example1 = new Vue(&#123; 8. el: &apos;#example-1&apos;, 9. data: &#123; 10. items: [ 11. &#123; message: &apos;苹果&apos; &#125;, 12. &#123; message: &apos;橘子&apos; &#125; 13. ] 14. &#125; 15. &#125;) 小程序 123456789101. Page(&#123; 2. data: &#123; 3. items: [ 4. &#123; message: &apos;苹果&apos; &#125;, 5. &#123; message: &apos;橘子&apos; &#125; 6. ] 7. &#125; 8. &#125;) 10. &lt;text wx:for=&quot;&#123;&#123;items&#125;&#125;&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/text&gt; 4.显示与隐藏元素vue中，使用v-if 和v-show控制元素的显示和隐藏 小程序中，使用wx-if和hidden控制元素的显示和隐藏 5.事件处理vue：使用v-on:event绑定事件，或者使用@event绑定事件,例如: 121. &lt;button v-on:click=&quot;counter += 1&quot;&gt;Add 1&lt;/button&gt; 2\\. &lt;button v-on:click.stop=&quot;counter+=1&quot;&gt;Add1&lt;/button&gt; //阻止事件冒泡 小程序中，全用bindtap(bind+event)，或者catchtap(catch+event)绑定事件,例如： 121. &lt;button bindtap=&quot;noWork&quot;&gt;明天不上班&lt;/button&gt; 2. &lt;button catchtap=&quot;noWork&quot;&gt;明天不上班&lt;/button&gt; //阻止事件冒泡 6.数据双向绑定1.设置值 在vue中,只需要再表单元素上加上v-model,然后再绑定data中对应的一个值，当表单元素内容发生变化时，data中对应的值也会相应改变，这是vue非常nice的一点。 12345678910111. &lt;div id=&quot;app&quot;&gt; 2. &lt;input v-model=&quot;reason&quot; placeholder=&quot;填写理由&quot; class=&apos;reason&apos;/&gt; 3. &lt;/div&gt; 5. new Vue(&#123; 6. el: &apos;#app&apos;, 7. data: &#123; 8. reason:&apos;&apos; 9. &#125; 10. &#125;) 但是在小程序中，却没有这个功能。那怎么办呢？ 当表单内容发生变化时，会触发表单元素上绑定的方法，然后在该方法中，通过this.setData({key:value})来将表单上的值赋值给data中的对应值。 下面是代码，可以感受一下: 12345678910111. &lt;input bindinput=&quot;bindReason&quot; placeholder=&quot;填写理由&quot; class=&apos;reason&apos; value=&apos;&#123;&#123;reason&#125;&#125;&apos; name=&quot;reason&quot; /&gt; 2. Page(&#123; 3. data:&#123; 4. reason:&apos;&apos; 5. &#125;, 6. bindReason(e) &#123; 7. this.setData(&#123; 8. reason: e.detail.value 9. &#125;) 10. &#125; 11. &#125;) 当页面表单元素很多的时候，更改值就是一件体力活了。和小程序一比较，vue的v-model简直爽的不要不要的。2.取值 vue中，通过this.reason取值 小程序中，通过this.data.reason取值 7.绑定事件传参在vue中，绑定事件传参挺简单，只需要在触发事件的方法中，把需要传递的数据作为形参传入就可以了，例如： 1234567891. &lt;button @click=&quot;say(&apos;明天不上班&apos;)&quot;&gt;&lt;/button&gt; 2. new Vue(&#123; 3. el: &apos;#app&apos;, 4. methods:&#123; 5. say(arg)&#123; 6. consloe.log(arg) 7. &#125; 8. &#125; 9. &#125;) 在小程序中，不能直接在绑定事件的方法中传入参数，需要将参数作为属性值，绑定到元素上的data-属性上，然后在方法中，通过e.currentTarget.dataset.*的方式获取，从而完成参数的传递，很麻烦有没有… 1234567891. &lt;view class=&apos;tr&apos; bindtap=&apos;toApprove&apos; data-id=&quot;&#123;&#123;item.id&#125;&#125;&quot;&gt;&lt;/view&gt; 2. Page(&#123; 3. data:&#123; 4. reason:&apos;&apos; 5. &#125;, 6. toApprove(e) &#123; 7. let id = e.currentTarget.dataset.id; 8. &#125; 9. &#125;) 8.父子组件通信1.子组件的使用 在vue中，需要： 编写子组件在需要使用的父组件中通过import引入在vue的components中注册在模板中使用 12345678910111213141516171819202122232425262728293031323334353637383940414243444546471. //子组件 bar.vue 2. &lt;template&gt; 3. &lt;div class=&quot;search-box&quot;&gt; 4. &lt;div @click=&quot;say&quot; :title=&quot;title&quot; class=&quot;icon-dismiss&quot;&gt;&lt;/div&gt; 5. &lt;/div&gt; 6\\. &lt;/template&gt; 7. &lt;script&gt; 8. export default&#123; 9. props:&#123; 10. title:&#123; 11. type:String, 12. default:&apos;&apos; 13. &#125; 14. &#125; 15. &#125;, 17. methods:&#123; 18. say()&#123; 19. console.log(&apos;明天不上班&apos;); 20. this.$emit(&apos;helloWorld&apos;) 21. &#125; 22. &#125; 23. &lt;/script&gt; 25\\. // 父组件 foo.vue 26. &lt;template&gt; 27. &lt;div class=&quot;container&quot;&gt; 28. &lt;bar :title=&quot;title&quot; @helloWorld=&quot;helloWorld&quot;&gt;&lt;/bar&gt; 29. &lt;/div&gt; 30\\. &lt;/template&gt; 32. &lt;script&gt; 33. import Bar from &apos;./bar.vue&apos; 34. export default&#123; 35. data:&#123; 36. title:&quot;我是标题&quot; 37. &#125;, 38. methods:&#123; 39. helloWorld()&#123; 40. console.log(&apos;我接收到子组件传递的事件了&apos;) 41. &#125; 42. &#125;, 43. components:&#123; 44. Bar 45. &#125; 46. &lt;/script&gt; 在小程序中，需要：1.编写子组件2.在子组件的json文件中，将该文件声明为组件 1231. &#123; 2. &quot;component&quot;: true 3. &#125; 3.在需要引入的父组件的json文件中，在usingComponents填写引入组件的组件名以及路径 12341. &quot;usingComponents&quot;: &#123; 2. &quot;tab-bar&quot;: &quot;../../components/tabBar/tabBar&quot; 3. &#125; 4.在父组件中，直接引入即可1. &lt;tab-bar currentpage=&quot;index&quot;&gt;&lt;/tab-bar&gt;2.父子组件间通信 在vue中 父组件向子组件传递数据，只需要在子组件通过v-bind传入一个值，在子组件中，通过props接收，即可完成数据的传递，示例: 123456789101112131415161718192021222324252627282930313233341. // 父组件 foo.vue 2. &lt;template&gt; 3. &lt;div class=&quot;container&quot;&gt; 4. &lt;bar :title=&quot;title&quot;&gt;&lt;/bar&gt; 5. &lt;/div&gt; 6\\. &lt;/template&gt; 7. &lt;script&gt; 8. import Bar from &apos;./bar.vue&apos; 9. export default&#123; 10. data:&#123; 11. title:&quot;我是标题&quot; 12. &#125;, 13. components:&#123; 14. Bar 15. &#125; 16. &lt;/script&gt; 18\\. // 子组件bar.vue 19. &lt;template&gt; 20. &lt;div class=&quot;search-box&quot;&gt; 21. &lt;div :title=&quot;title&quot; &gt;&lt;/div&gt; 22. &lt;/div&gt; 23\\. &lt;/template&gt; 24. &lt;script&gt; 25. export default&#123; 26. props:&#123; 27. title:&#123; 28. type:String, 29. default:&apos;&apos; 30. &#125; 31. &#125; 32. &#125; 33. &lt;/script&gt; 子组件和父组件通信可以通过this.$emit将方法和数据传递给父组件。在小程序中 父组件向子组件通信和vue类似，但是小程序没有通过v-bind，而是直接将值赋值给一个变量，如下：1. &lt;tab-bar currentpage=&quot;index&quot;&gt;&lt;/tab-bar&gt;此处， “index”就是要向子组件传递的值在子组件properties中，接收传递的值 123456781. properties: &#123; 2. // 弹窗标题 3. currentpage: &#123; // 属性名 4. type: String, // 类型（必填），目前接受的类型包括：String, Number, Boolean, Object, Array, null（表示任意类型） 5. value: &apos;index&apos; // 属性初始值（可选），如果未指定则会根据类型选择一个 6. &#125; 7. &#125; 子组件向父组件通信和vue也很类似，代码如下: 123456789101112131415161. //子组件中 2. methods: &#123; 3. // 传递给父组件 4. cancelBut: function (e) &#123; 5. var that = this; 6. var myEventDetail = &#123; pickerShow: false, type: &apos;cancel&apos; &#125; // detail对象，提供给事件监听函数 7. this.triggerEvent(&apos;myevent&apos;, myEventDetail) //myevent自定义名称事件，父组件中使用 8. &#125;, 9. &#125; 10. //父组件中 11. &lt;bar bind:myevent=&quot;toggleToast&quot;&gt;&lt;/bar&gt; 12. // 获取子组件信息 13. toggleToast(e)&#123; 14. console.log(e.detail) 15. &#125; 如果父组件想要调用子组件的方法 vue会给子组件添加一个ref属性，通过this.$refs.ref的值便可以获取到该子组件，然后便可以调用子组件中的任意方法，例如： 123451. //子组件 2. &lt;bar ref=&quot;bar&quot;&gt;&lt;/bar&gt; 3. //父组件 4. this.$ref.bar.子组件的方法 小程序是给子组件添加id或者class，然后通过this.selectComponent找到子组件，然后再调用子组件的方法,示例： 123451. //子组件 2. &lt;bar id=&quot;bar&quot;&gt;&lt;/bar&gt; 3. // 父组件 4. this.selectComponent(&apos;#id&apos;).syaHello() 小程序和vue在这点上太相似了… 这些都是我们常用到的知识点，还有不足，以后慢慢改善~~！ 原文地址","categories":[{"name":"小程序","slug":"小程序","permalink":"http://zhi.com/categories/小程序/"}],"tags":[{"name":"小程序","slug":"小程序","permalink":"http://zhi.com/tags/小程序/"},{"name":"Vue","slug":"Vue","permalink":"http://zhi.com/tags/Vue/"}]}]}