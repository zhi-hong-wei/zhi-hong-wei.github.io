<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Js同步与异步</title>
    <url>/2020/04/01/JS%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5/</url>
    <content><![CDATA[<h1 id="Js的同步与异步问题"><a href="#Js的同步与异步问题" class="headerlink" title="Js的同步与异步问题"></a>Js的同步与异步问题</h1><h2 id="Js知识"><a href="#Js知识" class="headerlink" title="Js知识"></a>Js知识</h2><a id="more"></a>

<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>如果有人问你Js的同步异步问题，你该怎么回答？理解一个问题无非是what-why-how，js同步和异步问题是什么–&gt;为什么会产生异步问题–&gt;如何解决。</p>
<blockquote>
<p>首先，我们要知道Js是单线程的，同一时间只处理一个任务，这已经成这门语言的核心特征。</p>
</blockquote>
<h3 id="同步与异步（重点）"><a href="#同步与异步（重点）" class="headerlink" title="同步与异步（重点）"></a>同步与异步（重点）</h3><p><font color="orange">同步</font>就是任务放入到队列中后按照顺序执行；<br><font color="orange">异步</font>就是同时进行多个任务。<br>举个例子：比方说你要烧水做菜，如果你先烧水，等着水烧开，再去做菜，这就是同步操作；但如果你边烧着水，同时准备做菜材料，同时进行，这就是异步操作；<br>&nbsp;<br>js单线程是执行同步操作的，但有时也需要异步操作，防止某一块解析时间过长，造成“卡死”情况。<br>那么，js单线程又是如何实现异步的呢? ——<strong>是通过事件循环实现“异步”</strong><br>js中，最基础的异步是setTimeout和setInterval函数，还有onclick, ajax等异步操作。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> console.log(&apos;1&apos;)</span><br><span class="line">setTimeout(function()&#123;</span><br><span class="line"> console.log(&apos;2&apos;)</span><br><span class="line">&#125;,0)</span><br><span class="line">console.log(&apos;3&apos;)  </span><br><span class="line">//输出       1，3，2</span><br></pre></td></tr></table></figure>

<h3 id="promise解决异步问题"><a href="#promise解决异步问题" class="headerlink" title="promise解决异步问题"></a>promise解决异步问题</h3><p>promise解决嵌套回调的问题，将嵌套的回调函数改成.then()的连缀使用。<br>Promise有这些特征：只能决议一次，决议值只能有一个，决议之后无法改变。任何then中的回调也只会被调用一次。Promise的特征保证了Promise可以解决信任问题。</p>
<h4 id="promise-的使用"><a href="#promise-的使用" class="headerlink" title="promise 的使用"></a>promise 的使用</h4><blockquote>
<p>首先通过new Promise（function）创建一个promise对象，接收一个函数参数，并且在函数中传入resolve以及reject两个参数；</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var p = new Promise(function(resolve, reject)&#123;      </span><br><span class="line">            //做一些异步操作</span><br><span class="line">            setTimeout(function()&#123;</span><br><span class="line">                console.log(&apos;这是一个异步操作&apos;);</span><br><span class="line">                resolve(&apos;异步操作成功并且结束&apos;);</span><br><span class="line">            &#125;, 1000);</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>then() 接收两个函数，分别是对promise的resolve及reject状态处理的函数，并且处理结束之后返回promise对象</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function fn1() &#123;</span><br><span class="line">       console.log(&quot;第一个函数开始执行&quot;);</span><br><span class="line">       var p = new Promise(function (resolve, reject) &#123;</span><br><span class="line">           setTimeout(function () &#123;</span><br><span class="line">               console.log(&apos;第一个函数执行完毕&apos;);</span><br><span class="line">               resolve(&apos;接下来进入第二个函数&apos;);</span><br><span class="line">           &#125;, 1000);</span><br><span class="line">       &#125;);</span><br><span class="line">       return p;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   function fn2(data) &#123;</span><br><span class="line">       console.log(data);</span><br><span class="line">       console.log(&apos;第二个函数开始执行&apos;);</span><br><span class="line">       var p = new Promise(function (resolve, reject) &#123;</span><br><span class="line">           setTimeout(function () &#123;</span><br><span class="line">               var num = Math.ceil(Math.random() * 10); // 生成随机数</span><br><span class="line">              console.log(num);</span><br><span class="line">               //num = 0；设置num=0</span><br><span class="line">               if (num === 0) &#123;</span><br><span class="line">                   console.log(&apos;第二个函数执行完毕&apos;);</span><br><span class="line">                   resolve(&apos;所有函数执行完毕&apos;);</span><br><span class="line">               &#125;</span><br><span class="line">               else&#123;</span><br><span class="line">                   reject(&quot;执行函数2失败&quot;);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;, 2000);</span><br><span class="line">       &#125;);</span><br><span class="line">       return p;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   fn1()</span><br><span class="line">       .then(function (data) &#123;</span><br><span class="line">           return fn2(data);</span><br><span class="line">       &#125;)</span><br><span class="line">       .then(function (data) &#123;</span><br><span class="line">           console.log(data);</span><br><span class="line">       &#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li><em>第一个函数开始执行</em></li>
<li><em>第一个函数执行完毕</em></li>
<li><em>接下来进入第二个函数</em></li>
<li><em>第二个函数开始执行</em></li>
<li><em>第二个函数执行完毕</em></li>
<li><em>所有函数执行完毕</em><br>&emsp;&emsp;<font size="2">调用reslove</font></li>
</ul>
<p>.all() 接收一个函数数组，进行并发操作，并将每个函数的结果以数组的形式返回。<br>.race()接收函数数组，函数先执行完成之后先进入下一个回调函数中。<br>.catch() 当then中出现错误时不会中止整个函数，catch能够获取到错误并进行提示。   </p>
<h2 id="这几种方法不做详述啦！会用即可，好了！今天先到这里，我们下期见"><a href="#这几种方法不做详述啦！会用即可，好了！今天先到这里，我们下期见" class="headerlink" title="这几种方法不做详述啦！会用即可，好了！今天先到这里，我们下期见!"></a>这几种方法不做详述啦！会用即可，好了！今天先到这里，我们下期见!</h2>]]></content>
      <tags>
        <tag>Js</tag>
        <tag>解决异步</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue双向绑定原理</title>
    <url>/2020/03/23/Vue%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="详述Vue的数据双向绑定原理"><a href="#详述Vue的数据双向绑定原理" class="headerlink" title="详述Vue的数据双向绑定原理"></a>详述Vue的数据双向绑定原理</h1><h2 id="前端知识"><a href="#前端知识" class="headerlink" title="前端知识"></a>前端知识</h2><a id="more"></a>

<blockquote>
<p>Vue实现双向数据绑定的原理就是利用了 Object.defineProperty() 这个方法重新定义了对象获取属性值(get)和设置属性值(set)的操作来实现的。</p>
</blockquote>
<p>另一种说法：vue的双向绑定是由数据劫持结合发布者－订阅者模式实现的。（这里不懂没关系，接着往下看…）<br>首先，我们我们需要一个监听器Observer来给所有的属性设置set函数。如果属性发生了变化，就要通知所有的订阅者Watcher。而这些Watcher统一存放在消息订阅器Dep中，这样比较方便统一管理。Watcher接受到来自Dep的通知后就执行相应的操作去更新视图。<br>&nbsp;</p>
<h3 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h3><blockquote>
<p>监听器的核心代码如下：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function observe(data) &#123;</span><br><span class="line">  if (!data || typeof data !== &apos;object&apos;) &#123;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  Object.keys(data).forEach(function(key) &#123;  // 遍历属性，递归设置set函数</span><br><span class="line">    defineReactive(data, key, data[key]);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">function defineReactive(data, key, val) &#123;</span><br><span class="line">  observe(val)</span><br><span class="line">  var dep = new Dep()</span><br><span class="line">  Object.defineProperty(data, key, &#123;</span><br><span class="line">    enumerable: true,</span><br><span class="line">    configurable: true,</span><br><span class="line">    get: function() &#123;</span><br><span class="line">      if (Dep.target) &#123;</span><br><span class="line">        dep.addSub(Dep.target)  // 添加watcher</span><br><span class="line">      &#125;</span><br><span class="line">      return val</span><br><span class="line">    &#125;,</span><br><span class="line">    set: function(newVal) &#123;</span><br><span class="line">      if (val === newVal) &#123;</span><br><span class="line">        return;</span><br><span class="line">      &#125;</span><br><span class="line">      val = newVal;</span><br><span class="line">      dep.notify()  // 通知dep</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过调用observe（）函数来递归地给data对象设置set和get函数，在data的属性被get时添加watcher，被set时通知dep，dep的notify会接着通知所有的watcher去执行更新操作。<br>&nbsp;<br>这里需要对defineProperty做一个补充，上述的observe递归过程，在value值为对象时会继续递归，只有当value值是非对象时才return，然后调用definePropery。所以对于data里面的数组arr，vue实际监听的是arr[0]、arr[1]…arr[n]，而不是arr本身。所以对于改变arr的操作，arr[0] = 9这样是可以被监听到的，而arr.push(‘123’)这样是不行的，因为push方法本质上只是改变了arr[n+1]的值，而这个值本身是没有被监听的，即没有设置set函数。<br>vue为了方便我们对数组的操作，对数组的一些常用方法进行额外的封装，即对vue的data的属性的原型赋值为封装层，当我们使用this.arr.push时，根据原型链向上找会先找到封装层的push，而不会使用原生的push。封装层的push做的事情是先触发原生push方法，然后再监听新push的项，再触发消息订阅器dep的notify方法，从而提醒watcher去更新视图。<br>&nbsp;</p>
<h3 id="Dep"><a href="#Dep" class="headerlink" title="Dep"></a>Dep</h3><blockquote>
<p>消息订阅器的核心代码如下：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Dep() &#123;</span><br><span class="line">  this.subs = []  // 订阅者数组</span><br><span class="line">&#125;</span><br><span class="line">Dep.prototype = &#123;</span><br><span class="line">  addSub: function(sub) &#123;</span><br><span class="line">    this.subs.push(sub)</span><br><span class="line">  &#125;,</span><br><span class="line">  notify: function() &#123;</span><br><span class="line">    this.subs.forEach(function(sub) &#123;</span><br><span class="line">      sub.update()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Dep.target = null</span><br></pre></td></tr></table></figure>

<p>消息订阅器比较简单，就是维护一个subs数组。当监听新属性时把它push进subs数组中，然后dep被通知时触发notify函数，从而触发subs数组中每个watcher的update操作。<br>&nbsp;</p>
<h3 id="Watcher"><a href="#Watcher" class="headerlink" title="Watcher"></a>Watcher</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Watcher(vm, exp, cb) &#123;</span><br><span class="line">  this.cb = cb</span><br><span class="line">  this.vm = vm</span><br><span class="line">  this.exp = exp</span><br><span class="line">  this.value = this.get()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Watcher.prototype = &#123;</span><br><span class="line">  update: function() &#123;</span><br><span class="line">    this.run()</span><br><span class="line">  &#125;,</span><br><span class="line">  run: function() &#123;</span><br><span class="line">    var value = this.vm.data[this.exp]</span><br><span class="line">    var oldVal = this.value</span><br><span class="line">    if (value !== oldVal) &#123;</span><br><span class="line">      this.value = value</span><br><span class="line">      this.cb.call(this.vm, value, oldVal)  // 执行更新时的回调函数</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  get: function() &#123;</span><br><span class="line">    Dep.target = this</span><br><span class="line">    var value = this.vm.data[this.exp]  // 读取data的属性，从而执行属性的get函数</span><br><span class="line">    Dep.target = null</span><br><span class="line">    return value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Watcher的主要功能是去触发属性的get函数，从而添加watcher到Dep的subs数组中。另外就是在update()中更新属性的值并触发更新回调函数。<br>使用Watcher的方法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var el = document.getElementById(&apos;XXX&apos;)</span><br><span class="line">observe(data)</span><br><span class="line">new Watcher(vm, exp, function(value) &#123;  // vm表示某个实例,exp表示属性名</span><br><span class="line">  el.innerHTML = value</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>为了使用时的整洁，我们需要把代码稍微包装下。</p>
<h3 id="SimpleVue"><a href="#SimpleVue" class="headerlink" title="SimpleVue"></a>SimpleVue</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function SimpleVue (data, el, exp) &#123;</span><br><span class="line">  var self = this</span><br><span class="line">  this.data = data</span><br><span class="line">  Object.keys(data).forEach(function(key) &#123;</span><br><span class="line">    self.proxyKeys(key)</span><br><span class="line">  &#125;)</span><br><span class="line">  observe(data)</span><br><span class="line">  el.innerHTML = this.data[exp]</span><br><span class="line">  new Watcher(this, exp, function(value) &#123;</span><br><span class="line">    el.innerHTML = value</span><br><span class="line">  &#125;)</span><br><span class="line">  return this</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SimpleVue.prototype = &#123;</span><br><span class="line">  proxyKeys: function(key) &#123;</span><br><span class="line">    var self = this</span><br><span class="line">    Object.defineProperty(this, key, &#123;</span><br><span class="line">      enumerable: false,</span><br><span class="line">      configurable: true,</span><br><span class="line">      get: function() &#123;</span><br><span class="line">        return self.data[key]</span><br><span class="line">      &#125;,</span><br><span class="line">      set: function(newVal) &#123;</span><br><span class="line">        self.data[key] = newVal</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SimpleVue做的事情就是使用observe递归地给data的每个属性都加上get和set，然后对于要监听的属性exp新建一个Watcher对象去监听。（Watcher对象触发属性exp的get函数从而添加订阅事件到Dep，而且会在属性的update方法里面触发监听回调函数）<br>使用如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// html</span><br><span class="line">&lt;h1 id=&quot;name&quot;&gt;&#123;&#123;name&#125;&#125;&lt;/h1&gt;  //这个&#123;&#123;name&#125;&#125;暂时没用</span><br><span class="line"></span><br><span class="line">// js</span><br><span class="line">var el = document.querySelector(&apos;#name&apos;)</span><br><span class="line">var selfVue = new SimpleVue(&#123; name: &apos;hello&apos;&#125;, el, &apos;name&apos;)</span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">  selfVue.name = &apos;123&apos;</span><br><span class="line">&#125;, 2000)</span><br></pre></td></tr></table></figure>

<p>需要注意的是SimpleVue原型的proxyKeys是为了将selfVue.data.name这种操作代理为selfVue.name。这下我们就可以直接通过selfVue.name = “XXX”来改变数据了，并且视图也会相应变化。</p>
<h3 id="Compile"><a href="#Compile" class="headerlink" title="Compile"></a>Compile</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nodeToFragement: function(el) &#123;</span><br><span class="line">    var fragment = document.createDocumentFragment()</span><br><span class="line">    var child = el.firstChild</span><br><span class="line">    // 将dom节点移到fragment</span><br><span class="line">    while(child) &#123;</span><br><span class="line">      fragment.appendChild(child)</span><br><span class="line">      child = el.firstChild</span><br><span class="line">    &#125;</span><br><span class="line">    return fragment</span><br><span class="line">  &#125;,</span><br><span class="line">  compileElement: function(el) &#123;</span><br><span class="line">    var childNodes = el.childNodes</span><br><span class="line">    var self = this;</span><br><span class="line">    [].slice.call(childNodes).forEach(function(node) &#123;</span><br><span class="line">      var reg = /\&#123;\&#123;(.*)\&#125;\&#125;/</span><br><span class="line">      var text = node.textContent</span><br><span class="line">      if (self.isTextNode(node) &amp;&amp; reg.test(text)) &#123;</span><br><span class="line">        self.compileText(node, reg.exec(text)[1])</span><br><span class="line">      &#125;</span><br><span class="line">      if (node.childNodes &amp;&amp; node.childNodes.length) &#123;</span><br><span class="line">        self.compileElement(node)  // 递归遍历子节点</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">  compileText: function(node, exp) &#123;</span><br><span class="line">    var self = this</span><br><span class="line">    var initText = this.vm[exp]</span><br><span class="line">    this.updateText(node, initText)</span><br><span class="line">    new Watcher(this.vm, exp, function(value) &#123;</span><br><span class="line">      self.updateText(node, value)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>

<p>compile将dom节点移入DocumentFragment中去，并递归调用compileElement函数来遍历所有子节点，compileText函数创建新的watcher。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function SimpleVue (options) &#123;</span><br><span class="line">  var self = this</span><br><span class="line">  this.vm = this</span><br><span class="line">  this.data = options.data</span><br><span class="line">  Object.keys(this.data).forEach(function(key) &#123;</span><br><span class="line">    self.proxyKeys(key)</span><br><span class="line">  &#125;)</span><br><span class="line">  observe(this.data)</span><br><span class="line">  new Compile(options.el, this.vm)</span><br><span class="line">  return this</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&nbsp;</p>
<hr>
<h2 id="好了！以上就是全部内容啦-希望可以帮到你！！！"><a href="#好了！以上就是全部内容啦-希望可以帮到你！！！" class="headerlink" title="好了！以上就是全部内容啦~~希望可以帮到你！！！"></a>好了！以上就是全部内容啦~~希望可以帮到你！！！</h2>]]></content>
      <tags>
        <tag>Vue</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>小程序开发和Vue组件化开发的使用区别</title>
    <url>/2020/03/21/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%8EVue%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h1 id="总结一下二者的共同点和区别"><a href="#总结一下二者的共同点和区别" class="headerlink" title="总结一下二者的共同点和区别"></a>总结一下二者的共同点和区别</h1><h2 id="前端知识"><a href="#前端知识" class="headerlink" title="前端知识"></a>前端知识</h2><a id="more"></a>
<p>写了vue项目和小程序，发现二者有许多相同之处，在此想总结一下二者的共同点和区别。</p>
<h3 id="1-生命周期"><a href="#1-生命周期" class="headerlink" title="1.生命周期"></a>1.生命周期</h3><blockquote>
<p>vue生命周期：</p>
</blockquote>
<p><img src="https://segmentfault.com/img/bVVORa?w=1200&h=3039/view" alt></p>
<blockquote>
<p>小程序生命周期:</p>
</blockquote>
<p><img src="https://segmentfault.com/img/bVbcfCK?w=662&h=1014" alt><br>相比之下，小程序的钩子函数要简单得多。<br>vue的钩子函数在跳转新页面时，钩子函数都会触发，但是小程序的钩子函数，页面不同的跳转方式，触发的钩子并不一样。</p>
<p>onLoad: 页面加载<br>一个页面只会调用一次，可以在 onLoad 中获取打开当前页面所调用的 query 参数。</p>
<p>onShow: 页面显示<br>每次打开页面都会调用一次。</p>
<p>onReady: 页面初次渲染完成<br>一个页面只会调用一次，代表页面已经准备妥当，可以和视图层进行交互。</p>
<p>对界面的设置如wx.setNavigationBarTitle请在onReady之后设置。详见生命周期</p>
<p>onHide: 页面隐藏<br>当navigateTo或底部tab切换时调用。</p>
<p>onUnload: 页面卸载<br>当redirectTo或navigateBack的时候调用。</p>
<p>数据请求:</p>
<p>在页面加载请求数据时，两者钩子的使用有些类似，vue一般会在created或者mounted中请求数据，而在小程序，会在onLoad或者onShow中请求数据。</p>
<h3 id="2-数据绑定"><a href="#2-数据绑定" class="headerlink" title="2.数据绑定"></a>2.数据绑定</h3><p>VUE:vue动态绑定一个变量的值为元素的某个属性的时候，会在变量前面加上冒号：，例：<br><code>1.  &lt;img :src=&quot;imgSrc&quot;/&gt;</code><br>小程序：绑定某个变量的值为元素属性时，会用两个大括号括起来，如果不加括号，为被认为是字符串。例：<br><code>1.  &lt;image src=&quot;&quot;&gt;&lt;/image&gt;</code></p>
<h3 id="3-列表渲染"><a href="#3-列表渲染" class="headerlink" title="3.列表渲染"></a>3.列表渲染</h3><p>两者还是有些相似</p>
<blockquote>
<p>vue：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">1.  &lt;ul id=&quot;example-1&quot;&gt;  </span><br><span class="line">2.  &lt;li v-for=&quot;item in items&quot;&gt;  </span><br><span class="line">3.  &#123;&#123; item.message &#125;&#125;  </span><br><span class="line">4.  &lt;/li&gt;  </span><br><span class="line">5\.  &lt;/ul&gt;  </span><br><span class="line"></span><br><span class="line">7.  var example1 = new Vue(&#123;  </span><br><span class="line">8.  el: &apos;#example-1&apos;,  </span><br><span class="line">9.  data: &#123;  </span><br><span class="line">10.  items: [  </span><br><span class="line">11.  &#123; message: &apos;苹果&apos; &#125;,  </span><br><span class="line">12.  &#123; message: &apos;橘子&apos; &#125;  </span><br><span class="line">13.  ] </span><br><span class="line">14.  &#125;  </span><br><span class="line">15.  &#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>小程序:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.  Page(&#123;  </span><br><span class="line">2.  data: &#123;  </span><br><span class="line">3.  items: [  </span><br><span class="line">4.  &#123; message: &apos;苹果&apos; &#125;,  </span><br><span class="line">5.  &#123; message: &apos;橘子&apos; &#125;  </span><br><span class="line">6.  ]  </span><br><span class="line">7.  &#125;  </span><br><span class="line">8.  &#125;)  </span><br><span class="line"></span><br><span class="line">10.  &lt;text wx:for=&quot;&#123;&#123;items&#125;&#125;&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/text&gt;</span><br></pre></td></tr></table></figure>

<h3 id="4-显示与隐藏元素"><a href="#4-显示与隐藏元素" class="headerlink" title="4.显示与隐藏元素"></a>4.显示与隐藏元素</h3><p>vue中，使用v-if 和v-show控制元素的显示和隐藏</p>
<p>小程序中，使用wx-if和hidden控制元素的显示和隐藏</p>
<h3 id="5-事件处理"><a href="#5-事件处理" class="headerlink" title="5.事件处理"></a>5.事件处理</h3><p>vue：使用v-on:event绑定事件，或者使用@event绑定事件,例如:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.  &lt;button v-on:click=&quot;counter += 1&quot;&gt;Add 1&lt;/button&gt;  </span><br><span class="line">2\.  &lt;button v-on:click.stop=&quot;counter+=1&quot;&gt;Add1&lt;/button&gt;  //阻止事件冒泡</span><br></pre></td></tr></table></figure>

<p>小程序中，全用bindtap(bind+event)，或者catchtap(catch+event)绑定事件,例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.  &lt;button bindtap=&quot;noWork&quot;&gt;明天不上班&lt;/button&gt;  </span><br><span class="line">2.  &lt;button catchtap=&quot;noWork&quot;&gt;明天不上班&lt;/button&gt;  //阻止事件冒泡</span><br></pre></td></tr></table></figure>

<h3 id="6-数据双向绑定"><a href="#6-数据双向绑定" class="headerlink" title="6.数据双向绑定"></a>6.数据双向绑定</h3><p><strong>1.设置值</strong></p>
<p>在vue中,只需要再表单元素上加上v-model,然后再绑定data中对应的一个值，当表单元素内容发生变化时，data中对应的值也会相应改变，这是vue非常nice的一点。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">1.  &lt;div id=&quot;app&quot;&gt;  </span><br><span class="line">2.  &lt;input v-model=&quot;reason&quot; placeholder=&quot;填写理由&quot; class=&apos;reason&apos;/&gt;  </span><br><span class="line">3.  &lt;/div&gt;  </span><br><span class="line"></span><br><span class="line">5.  new Vue(&#123;  </span><br><span class="line">6.  el: &apos;#app&apos;,  </span><br><span class="line">7.  data: &#123;  </span><br><span class="line">8.  reason:&apos;&apos;  </span><br><span class="line">9.  &#125;  </span><br><span class="line">10.  &#125;)</span><br></pre></td></tr></table></figure>

<p>但是在小程序中，却没有这个功能。那怎么办呢？</p>
<p>当表单内容发生变化时，会触发表单元素上绑定的方法，然后在该方法中，通过this.setData({key:value})来将表单上的值赋值给data中的对应值。</p>
<p>下面是代码，可以感受一下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.  &lt;input bindinput=&quot;bindReason&quot; placeholder=&quot;填写理由&quot; class=&apos;reason&apos; value=&apos;&#123;&#123;reason&#125;&#125;&apos; name=&quot;reason&quot; /&gt;  </span><br><span class="line">2.  Page(&#123;  </span><br><span class="line">3.  data:&#123;  </span><br><span class="line">4.  reason:&apos;&apos;  </span><br><span class="line">5.  &#125;,  </span><br><span class="line">6.  bindReason(e) &#123;  </span><br><span class="line">7.  this.setData(&#123;  </span><br><span class="line">8.  reason: e.detail.value  </span><br><span class="line">9.  &#125;)  </span><br><span class="line">10.  &#125;  </span><br><span class="line">11.  &#125;)</span><br></pre></td></tr></table></figure>

<p>当页面表单元素很多的时候，更改值就是一件体力活了。和小程序一比较，vue的v-model简直爽的不要不要的。<br><strong>2.取值</strong></p>
<p>vue中，通过this.reason取值</p>
<p>小程序中，通过this.data.reason取值</p>
<h3 id="7-绑定事件传参"><a href="#7-绑定事件传参" class="headerlink" title="7.绑定事件传参"></a>7.绑定事件传参</h3><p>在vue中，绑定事件传参挺简单，只需要在触发事件的方法中，把需要传递的数据作为形参传入就可以了，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.  &lt;button @click=&quot;say(&apos;明天不上班&apos;)&quot;&gt;&lt;/button&gt;  </span><br><span class="line">2.  new Vue(&#123;  </span><br><span class="line">3.  el: &apos;#app&apos;,  </span><br><span class="line">4.  methods:&#123;  </span><br><span class="line">5.  say(arg)&#123;  </span><br><span class="line">6.  consloe.log(arg)  </span><br><span class="line">7.  &#125;  </span><br><span class="line">8.  &#125;  </span><br><span class="line">9.  &#125;)</span><br></pre></td></tr></table></figure>

<p>在小程序中，不能直接在绑定事件的方法中传入参数，需要将参数作为属性值，绑定到元素上的data-属性上，然后在方法中，通过e.currentTarget.dataset.*的方式获取，从而完成参数的传递，很麻烦有没有…</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.  &lt;view class=&apos;tr&apos; bindtap=&apos;toApprove&apos; data-id=&quot;&#123;&#123;item.id&#125;&#125;&quot;&gt;&lt;/view&gt;  </span><br><span class="line">2.  Page(&#123;  </span><br><span class="line">3.  data:&#123;  </span><br><span class="line">4.  reason:&apos;&apos;  </span><br><span class="line">5.  &#125;,  </span><br><span class="line">6.  toApprove(e) &#123;  </span><br><span class="line">7.  let id = e.currentTarget.dataset.id;  </span><br><span class="line">8.  &#125;  </span><br><span class="line">9.  &#125;)</span><br></pre></td></tr></table></figure>

<h3 id="8-父子组件通信"><a href="#8-父子组件通信" class="headerlink" title="8.父子组件通信"></a>8.父子组件通信</h3><p><strong>1.子组件的使用</strong></p>
<p>在vue中，需要：</p>
<p>编写子组件<br>在需要使用的父组件中通过import引入<br>在vue的components中注册<br>在模板中使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">1.  //子组件 bar.vue  </span><br><span class="line">2.  &lt;template&gt;  </span><br><span class="line">3.  &lt;div class=&quot;search-box&quot;&gt;  </span><br><span class="line">4.  &lt;div @click=&quot;say&quot; :title=&quot;title&quot; class=&quot;icon-dismiss&quot;&gt;&lt;/div&gt;  </span><br><span class="line">5.  &lt;/div&gt;  </span><br><span class="line">6\.  &lt;/template&gt;  </span><br><span class="line">7.  &lt;script&gt;  </span><br><span class="line">8.  export default&#123;  </span><br><span class="line">9.  props:&#123;  </span><br><span class="line">10.  title:&#123;  </span><br><span class="line">11.  type:String,  </span><br><span class="line">12.  default:&apos;&apos;  </span><br><span class="line">13.  &#125;  </span><br><span class="line">14.  &#125;  </span><br><span class="line">15.  &#125;, </span><br><span class="line"></span><br><span class="line">17.  methods:&#123;  </span><br><span class="line">18.  say()&#123; </span><br><span class="line">19.  console.log(&apos;明天不上班&apos;);  </span><br><span class="line">20.  this.$emit(&apos;helloWorld&apos;)  </span><br><span class="line">21.  &#125;  </span><br><span class="line">22.  &#125; </span><br><span class="line">23.  &lt;/script&gt;  </span><br><span class="line"></span><br><span class="line">25\.  // 父组件 foo.vue  </span><br><span class="line">26.  &lt;template&gt;  </span><br><span class="line">27.  &lt;div class=&quot;container&quot;&gt;  </span><br><span class="line">28.  &lt;bar :title=&quot;title&quot; @helloWorld=&quot;helloWorld&quot;&gt;&lt;/bar&gt;  </span><br><span class="line">29.  &lt;/div&gt;  </span><br><span class="line">30\.  &lt;/template&gt;  </span><br><span class="line"></span><br><span class="line">32.  &lt;script&gt;  </span><br><span class="line">33.  import Bar from &apos;./bar.vue&apos;  </span><br><span class="line">34.  export default&#123;  </span><br><span class="line">35.  data:&#123;  </span><br><span class="line">36.  title:&quot;我是标题&quot;  </span><br><span class="line">37.  &#125;,  </span><br><span class="line">38.  methods:&#123;  </span><br><span class="line">39.  helloWorld()&#123;  </span><br><span class="line">40.  console.log(&apos;我接收到子组件传递的事件了&apos;)  </span><br><span class="line">41.  &#125;  </span><br><span class="line">42.  &#125;,  </span><br><span class="line">43.  components:&#123; </span><br><span class="line">44.  Bar  </span><br><span class="line">45.  &#125;  </span><br><span class="line">46.  &lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>在小程序中，需要：<br>1.编写子组件<br>2.在子组件的json文件中，将该文件声明为组件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.  &#123;  </span><br><span class="line">2.  &quot;component&quot;: true  </span><br><span class="line">3.  &#125;</span><br></pre></td></tr></table></figure>

<p>3.在需要引入的父组件的json文件中，在usingComponents填写引入组件的组件名以及路径</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">1.  &quot;usingComponents&quot;: &#123;  </span><br><span class="line">2.  &quot;tab-bar&quot;: &quot;../../components/tabBar/tabBar&quot;  </span><br><span class="line">3.  &#125;</span><br></pre></td></tr></table></figure>

<p>4.在父组件中，直接引入即可<br><code>1.  &lt;tab-bar currentpage=&quot;index&quot;&gt;&lt;/tab-bar&gt;</code><br><strong>2.父子组件间通信</strong></p>
<p>在vue中</p>
<p>父组件向子组件传递数据，只需要在子组件通过v-bind传入一个值，在子组件中，通过props接收，即可完成数据的传递，示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">1.  // 父组件 foo.vue  </span><br><span class="line">2.  &lt;template&gt;  </span><br><span class="line">3.  &lt;div class=&quot;container&quot;&gt;  </span><br><span class="line">4.  &lt;bar :title=&quot;title&quot;&gt;&lt;/bar&gt;  </span><br><span class="line">5.  &lt;/div&gt;  </span><br><span class="line">6\.  &lt;/template&gt;  </span><br><span class="line">7.  &lt;script&gt;  </span><br><span class="line">8.  import Bar from &apos;./bar.vue&apos;  </span><br><span class="line">9.  export default&#123;  </span><br><span class="line">10.  data:&#123;  </span><br><span class="line">11.  title:&quot;我是标题&quot;  </span><br><span class="line">12.  &#125;,  </span><br><span class="line">13.  components:&#123;  </span><br><span class="line">14.  Bar  </span><br><span class="line">15.  &#125;  </span><br><span class="line">16.  &lt;/script&gt;  </span><br><span class="line"></span><br><span class="line">18\.  // 子组件bar.vue  </span><br><span class="line">19.  &lt;template&gt;  </span><br><span class="line">20.  &lt;div class=&quot;search-box&quot;&gt;  </span><br><span class="line">21.  &lt;div :title=&quot;title&quot; &gt;&lt;/div&gt;  </span><br><span class="line">22.  &lt;/div&gt;  </span><br><span class="line">23\.  &lt;/template&gt;  </span><br><span class="line">24.  &lt;script&gt;  </span><br><span class="line">25.  export default&#123;  </span><br><span class="line">26.  props:&#123;  </span><br><span class="line">27.  title:&#123;  </span><br><span class="line">28.  type:String,  </span><br><span class="line">29.  default:&apos;&apos;  </span><br><span class="line">30.  &#125;  </span><br><span class="line">31.  &#125;  </span><br><span class="line">32.  &#125;  </span><br><span class="line">33.  &lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>子组件和父组件通信可以通过this.$emit将方法和数据传递给父组件。<br>在小程序中</p>
<p>父组件向子组件通信和vue类似，但是小程序没有通过v-bind，而是直接将值赋值给一个变量，如下：<br><code>1.  &lt;tab-bar currentpage=&quot;index&quot;&gt;&lt;/tab-bar&gt;</code><br>此处， “index”就是要向子组件传递的值<br>在子组件properties中，接收传递的值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">1.  properties: &#123;  </span><br><span class="line">2.  // 弹窗标题  </span><br><span class="line">3.  currentpage: &#123;            // 属性名  </span><br><span class="line">4.  type: String,     // 类型（必填），目前接受的类型包括：String, Number, Boolean, Object, Array, null（表示任意类型）  </span><br><span class="line">5.  value: &apos;index&apos;     // 属性初始值（可选），如果未指定则会根据类型选择一个 </span><br><span class="line">6.  &#125; </span><br><span class="line">7.  &#125;</span><br></pre></td></tr></table></figure>

<p>子组件向父组件通信和vue也很类似，代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">1.  //子组件中  </span><br><span class="line">2.  methods: &#123;     </span><br><span class="line">3.  // 传递给父组件  </span><br><span class="line">4.  cancelBut: function (e) &#123;  </span><br><span class="line">5.  var that = this;  </span><br><span class="line">6.  var myEventDetail = &#123; pickerShow: false, type: &apos;cancel&apos; &#125; // detail对象，提供给事件监听函数  </span><br><span class="line">7.  this.triggerEvent(&apos;myevent&apos;, myEventDetail) //myevent自定义名称事件，父组件中使用  </span><br><span class="line">8.  &#125;, </span><br><span class="line">9.  &#125;  </span><br><span class="line">10.  //父组件中  </span><br><span class="line">11.  &lt;bar bind:myevent=&quot;toggleToast&quot;&gt;&lt;/bar&gt;   </span><br><span class="line">12.  // 获取子组件信息  </span><br><span class="line">13.  toggleToast(e)&#123;  </span><br><span class="line">14.  console.log(e.detail)  </span><br><span class="line">15.  &#125;</span><br></pre></td></tr></table></figure>

<p>如果父组件想要调用子组件的方法</p>
<p>vue会给子组件添加一个ref属性，通过this.$refs.ref的值便可以获取到该子组件，然后便可以调用子组件中的任意方法，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">1.  //子组件  </span><br><span class="line">2.  &lt;bar ref=&quot;bar&quot;&gt;&lt;/bar&gt;  </span><br><span class="line">3.  //父组件  </span><br><span class="line">4.  this.$ref.bar.子组件的方法</span><br></pre></td></tr></table></figure>

<p>小程序是给子组件添加id或者class，然后通过this.selectComponent找到子组件，然后再调用子组件的方法,示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">1.  //子组件  </span><br><span class="line">2.  &lt;bar id=&quot;bar&quot;&gt;&lt;/bar&gt;  </span><br><span class="line">3.  // 父组件  </span><br><span class="line">4.  this.selectComponent(&apos;#id&apos;).syaHello()</span><br></pre></td></tr></table></figure>

<p>小程序和vue在这点上太相似了…</p>
<hr>
<p>这些都是我们常用到的知识点，还有不足，以后慢慢改善~~！</p>
<p><a href="https://segmentfault.com/a/1190000015684864" target="_blank" rel="noopener">原文地址</a></p>
]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>小程序</tag>
      </tags>
  </entry>
</search>
