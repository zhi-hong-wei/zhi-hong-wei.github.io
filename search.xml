<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>LeetCode总结</title>
    <url>/2021/05/08/LeetCode%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="LeetCode笔记"><a href="#LeetCode笔记" class="headerlink" title="LeetCode笔记"></a>LeetCode笔记</h1><a id="more"></a>

<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>如果从根节点向下进行需要递归一次，若将左右子树作为根节点再向下进行，需要两次递归。一般递归写成单独的函数</p>
<p>递归二部曲：</p>
<p>1.写终止递归条件：if(!root) return null/0;</p>
<p>2.写递归式和递归条件：**先写递归式代表自底向上执行(有return返回值)，后写递归式代表自顶向下执行</p>
<h4 id="1-二叉树最大深度-树的高度"><a href="#1-二叉树最大深度-树的高度" class="headerlink" title="1.二叉树最大深度(树的高度)*"></a>1.二叉树最大深度(树的高度)*</h4><p><img src="/img/1587383178214.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var maxDepth = function(root) &#123;</span><br><span class="line">    if(!root) return 0;</span><br><span class="line">    return Math.max(maxDepth(root.left),maxDepth(root.right)) + 1;   //返回的是数值，每次调用加一行</span><br><span class="line">&#125;;</span><br><span class="line">//O(n)/O(Height),时间复杂度看节点数，空间复杂度看树的高度，一般为O(n)，单支树；</span><br></pre></td></tr></table></figure>

<h4 id="2-平衡二叉树"><a href="#2-平衡二叉树" class="headerlink" title="2.平衡二叉树"></a>2.平衡二叉树</h4><p><img src="/img/1587384208648.png" alt="Alt text"></p>
<p>求一个结点的最大深度本来就要遍历整个结点并求出左右子树的深度，用一个全局的变量看有没有一个结点让flag变成false即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var isBalanced = function (root) &#123;</span><br><span class="line">    //后序遍历二叉树（左右根），从底至顶返回子树最大高度</span><br><span class="line">    var flag = true;</span><br><span class="line"></span><br><span class="line">    var isBalancedHelper = function (root) &#123;</span><br><span class="line">        if (!root) return 0;</span><br><span class="line">        let l = isBalancedHelper(root.left);  //树的左子树高度</span><br><span class="line">        let r = isBalancedHelper(root.right);</span><br><span class="line">        if (Math.abs(l - r) &gt; 1) flag = false;//若不平衡，赋为false****</span><br><span class="line">        return Math.max(l,r) + 1;   //若左右子树平衡，返回当前树的深度，使用它们的高度判断父节点是否平衡</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    isBalancedHelper(root);</span><br><span class="line">    return flag;</span><br><span class="line">&#125;;</span><br><span class="line">//O(n)/O(n)</span><br><span class="line">谨记：1.在求树高的函数内，同时做判断，不能先写求树高函数，再在外面判断，那只是左右各调用一次，求的是左子树高度和右子树高度。2.***必须用flag承接，因为若是在isBalancedHelper函数内直接return，结束的是isBalancedHelper函数，不影响外面函数的返回值，所以外面函数若写死return：true，无论结果如何，都返回true。***面试时犯的错误</span><br></pre></td></tr></table></figure>

<h4 id="3-二叉树的直径x-543"><a href="#3-二叉树的直径x-543" class="headerlink" title="3. 二叉树的直径x-543"></a><strong>3. 二叉树的直径x-543</strong></h4><p><img src="/img/1587385689737.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//就是递归求左右子树高度加和的最大值，看自己方法好些</span><br><span class="line">var diameterOfBinaryTree = function(root) &#123;</span><br><span class="line">    let ans = 1;</span><br><span class="line">    function getDepth(rootNode)&#123;</span><br><span class="line">    if(!rootNode) return 0;</span><br><span class="line">    let l = getDepth(rootNode.left);</span><br><span class="line">    let r = getDepth(rootNode.right);</span><br><span class="line">    ans = Math.max(ans,l + r + 1);  //左节点高度+右节点高度+1(根节点)=总路径</span><br><span class="line">    return Math.max(l,r) + 1;</span><br><span class="line">&#125;</span><br><span class="line">    getDepth(root);</span><br><span class="line">    return ans - 1;</span><br><span class="line">&#125;;</span><br><span class="line">**************************************************************************************</span><br><span class="line">我的方法：</span><br><span class="line">var diameterOfBinaryTree = function (root) &#123;</span><br><span class="line">    if (!root) return 0</span><br><span class="line">    var deepTree = function (root) &#123;   //求树的深度</span><br><span class="line">        if (!root) return 0;</span><br><span class="line">        return Math.max(deepTree(root.left), deepTree(root.right)) + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    var temp = deepTree(root.left) + deepTree(root.right)  //求除根节点的左分支、右分支高度</span><br><span class="line">    //对每个节点都进行高度汇总，取最大值。求最大值时类似12，要把上一次求得的值放里比较（temp）</span><br><span class="line">    return Math.max(temp, diameterOfBinaryTree(root.left), diameterOfBinaryTree(root.right))</span><br><span class="line">    &#125;;</span><br><span class="line"> //O(N)/O(Height)，其中N为二叉树的节点数,Height为树高度；</span><br></pre></td></tr></table></figure>

<p>思路其实和上一个求平衡二叉树的相同，都是在求最大深度的过程中更新一个全局变量。</p>
<h4 id="4-翻转二叉树-226"><a href="#4-翻转二叉树-226" class="headerlink" title="4. 翻转二叉树-226*"></a><strong>4. 翻转二叉树-226*</strong></h4><p><img src="/img/1587385992308.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> var invertTree = function(root) &#123;</span><br><span class="line">    if(!root) return null;</span><br><span class="line">    [root.left,root.right] = [invertTree(root.right), invertTree(root.left)];</span><br><span class="line">    return root;</span><br><span class="line">&#125;;</span><br><span class="line">*********************************************************************************************</span><br><span class="line">我的方法：</span><br><span class="line">var invertTree = function (root) &#123;</span><br><span class="line">    if (!root) return null;  //就算说树非空，后面要是用到root.left或root.right，还是要判断，也是递归边界</span><br><span class="line">    let temp =  invertTree(root.right);  //从下往上遍历的，也可以从上往下，就是交换节点</span><br><span class="line">    root.right = invertTree(root.left);</span><br><span class="line">    root.left = temp</span><br><span class="line">    return root</span><br><span class="line">&#125;;</span><br><span class="line">//O(n)/O(n),N为二叉树节点的数目。我们会遍历二叉树中的每一个节点，并在常数时间内交换其两棵子树。空间由递归栈的深度决定，它等于当前节点在二叉树中的高度。在平均情况下，二叉树的高度与节点个数为对数关系，即O(logN)。而在最坏情况下，树形成链状，空间复杂度为 O(N)。</span><br></pre></td></tr></table></figure>

<p>递归<br>目的或返回值：输入一个root为根的树，返回一个以root为根的对称树<br>递归式：左子树 = 以右子树为根的对称右子树<br>               右子树 = 以左子树为根的对称左子树<br>递归边界： root为空直接返回</p>
<h4 id="5-合并二叉树-617"><a href="#5-合并二叉树-617" class="headerlink" title="5.合并二叉树-617"></a><strong>5.合并二叉树-617</strong></h4><p><img src="/img/1587386666290.png" alt="Alt text"></p>
<p>递归<br>目的：输入一个root1,root2,返回一个以root1为根的合并树<br>递归逻辑：root1.val += root2.val<br>递归式：左子树.left = 输入一个root1.left,root2.left，返回一个以root1.left为根的合并树<br>               右子树相同<br>递归边界： root1若为空则返回root2<br>                    root2若为空则返回root1(正好与递归边界有所重叠)</p>
<p>执行从上至下，每次递归会生成新的值，不仅仅是完成操作，所以要承接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var mergeTrees = function(t1, t2) &#123;</span><br><span class="line">    if(t1 === null) return t2;</span><br><span class="line">    if(t2 === null) return t1;</span><br><span class="line">    t1.val = t1.val + t2.val;   //val代表树的值，递归条件</span><br><span class="line">    t1.left = mergeTrees(t1.left,t2.left);</span><br><span class="line">    t1.right = mergeTrees(t1.right,t2.right);</span><br><span class="line">    return t1;</span><br><span class="line">&#125;</span><br><span class="line">//O(min(m,n))/O(min(m,n))，其中m和n分别是两个二叉树的节点个数;空间：递归调用的层数不会超过较小的二叉树的最大高度，最坏情况下，二叉树的高度等于节点数。</span><br><span class="line">//注：递归条件有返回值时，直接左右递归即可，没有返回值时，用左右节点承接。</span><br></pre></td></tr></table></figure>

<h4 id="6-路径总和-112"><a href="#6-路径总和-112" class="headerlink" title="6.路径总和-112**"></a><strong>6.路径总和-112**</strong></h4><p><img src="/img/1587387473678.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var hasPathSum = function(root, sum) &#123;</span><br><span class="line">        if(root === null)&#123;   //等同于if(!root)&#123;&#125;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        sum -= root.val;</span><br><span class="line">        if(sum === 0 &amp;&amp; !root.left &amp;&amp; !root.right) return true;</span><br><span class="line">        return hasPathSum(root.left,sum) || hasPathSum(root.right,sum);</span><br><span class="line">       //此处要加‘或’符号，因为顺序调用hasPathSum(root.left,sum)/(root.right,sum)时，虽遍历全树，其实判断的只是最后一次调用hasPathSum(root.right,sum)的值，5-8-4-1，返回false，但我们只要一次true就行，所以要用||取值</span><br><span class="line">&#125;;</span><br><span class="line">//O(n)/O(Height),空间复杂度取决于空间栈的开销，最坏不超过O(n)</span><br><span class="line">*************************************************************************************</span><br><span class="line">**leetcode-113求路径总和II**，要求输出满足条件的路径，存放在数组中，nums.slice()不是很懂。</span><br><span class="line">var pathSum = function (root, targetSum) &#123;</span><br><span class="line">    if (!root) return [];</span><br><span class="line">    let res = [];  //1. 设置结果集</span><br><span class="line">    let nums=[];   //2. 存放路径</span><br><span class="line">    let dfs = function (node, sum) &#123;</span><br><span class="line">        if (!node) return [];  //3. 终止递归条件</span><br><span class="line">        sum -= node.val;</span><br><span class="line">        nums.push(node.val);</span><br><span class="line">        if (!node.left &amp;&amp; !node.right &amp;&amp; sum === 0) &#123;</span><br><span class="line">            res.push(nums.slice());  //重点***需要赋新数组</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(node.left, sum);</span><br><span class="line">        dfs(node.right, sum);</span><br><span class="line">        nums.pop();   //剪枝操作，遍历到叶节点，不满足时，逐层向上剪枝</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(root, targetSum);</span><br><span class="line">    return res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>目的：输入一个root,sum,判断能否以该结点为根…<br>递归逻辑：sum - root.val是否等于0该结点为<strong>叶子结点</strong>，若为0则返回true<br>递归式：若sum已经小于0则不用递归，否则对左右子树进行递归<br>递归边界： root 为空<br><strong>注意sum可以为负值，所以不能用sum&lt;0来结束递归</strong></p>
<h4 id="7-路径总和-IIIx-437"><a href="#7-路径总和-IIIx-437" class="headerlink" title="7. 路径总和 IIIx-437"></a><strong>7. 路径总和 IIIx-437</strong></h4><p><img src="/img/1587388653606.png" alt="Alt text"></p>
<p>我的方法：</p>
<p>找所有满足条件的路径，用两个函数递归就可以遍历所有结点。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var pathSum = function (root, sum) &#123;</span><br><span class="line">    var ans = 0;</span><br><span class="line">    var pathSumHelper = function (root, sum) &#123;</span><br><span class="line">        if (!root) &#123;  //终止递归条件</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        sum -= root.val;</span><br><span class="line">        if (sum === 0) &#123;</span><br><span class="line">            ans += 1;</span><br><span class="line">        &#125;</span><br><span class="line">        pathSumHelper(root.left, sum);</span><br><span class="line">        pathSumHelper(root.right, sum);</span><br><span class="line">    &#125;</span><br><span class="line">    var traverse = function (root, sum) &#123;</span><br><span class="line">        if (!root) return;</span><br><span class="line">        pathSumHelper(root, sum);  //从根节点向下找</span><br><span class="line">        traverse(root.left, sum);  //改变根节点位置，第二次递归遍历</span><br><span class="line">        traverse(root.right, sum);</span><br><span class="line">    &#125;</span><br><span class="line">    &lt;&lt;&lt;&lt;&lt;//pathSumHelper(root, sum);  //为啥不能这么写，因为调用总函数的话，每次ans会重置，所以另写traverse</span><br><span class="line">    &lt;&lt;&lt;&lt;&lt;//pathSum(root.left, sum);</span><br><span class="line">    &lt;&lt;&lt;&lt;&lt;//pathSum(root.right, sum);</span><br><span class="line">    traverse(root, sum);  //也可以使用主函数本身递归</span><br><span class="line">    return ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>思路与上一个题类似，上一题必须从根节点开始向下求值，本题可从任一节点向下求值，所以第二次递归遍历是改变根节点位置。</p>
<p>另外一种：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var pathSum = function (root, sum) &#123;</span><br><span class="line">    function pathSumHelper(root, sum) &#123;//以一个结点为根有多少连续的路径可以得到这个sum</span><br><span class="line">        if (!root) return 0;//注意这里的递归边界</span><br><span class="line">        let res = 0;</span><br><span class="line">        if (root.val === sum) res++;</span><br><span class="line">        res += pathSumHelper(root.left, sum - root.val) + pathSumHelper(root.right, sum - root.val);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!root) return 0;</span><br><span class="line">    let ans = pathSumHelper(root, sum) + pathSum(root.left, sum) + pathSum(root.right, sum);</span><br><span class="line">    return ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其实原理都一样，但是这种写法其实更好的体现了递归的思想，一定要注意这种拿到递归的返回结果返回给一个变量的方法</p>
<h4 id="8-另一个树的子树xx-572"><a href="#8-另一个树的子树xx-572" class="headerlink" title="8.另一个树的子树xx-572"></a><strong>8.另一个树的子树xx-572</strong></h4><p><img src="/img/1587388955271.png" alt="Alt text"></p>
<p>不熟，把功能分成两层，一层为判断两个树是否相等(从根节点开始)，另外一层对树的结点进行遍历(转移到左右节点)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var isSubtree = function (s, t) &#123;</span><br><span class="line">    function isEqual(s,t)&#123;</span><br><span class="line">      if(!s &amp;&amp; !t) return true;    //后面要用到s.left和t.left/right，所以此处要判断是否为空</span><br><span class="line">      if(!s || !t)return false;</span><br><span class="line">      if(s.val === t.val) return isEqual(s.left,t.left) &amp;&amp; isEqual(s.right,t.right);//左右要一起判断，如果分别递归，就是先左子树后右子树。</span><br><span class="line">      else return false;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!s) return false;    //同上面因为只用到s，对s判断，也是终止条件</span><br><span class="line">    if (isEqual(s,t)) return true;</span><br><span class="line">    else return isSubtree(s.left, t) || isSubtree(s.right, t); //此处是从根节点移到左右节点继续判断</span><br><span class="line">&#125;;</span><br><span class="line">//O(m*n),O(max(d1,d2)),m和n是s和t的节点数，d1和d2是</span><br></pre></td></tr></table></figure>

<h4 id="9-对称二叉树xx-剑指28"><a href="#9-对称二叉树xx-剑指28" class="headerlink" title="9.对称二叉树xx-剑指28"></a><strong>9.对称二叉树xx-剑指28</strong></h4><p><img src="/img/1587389502147.png" alt="Alt text"></p>
<p>和上题类似：创新点在于“将除根节点之外的左右子树当成两棵树比较”和递归传参“(s.left，t.right)”</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var isSymmetric = function(root) &#123;</span><br><span class="line">            function isSymmetricHelper(s,t)&#123;  //将除根节点之外的左右子树当成两棵树比较</span><br><span class="line">            if(!s &amp;&amp; !t) return true;</span><br><span class="line">            if(!s || !t)return false;</span><br><span class="line">            if(s.val === t.val) return isSymmetricHelper(s.left,t.right) &amp;&amp; isSymmetricHelper(s.right,t.left);   //与-判断全符合条件的情况</span><br><span class="line">            else return false;</span><br><span class="line">            &#125;</span><br><span class="line">            if(!root) return true;</span><br><span class="line">            return isSymmetricHelper(root.left,root.right);</span><br><span class="line">&#125;;O(n)/O(n)</span><br></pre></td></tr></table></figure>

<h4 id="10-二叉树的最小深度-111"><a href="#10-二叉树的最小深度-111" class="headerlink" title="10.二叉树的最小深度-111*"></a><strong>10.二叉树的最小深度-111*</strong></h4><p><img src="/img/1587390022231.png" alt="Alt text"></p>
<p>解法1:该方法类似回溯剪枝，就是穷举遍历，迭代找最小值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var minDepth = function(root) &#123;</span><br><span class="line">    var min = 100000000;</span><br><span class="line">    function traverse(root,depth)&#123;//遍历更新全局变量</span><br><span class="line">    	if(!root) return 0; //有此判断，下面if不需要</span><br><span class="line">        depth += 1;</span><br><span class="line">        if(!root.left &amp;&amp; !root.right)&#123;       </span><br><span class="line">            min = Math.min(min, depth);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        // if(root.left)不需要了</span><br><span class="line">        traverse(root.left,depth);   //****此处depth参数不可以定义，只能传，因为定义的参数只会累加，最后min         traverse(root.right,depth);  //的值就是找完左节点的高度值。传的参数在每一层函数中值是不同的，例如                                        //[1,2,3,4,5]，定义是3，传参是2.</span><br><span class="line">    &#125;</span><br><span class="line">    if(!root) return 0;</span><br><span class="line">    traverse(root,0);</span><br><span class="line">    return min;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>解法二：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var minDepth = function (root) &#123;</span><br><span class="line">    if (!root) return 0;</span><br><span class="line">    let l = minDepth(root.left);</span><br><span class="line">    let r = minDepth(root.right);</span><br><span class="line">    //如果左子树或右子树的深度不为 0，即存在一个子树，那么当前子树的最小深度就是该子树的深度+1</span><br><span class="line">    //如果左子树和右子树的深度都不为 0，即左右子树都存在，那么当前子树的最小深度就是它们较小值+1</span><br><span class="line">    if (l == 0 || r == 0) return l + r + 1;</span><br><span class="line">    return Math.min(l, r) + 1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>也不完全一样，注意对该结点的左结点或右结点为空的情况</strong></p>
<h4 id="11-左叶子之和-404"><a href="#11-左叶子之和-404" class="headerlink" title="11.左叶子之和-404"></a><strong>11.左叶子之和-404</strong></h4><p><img src="/img/1587391010109.png" alt="Alt text"></p>
<p>方法1:</p>
<p>有左孩子，且左孩子为叶节点时累加即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var sumOfLeftLeaves = function(root) &#123;</span><br><span class="line">    if (!root) return 0;</span><br><span class="line">    let ans = 0;</span><br><span class="line">    function dfs(root) &#123;   //属于前序遍历</span><br><span class="line">        if (!root) return 0;</span><br><span class="line">        if (root.left &amp;&amp; !root.left.left &amp;&amp; !root.left.right) &#123;</span><br><span class="line">            ans += root.left.val;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root.left);</span><br><span class="line">        dfs(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(root);</span><br><span class="line">    return ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>方法2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var sumOfLeftLeaves = function(root) &#123;</span><br><span class="line">    if(!root) return 0;</span><br><span class="line">    let ans = 0;</span><br><span class="line">    if(root.left &amp;&amp; !root.left.left &amp;&amp; !root.left.right)&#123;  //左节点存在并为叶子节点时</span><br><span class="line">        ans += root.left.val;</span><br><span class="line">    &#125;</span><br><span class="line">    ans += (sumOfLeftLeaves(root.left) + sumOfLeftLeaves(root.right));  //ans+=就不会重置ans=0了</span><br><span class="line">    return ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>方法2更好的体现了递归的思想</p>
<p><strong>注意是左叶子而不是左孩子</strong></p>
<h4 id="12-最长同值路径xxx-687"><a href="#12-最长同值路径xxx-687" class="headerlink" title="12.最长同值路径xxx-687"></a><strong>12.最长同值路径xxx-687</strong></h4><p><img src="/img/1592315022106.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//自底向上执行，有返回值，若root值==左节点值，L+1，否则重置为0，右侧同理</span><br><span class="line">var longestUnivaluePath = function (root) &#123;</span><br><span class="line">    let ans = 0;</span><br><span class="line"></span><br><span class="line">    function helper(root) &#123;//从一个结点开始的最长同值路径长度</span><br><span class="line">        if (!root) return 0;</span><br><span class="line">        //注意因为要递归到底所以不能在这个时候判断相等不相等然后结束递归</span><br><span class="line">        let l = helper(root.left);</span><br><span class="line">        let r = helper(root.right);</span><br><span class="line">        //递归式在这里</span><br><span class="line">        //左右节点和根节点同值情况，感觉少了左节点和根节点同值/右节点和根节点同值情况</span><br><span class="line">        l = (root.left &amp;&amp; root.left.val === root.val) ? l + 1 : 0;</span><br><span class="line">        r = (root.right &amp;&amp; root.right.val === root.val) ? r + 1 : 0;</span><br><span class="line">        ans = Math.max(ans,l + r);</span><br><span class="line">        return Math.max(l, r);  //递归的功能就是从左子树和右子树中返回一个最长同值路径</span><br><span class="line">    &#125;</span><br><span class="line">    helper(root);</span><br><span class="line">    return ans;</span><br><span class="line">&#125;;</span><br><span class="line">*****************************************************************************************</span><br><span class="line">我的解法：</span><br><span class="line">var longestUnivaluePath = function (root) &#123;</span><br><span class="line">    let ans = 0;</span><br><span class="line">    function helper(root) &#123;//从一个结点开始的最长同值路径长度</span><br><span class="line">        if (!root) return 0;</span><br><span class="line">        let maxLorRres = 0</span><br><span class="line">        //注意因为要递归到底所以不能在这个时候判断相等不相等然后结束递归</span><br><span class="line">        let l = helper(root.left);</span><br><span class="line">        let r = helper(root.right);</span><br><span class="line">        //递归式在这里</span><br><span class="line">        if (root.left &amp;&amp; root.left.val == root.val &amp;&amp; root.right &amp;&amp; root.right.val == root.val) &#123;</span><br><span class="line">            ans = Math.max(ans, l + r + 2);</span><br><span class="line">        &#125;</span><br><span class="line">        //从左右子树中选择最长的同值路径</span><br><span class="line">        if (root.left &amp;&amp; root.left.val == root.val) &#123;</span><br><span class="line">            maxLorRres = l + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        if (root.right &amp;&amp; root.right.val == root.val) &#123;</span><br><span class="line">            maxLorRres = Math.max(maxLorRres, r + 1);</span><br><span class="line">        &#125;</span><br><span class="line">        //从ans与maxLorRres中更新最大值</span><br><span class="line">        ans = Math.max(ans, maxLorRres);</span><br><span class="line">        return maxLorRres;  //递归的功能就是从左子树和右子树中返回一个最长同值路径，此处注意</span><br><span class="line">    &#125;</span><br><span class="line">    helper(root);</span><br><span class="line">    return ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其实思路与求二叉树的直径和平衡二叉树类似<br>都是在求另外一个子目标的过程中不断更新一个最优值</p>
<h4 id="13-打家劫舍-IIIx-337"><a href="#13-打家劫舍-IIIx-337" class="headerlink" title="13.打家劫舍 IIIx-337"></a><strong>13.打家劫舍 IIIx-337</strong></h4><p><img src="/img/1587391402593.png" alt="Alt text"></p>
<p>这个题是递归的美妙应用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var rob = function (root) &#123;</span><br><span class="line">    //递归式：一个结点的最高金额和（目的） = Max(子结点的最高金额之和，孙结点最高金额和 + 自己的金额)</span><br><span class="line">    if (!root) return 0;</span><br><span class="line">    let val = root.val;</span><br><span class="line">    if (root.left) &#123;</span><br><span class="line">        val += rob(root.left.left);</span><br><span class="line">        val += rob(root.left.right);</span><br><span class="line">    &#125;</span><br><span class="line">    if (root.right) &#123;</span><br><span class="line">        val += rob(root.right.left);</span><br><span class="line">        val += rob(root.right.right);</span><br><span class="line">    &#125;</span><br><span class="line">    return Math.max(val, rob(root.left) + rob(root.right));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="14-完全二叉树节点数-222"><a href="#14-完全二叉树节点数-222" class="headerlink" title="14.完全二叉树节点数-222"></a><strong>14.完全二叉树节点数-222</strong></h4><p><img src="/img/20210406_1.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var countNodes = function (root) &#123;</span><br><span class="line">    if (!root) return 0;</span><br><span class="line">    let count = 1;</span><br><span class="line">    function dfs(root) &#123;</span><br><span class="line">        if (!root) return 0;</span><br><span class="line">        if (root.left) count += 1;</span><br><span class="line">        if (root.right) count += 1;</span><br><span class="line">        dfs(root.left);</span><br><span class="line">        dfs(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(root);</span><br><span class="line">    return count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="15-二叉树的所有路径"><a href="#15-二叉树的所有路径" class="headerlink" title="15.二叉树的所有路径"></a><strong>15.二叉树的所有路径</strong></h4><p>看回溯-例4</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>对于可以不从根结点开始的题目，要先抽象出一个简单的从根结点开始的函数，找到与原函数的递推关系，或者是在递归的过程中更新一个全局变量找到最优解</li>
<li>对树进行整体搜索时，不用返回值，查找某一路径或某一条件时有返回值</li>
<li>对于需要求路径的题目，转换为以一个结点为根的深度问题并找到与路径的递推关系</li>
<li>对于既不要求从根结点开始，又求路径的问题，结合以上两者将问题转换为在求深度的过程中更新一个全局变量</li>
</ul>
<h3 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h3><h4 id="1-二叉树的层平均值"><a href="#1-二叉树的层平均值" class="headerlink" title="1.二叉树的层平均值"></a>1.二叉树的层平均值</h4><p><img src="/img/1587984252519.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">层次遍历：1、定义空队列。2、根节点入队列。3、while循环（队列不空）。4.获取队列长度用以for循环。5.每次对队头元素判断左右节点是否为空，push进队列。6.最后出队列。</span><br><span class="line">var averageOfLevels = function (root) &#123;</span><br><span class="line">    var q = [];</span><br><span class="line">    var ans = [];</span><br><span class="line">    q.push(root);   //***推进来的都是节点**</span><br><span class="line">    while (q.length !== 0) &#123;</span><br><span class="line">        let sum = 0;</span><br><span class="line">        let len = q.length;</span><br><span class="line">        for (let i = 0; i &lt; len; i++) &#123;</span><br><span class="line">            sum += q[0].val;//注意这个地方下标都为0，因为出队后下标会发生改变，运算使用val</span><br><span class="line">            if (q[0].left) q.push(q[0].left);</span><br><span class="line">            if (q[0].right) q.push(q[0].right);</span><br><span class="line">            q.shift();//队首出队用shift()</span><br><span class="line">        &#125;</span><br><span class="line">        ans.push(sum / len);</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;;  //O(n)/O(n)</span><br></pre></td></tr></table></figure>

<h4 id="2-找树左下角的值"><a href="#2-找树左下角的值" class="headerlink" title="2.找树左下角的值"></a>2.找树左下角的值</h4><p><img src="/img/1587984306440.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//从右侧入队列</span><br><span class="line">var findBottomLeftValue = function (root) &#123;</span><br><span class="line">    let q = [];</span><br><span class="line">    q.push(root);</span><br><span class="line">    let ans = root;</span><br><span class="line">    while (q.length) &#123;</span><br><span class="line">        let len = q.length;</span><br><span class="line">        for (let i = 0; i &lt; len; i++) &#123;</span><br><span class="line">            ans = q[0];</span><br><span class="line">            if (q[0].right) q.push(q[0].right);//注意是从右孩子开始入队</span><br><span class="line">            if (q[0].left) q.push(q[0].left);</span><br><span class="line">            q.shift();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans.val;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="3-二叉树的层次遍历102"><a href="#3-二叉树的层次遍历102" class="headerlink" title="3.二叉树的层次遍历102*"></a>3.二叉树的层次遍历102*</h4><p><img src="/img/20201123.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var levelOrder = function (root) &#123;</span><br><span class="line">    if (!root) return [];</span><br><span class="line">    let q = [];</span><br><span class="line">    let ans = [];  // 存放遍历结果</span><br><span class="line">    q.push(root);</span><br><span class="line">    let level = 0;  // 代表当前层数</span><br><span class="line">    while (q.length) &#123;</span><br><span class="line">        let len = q.length;  // 第level层的节点数量</span><br><span class="line">        ans[level] = [];  // 第level层的遍历结果</span><br><span class="line">        for (let i = 0; i &lt; len; i++) &#123;</span><br><span class="line">            let temp = q.shift();  //由变量保存出来节点，后面就不用q[0]判断</span><br><span class="line">            ans[level].push(temp.val);</span><br><span class="line">            if (temp.left) q.push(temp.left);  //（589）</span><br><span class="line">            if (temp.right) q.push(temp.right);</span><br><span class="line">        &#125;</span><br><span class="line">        level++;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;   //LeetCode-107若要求从底向上层次遍历的话，只需反转数组即可</span><br><span class="line">                  //LeetCode-589若要求算N叉树的层次遍历，将上述（589）改为</span><br><span class="line">                  for (int i = 0; i &lt; node-&gt;children.size(); i++) &#123; // 将节点孩子加入队列，c++的</span><br><span class="line">                    if (node-&gt;children[i]) que.push(node-&gt;children[i]);</span><br><span class="line">                &#125;</span><br><span class="line">&#125;;  //O(n)/O(n)</span><br></pre></td></tr></table></figure>

<h3 id="前中后序遍历"><a href="#前中后序遍历" class="headerlink" title="前中后序遍历"></a>前中后序遍历</h3><h4 id="1-非递归实现二叉树的前序遍历x"><a href="#1-非递归实现二叉树的前序遍历x" class="headerlink" title="1.非递归实现二叉树的前序遍历x"></a>1.非递归实现二叉树的前序遍历x</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">前中后遍历：1、定义空栈。2、根节点入栈。3、while循环（栈不空），根节点出栈，右,左子树进栈(注意进栈顺序)。</span><br><span class="line">var preorderTraversal = function (root) &#123;</span><br><span class="line">    let ans = [];</span><br><span class="line">    let stack = [];</span><br><span class="line">    if(root) stack.push(root);</span><br><span class="line">    while (stack.length) &#123;</span><br><span class="line">        let temp = stack.pop();  //先出栈就要用结点承接，上题层次遍历同理</span><br><span class="line">        ans.push(temp.val);</span><br><span class="line">        if (temp.right) stack.push(temp.right);</span><br><span class="line">        if (temp.left) stack.push(temp.left);</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>先入根结点，再依次遍历是<strong>先入右孩子，再入左孩子</strong></p>
<h4 id="2-非递归后序遍历x"><a href="#2-非递归后序遍历x" class="headerlink" title="2.非递归后序遍历x"></a>2.非递归后序遍历x</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var postorderTraversal = function (root) &#123;</span><br><span class="line">    let ans = [];</span><br><span class="line">    let stack = [];</span><br><span class="line">    if (root) stack.push(root);</span><br><span class="line">    while (stack.length) &#123;</span><br><span class="line">        let temp = stack.pop();</span><br><span class="line">        ans.push(temp.val);</span><br><span class="line">        if (temp.left) stack.push(temp.left);</span><br><span class="line">        if (temp.right) stack.push(temp.right);</span><br><span class="line">    &#125;</span><br><span class="line">    return ans.reverse();</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>先入根结点，再入左孩子，再入右孩子，最后再反转<br>思路与前序类似，就是最后要再反转</p>
<h4 id="3-非递归二叉树的中序遍历"><a href="#3-非递归二叉树的中序遍历" class="headerlink" title="3.非递归二叉树的中序遍历*"></a>3.非递归二叉树的中序遍历*</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var inorderTraversal = function(root) &#123;</span><br><span class="line">    let stack = [];</span><br><span class="line">    let ans = [];</span><br><span class="line">    let node = root;</span><br><span class="line">    while(node || stack.length !== 0)&#123;  //开始根节点并不入栈，所以加判断条件node</span><br><span class="line">        while(node)&#123;</span><br><span class="line">            stack.push(node);  //根节点在这里入栈，不要提前入</span><br><span class="line">            node = node.left;  //左侧节点全部入栈</span><br><span class="line">        &#125;</span><br><span class="line">        let temp = stack.pop();</span><br><span class="line">        ans.push(temp.val);</span><br><span class="line">        node = temp.right;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>根入栈后一直左孩子入栈，直到入不了了再出栈顶从栈顶的右孩子重复</p>
<h3 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h3><h4 id="0-验证二叉搜索树"><a href="#0-验证二叉搜索树" class="headerlink" title="0.验证二叉搜索树"></a>0.验证二叉搜索树</h4><p><img src="/img/2021124-3.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var isValidBST = function (root) &#123;  //二叉搜索树中序遍历后是递增的数组，判断后一项大于前一项即可</span><br><span class="line">    let queue = [];</span><br><span class="line">    function dfs(root)&#123;</span><br><span class="line">        if(!root) return;  //测试用例1&lt;size&lt;1000</span><br><span class="line">        dfs(root.left);</span><br><span class="line">        queue.push(root.val);</span><br><span class="line">        dfs(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(root);</span><br><span class="line">    for(let i=0;i&lt;queue.length-1;i++)&#123;   //使用数组承接和在中序里判断相差不多</span><br><span class="line">        if(queue[i]&gt;=queue[i+1]) return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="1-二叉搜索树的搜索"><a href="#1-二叉搜索树的搜索" class="headerlink" title="1.二叉搜索树的搜索*"></a>1.二叉搜索树的搜索*</h4><p><img src="/img/20210407.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//搜索某一结点，先比根节点，再递归比左右树，因为只需找到符合条件的，不必遍历整棵树，所以要return递归函数</span><br><span class="line">var searchBST = function (root, val) &#123;</span><br><span class="line">    if (!root || root.val === val) return root;</span><br><span class="line">    if (root.val &lt; val) return searchBST(root.right, val);</span><br><span class="line">    if (root.val &gt; val) return searchBST(root.left, val);</span><br><span class="line">    return null;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-修剪二叉搜索树"><a href="#2-修剪二叉搜索树" class="headerlink" title="2.修剪二叉搜索树"></a>2.修剪二叉搜索树</h4><p><img src="/img/1587984704434.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var trimBST = function(root, L, R) &#123;</span><br><span class="line">    //目的：返回以一个结点为根的修建后的二叉树</span><br><span class="line">    //递归式：若结点值小于要求，则返回以右结点为根修剪后的二叉树</span><br><span class="line">    //若结点值大于要求，则返回以左结点为根修剪后的二叉树</span><br><span class="line">    //若满足要求，则将左孩子修剪后返回给左孩子，右孩子修剪后返回右孩子</span><br><span class="line">    //边界条件：root为空,返回空；</span><br><span class="line">    if(!root) return null;</span><br><span class="line">    if(root.val &lt; L) return trimBST(root.right,L ,R );//记得填满参数呀！！！</span><br><span class="line">    if(root.val &gt; R) return trimBST(root.left,L ,R );</span><br><span class="line">    root.left = trimBST(root.left,L ,R );</span><br><span class="line">    root.right = trimBST(root.right, L, R);</span><br><span class="line">    return root;</span><br><span class="line">&#125;;</span><br><span class="line">//O(N)，其中N是给定的树的全部节点。我们最多访问每个节点一次。O(N)即使我们没有明确使用任何额外的内存，在最糟糕的情况下，我们递归调用的栈可能与节点数一样大。</span><br></pre></td></tr></table></figure>

<p>注意这是二叉搜索树，左孩子的值都小于根，右孩子的值都大于根，所以若一个结点根的值大于范围，这个结点和右孩子都不能要，反之左孩子都不能要</p>
<h4 id="3-寻找二叉查找树的第-k-小的元素"><a href="#3-寻找二叉查找树的第-k-小的元素" class="headerlink" title="3.寻找二叉查找树的第 k 小的元素*"></a>3.寻找二叉查找树的第 k 小的元素*</h4><p><img src="/img/1587985079176.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var kthSmallest = function(root, k) &#123;</span><br><span class="line">    //二叉搜索树的两个重要性质</span><br><span class="line">    //1.左子树的所有结点比根结点小，右子树的所有结点比根结点打</span><br><span class="line">    //2.中序遍历后的数组仍然有序</span><br><span class="line">    let ans = 0;</span><br><span class="line">    let now = 0;</span><br><span class="line">    function inOrder(root,k)&#123;</span><br><span class="line">        if(!root) return;</span><br><span class="line">        inOrder(root.left,k);</span><br><span class="line">        now += 1;//用来计数是第几个数，由于有序，第几个数就是第几小</span><br><span class="line">        if(now === k)&#123;</span><br><span class="line">            ans = root.val;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        inOrder(root.right,k);</span><br><span class="line">    &#125;</span><br><span class="line">    inOrder(root,k);</span><br><span class="line">    return ans;</span><br><span class="line">&#125;;</span><br><span class="line">*********************************************************************************</span><br><span class="line">var kthSmallest = function (root, k) &#123;</span><br><span class="line">    let q=[];</span><br><span class="line">    function inroder(root) &#123;  //中序排序，存入数组,还是第一种快</span><br><span class="line">        if(!root) return;</span><br><span class="line">        inroder(root.left);</span><br><span class="line">        q.push(root.val);</span><br><span class="line">        inroder(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    inroder(root);</span><br><span class="line">    return q[k-1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>灵活运用了二叉搜索树的遍历后数组仍然有序的性质，并且运用一个计数来提前结束递归</p>
<h4 id="4-把二叉搜索树转换为累加树-538"><a href="#4-把二叉搜索树转换为累加树-538" class="headerlink" title="4. 把二叉搜索树转换为累加树-538"></a>4. 把二叉搜索树转换为累加树-538</h4><p><img src="/img/1587986241482.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var convertBST = function (root) &#123;</span><br><span class="line">//注意执行顺序，右-根-左，使用递归中序的翻转即可。</span><br><span class="line">    var sum = 0;</span><br><span class="line">    function midTra(root) &#123;</span><br><span class="line">        if(!root) return;</span><br><span class="line">        midTra(root.right);</span><br><span class="line">        sum += root.val;</span><br><span class="line">        root.val = sum;</span><br><span class="line">        midTra(root.left);</span><br><span class="line">    &#125;</span><br><span class="line">    midTra(root);</span><br><span class="line">    return root;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>同样灵活运用了二叉搜索树中序遍历有序的性质，右中左遍历得到由大到小的序列，再通过一个变量计数积累和从而进行运算</p>
<h4 id="5-二叉搜索树的最近公共祖先-剑指68I"><a href="#5-二叉搜索树的最近公共祖先-剑指68I" class="headerlink" title="5.二叉搜索树的最近公共祖先-剑指68I*"></a>5.二叉搜索树的最近公共祖先-剑指68I*</h4><p><img src="/img/1587986405782.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//二叉搜索树规律：递归+要实现的功能</span><br><span class="line">var lowestCommonAncestor = function(root, p, q) &#123;</span><br><span class="line">    if(root.val &gt; p.val &amp;&amp; root.val &gt; q.val) return lowestCommonAncestor(root.left,p,q);</span><br><span class="line">    if(root.val &lt; p.val &amp;&amp; root.val &lt; q.val) return lowestCommonAncestor(root.right,p,q);</span><br><span class="line">    return root;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注意返回的是<strong>结点</strong>，输入的也是<strong>结点</strong><br>灵活运用了二叉搜索树的右边大，左边小的性质</p>
<h4 id="6-二叉树的最近公共祖先-x-剑指68II"><a href="#6-二叉树的最近公共祖先-x-剑指68II" class="headerlink" title="6.二叉树的最近公共祖先 x-剑指68II*"></a>6.二叉树的最近公共祖先 x-剑指68II*</h4><p><img src="/img/1587988304011.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//此题为二叉树*  递归寻找左右子树值，若在左右子树中，返回根节点，若在一棵子树中，返回该递归节点。</span><br><span class="line">var lowestCommonAncestor = function(root, p, q) &#123;</span><br><span class="line">    if(!root || root.val === p.val || root.val === q.val)&#123;  //终止条件+*查找条件</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">    let l = lowestCommonAncestor(root.left,p,q);   //l和r代表节点值*，都能找到，代表祖先是根节点</span><br><span class="line">    let r = lowestCommonAncestor(root.right,p,q);</span><br><span class="line">    if(l &amp;&amp; r) return root; //两棵子树中情况</span><br><span class="line">    return l ? l : r;  //在一颗子树上</span><br><span class="line">&#125;;  //若查找2/4结点，运行完，l=2,r=null,返回l结点</span><br></pre></td></tr></table></figure>

<p><strong>结点值唯一的条件特别重要</strong><br>其实就是往左右子树找这两个数的过程，对这些值进行一些判断返回答案</p>
<h4 id="7-二叉搜索树的插入"><a href="#7-二叉搜索树的插入" class="headerlink" title="7.二叉搜索树的插入"></a>7.二叉搜索树的插入</h4><p><img src="/img/20210407_2.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var insertIntoBST = function (root, val) &#123;</span><br><span class="line">    if (root == null) &#123;</span><br><span class="line">        return new TreeNode(val);    //将新节点传给上层函数</span><br><span class="line">    &#125;</span><br><span class="line">    if (val &lt; root.val) &#123;</span><br><span class="line">        root.left = insertIntoBST(root.left, val);   //用节点承接才能加上新节点</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        root.right = insertIntoBST(root.right, val);</span><br><span class="line">    &#125;</span><br><span class="line">    return root;   //返回根节点</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="7-将有序数组转换为二叉搜索树x"><a href="#7-将有序数组转换为二叉搜索树x" class="headerlink" title="7.将有序数组转换为二叉搜索树x"></a>7.将有序数组转换为二叉搜索树x</h4><p><img src="/img/1589294506708.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//取中间值赋给新建空结点，再截取数组，递归赋值</span><br><span class="line">var sortedArrayToBST = function(nums) &#123;</span><br><span class="line">    if(nums.length === 0) return null;</span><br><span class="line">    let len = nums.length;</span><br><span class="line">    let mid = Math.floor(len/2);  //注意js的向下取整，**直接折半**</span><br><span class="line">    let node = new TreeNode(nums[mid]);  //创建一个根节点</span><br><span class="line">    let left_nums = nums.slice(0,mid);  //分成两个数组</span><br><span class="line">    let right_nums = nums.slice(mid + 1);  //mid+1除去根节点了</span><br><span class="line">    node.left = sortedArrayToBST(left_nums);  //递归执行赋给左右子树</span><br><span class="line">    node.right = sortedArrayToBST(right_nums);</span><br><span class="line">    return node;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>js向下取整Math.floor()<br>向上取整Math.ceil()<br>直接运算是带小数的<br>slice方法(m,n)取下标从m至<strong>n-1</strong><br>slice(m)取下标为m到结尾的值，若m大于最大下标则返回空数组</p>
<h4 id="8-有序链表转换二叉搜索树"><a href="#8-有序链表转换二叉搜索树" class="headerlink" title="8.有序链表转换二叉搜索树"></a>8.有序链表转换二叉搜索树</h4><p><img src="/img/1589465681766.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//多一步链表转数组</span><br><span class="line">var sortedListToBST = function (head) &#123;</span><br><span class="line">    function transe(head)&#123;  //该方法链表转数组</span><br><span class="line">        if(head instanceof Array) return head;</span><br><span class="line">        let nums = [];</span><br><span class="line">        while(head !== null)&#123;</span><br><span class="line">            nums[nums.length] = head.val;  //数组变长赋值，并用val取值</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    let nums = transe(head);</span><br><span class="line"></span><br><span class="line">    if (nums.length === 0) return null;</span><br><span class="line">    let len = nums.length;</span><br><span class="line">    let mid = Math.floor(len / 2);</span><br><span class="line">    let node = new TreeNode(nums[mid]);</span><br><span class="line">    let left_nums = nums.slice(0, mid);</span><br><span class="line">    let right_nums = nums.slice(mid + 1);</span><br><span class="line">    node.left = sortedListToBST(left_nums);</span><br><span class="line">    node.right = sortedListToBST(right_nums);</span><br><span class="line">    return node;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>跟上一题思路相同，就是转化一下为数组即可</p>
<h4 id="9-两数之和-IV-输入-BST"><a href="#9-两数之和-IV-输入-BST" class="headerlink" title="9.两数之和 IV - 输入 BST"></a>9.两数之和 IV - 输入 BST</h4><p><img src="/img/1592221297937.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//查找某些值是否存在，存在返回true--使用map存储</span><br><span class="line">var findTarget = function(root, k) &#123;</span><br><span class="line">   let map=new Map();  //定义一个map</span><br><span class="line">   let flag=false;</span><br><span class="line">   function inorder(root,k)&#123;  //递归中序遍历</span><br><span class="line">       if(!root) return false;</span><br><span class="line">       inorder(root.left,k);</span><br><span class="line">       if(map.has(k-root.val)) flag=true;</span><br><span class="line">       map.set(root.val,root.val);  //设置下标和值</span><br><span class="line">       inorder(root.right,k);</span><br><span class="line">   &#125;</span><br><span class="line">   inorder(root,k);</span><br><span class="line">   return flag;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注意map的用法<br>这个题其实是不是二叉搜索树都没有关系，因为有可能左右子树都有</p>
<h4 id="10-二叉搜索树的最小绝对差x"><a href="#10-二叉搜索树的最小绝对差x" class="headerlink" title="10.二叉搜索树的最小绝对差x"></a>10.二叉搜索树的最小绝对差x</h4><p><img src="/img/1589523922829.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//二叉搜索树多考虑中序遍历，遍历完是递增序列，对两相邻元素，只需定义pre变量即可，在根节点处进行逻辑判断</span><br><span class="line">var getMinimumDifference = function (root) &#123;</span><br><span class="line">    let pre;</span><br><span class="line">    let max = Number.MAX_VALUE;</span><br><span class="line">    function inorder(root) &#123;</span><br><span class="line">        if (!root) return null;</span><br><span class="line">        inorder(root.left);</span><br><span class="line">        if (pre !== null &amp;&amp; root.val - pre &lt; max) &#123;</span><br><span class="line">            max = root.val - pre;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = root.val;</span><br><span class="line">        inorder(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    inorder(root);</span><br><span class="line">    return max;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其实就是运用中序遍历的性质即可</p>
<h4 id="11-二叉搜索树中的众数"><a href="#11-二叉搜索树中的众数" class="headerlink" title="11.二叉搜索树中的众数"></a>11.二叉搜索树中的众数</h4><p><img src="/img/1589526185223.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//可以中序遍历后存到hash表中，不过多用了一个O(n)的空间，代码量大，重要度小</span><br><span class="line">var findMode = function (root) &#123;</span><br><span class="line">    let ans = [] //输出的承接数组</span><br><span class="line">    let temp = 1 //相同元素个数的承载变量</span><br><span class="line">    let pre  //前一个元素</span><br><span class="line">    let count = 1 //计数有多少相同的</span><br><span class="line">    function inorder(root) &#123;</span><br><span class="line">        if (!root) return []</span><br><span class="line">        inorder(root.left)</span><br><span class="line">        //******逻辑处理部分，可单独抽成一个函数******</span><br><span class="line">        if (root.val == pre) &#123;  //逐个与前一个比较，相同加一，不同重置</span><br><span class="line">            count++</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            count = 1;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = root.val  //后移一位</span><br><span class="line">        if (temp &lt; count) &#123;</span><br><span class="line">            temp = count</span><br><span class="line">            ans=[root.val]</span><br><span class="line">        &#125;else if(temp == count)&#123;</span><br><span class="line">            ans.push(root.val)</span><br><span class="line">        &#125;</span><br><span class="line">        //******逻辑处理部分******</span><br><span class="line">        inorder(root.right)</span><br><span class="line">    &#125;</span><br><span class="line">    inorder(root);</span><br><span class="line">    return ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注意最后一次的记录要再识别一次</p>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="基础之删除链表"><a href="#基础之删除链表" class="headerlink" title="基础之删除链表"></a>基础之删除链表</h3><p><img src="/img/20210315.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//创建头结点便于删除和返回新链表</span><br><span class="line">var removeElements = function (head, val) &#123;  //若要判断是否为空，需返回元素本身，不能返回[]</span><br><span class="line">    let node = new ListNode();  //创建虚拟头节点，指针不动用以返回最后输出结果</span><br><span class="line">    let pre = node;  //用以移动的指针</span><br><span class="line">    let curr = head;  //同理</span><br><span class="line">    node.next = head;</span><br><span class="line">    while (curr) &#123;</span><br><span class="line">        if (curr.val == val) &#123;</span><br><span class="line">            pre.next = curr.next;</span><br><span class="line">            curr = pre.next;  //删除后当前指针后移</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            pre=curr;  //两指针都后移</span><br><span class="line">            curr=curr.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return node.next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>链表题多采用：改指针指向、递归、栈、双指针等方式，循环使用while</p>
<h3 id="1-相交链表-160"><a href="#1-相交链表-160" class="headerlink" title="1.相交链表-160*"></a>1.相交链表-160*</h3><p><img src="/img/1589637492986.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//让a走完a链表后再走b链表，让b走完b链表后再走a链表，会在交点相遇</span><br><span class="line">var getIntersectionNode = function(headA, headB) &#123;</span><br><span class="line">    let a = headA;</span><br><span class="line">    let b = headB;</span><br><span class="line">    while(a !== b)&#123;</span><br><span class="line">        a = (a === null) ? headB : a.next;</span><br><span class="line">        b = (b === null) ? headA : b.next;</span><br><span class="line">    &#125;</span><br><span class="line">    return a;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>设 A 的长度为 a + c，B 的长度为 b + c，其中 c 为尾部公共部分长度，可知 a + c + b = b + c + a。</p>
<p>当访问 A 链表的指针访问到链表尾部时，令它从链表 B 的头部开始访问链表 B；同样地，当访问 B 链表的指针访问到链表尾部时，令它从链表 A 的头部开始访问链表 A。这样就能控制访问 A 和 B 两个链表的指针能同时访问到交点。</p>
<p><strong>如果不存在交点，那么 a + b = b + a，以下实现代码中 l1 和 l2 会同时为 null，从而退出循环。</strong></p>
<h3 id="2-反转链表x-剑指24"><a href="#2-反转链表x-剑指24" class="headerlink" title="2. 反转链表x-剑指24*"></a>2. 反转链表x-剑指24*</h3><p><img src="/img/1589727002390.png" alt="Alt text"></p>
<h4 id="递归：x"><a href="#递归：x" class="headerlink" title="递归：x"></a>递归：x</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var reverseList = function(head) &#123;</span><br><span class="line">    if(head === null || head.next === null) return head;</span><br><span class="line">    let newNode = reverseList(head.next);//实际上这个newNode是为了保存最后一个结点的位置好返回最后的结果</span><br><span class="line">    head.next.next = head;</span><br><span class="line">    head.next = null;</span><br><span class="line">    return newNode;  //返回开始节点-&gt;5</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>递归式： 以下一个结点为开头的结点进行反转然后再改变这一个结点的指针指向</p>
<h4 id="迭代x"><a href="#迭代x" class="headerlink" title="迭代x"></a>迭代x</h4><p><img src="/img/reserveLink1.png" alt="Alt text"></p>
<p><img src="/img/reserveLink2.png" alt="Alt text"></p>
<p><img src="/img/reserveLink3.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//往前指即可，三个变量，pre、current、temp保存下一个值</span><br><span class="line">var reverseList = function (head) &#123;</span><br><span class="line">    let prev = null;</span><br><span class="line">    let curr = head,temp;</span><br><span class="line">    while (curr) &#123;</span><br><span class="line">        temp=curr.next;  //保存后一个节点值</span><br><span class="line">        curr.next=prev;  //改变指针指向，反向指</span><br><span class="line">        prev=curr;  //prev节点后移</span><br><span class="line">        curr=temp;  //curr节点后移</span><br><span class="line">    &#125;</span><br><span class="line">    return prev;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="3-合并两个有序链表"><a href="#3-合并两个有序链表" class="headerlink" title="3.合并两个有序链表**"></a>3.合并两个有序链表**</h3><p><img src="/img/1589767548671.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//递归比较开始节点值，若l1小，l1.next=递归(l1.next,l2),反之l2.next=...</span><br><span class="line">var mergeTwoLists = function(l1, l2) &#123;</span><br><span class="line">    if(l1 === null) return l2;  //这里的l1和l2仅代表一个节点</span><br><span class="line">    if(l2 === null) return l1;</span><br><span class="line">    if(l1.val &lt; l2.val)&#123;</span><br><span class="line">        l1.next = mergeTwoLists(l1.next,l2);</span><br><span class="line">        return l1;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        l2.next = mergeTwoLists(l1,l2.next);</span><br><span class="line">        return l2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>一种排序的新思路，因为指针只需要改变指向即可，所以在这里用这种递归改变指针的方法就会更快不需要新创建结点</p>
<h3 id="4-删除排序链表中的重复元素xx"><a href="#4-删除排序链表中的重复元素xx" class="headerlink" title="4.删除排序链表中的重复元素xx"></a>4.删除排序链表中的重复元素xx</h3><p><img src="/img/1589768109558.png" alt="Alt text"></p>
<p>很妙的递归解法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var deleteDuplicates = function (head) &#123;</span><br><span class="line">    if (!head || !head.next) return head;</span><br><span class="line">    head.next = deleteDuplicates(head.next); </span><br><span class="line">    if (head.val === head.next.val) head.next = head.next.next;</span><br><span class="line">    return head;</span><br><span class="line">&#125;;</span><br><span class="line">*************************************************************************************</span><br><span class="line">//迭代算法</span><br><span class="line">var deleteDuplicates = function (head) &#123;</span><br><span class="line">    if (!head || !head.next) return head;</span><br><span class="line">    let current = head;</span><br><span class="line">    while (current != null &amp;&amp; current.next != null) &#123;</span><br><span class="line">        if (current.val == current.next.val) &#123;</span><br><span class="line">            current.next = current.next.next;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return head;</span><br><span class="line">&#125;;//也可以快慢指针</span><br></pre></td></tr></table></figure>

<p>若从程序执行的角度考虑就是递归到最后一个结点然后往回进行对比，递归解决链表的问题可以很好的解决由于指针的指向问题的改变引发的问题因为是从后往前进行修改<br>若从递归的角度看：<br>递归式就是将本次的next改为以下一个指针开头的不重复排序链表，然后对比这个结点的值和这个不重复链表的开头的结点的值返回结果。<br><strong>递归的思考方式只需要考虑递归式</strong></p>
<h3 id="5-删除链表的倒数第N个节点xx"><a href="#5-删除链表的倒数第N个节点xx" class="headerlink" title="5.删除链表的倒数第N个节点xx*"></a>5.删除链表的倒数第N个节点xx*</h3><p><img src="/img/1589858750861.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//我们可以设想假设设定了双指针 p 和 q 的话，当 q 指向末尾的 NULL，p 与 q 之间相隔的元素个数为 n 时，那么删除掉 p 的下一个指针就完成了要求。</span><br><span class="line">var removeNthFromEnd = function (head, n) &#123;</span><br><span class="line">    if(!head) return head</span><br><span class="line">    let preHead = new ListNode(0)  //创建头结点</span><br><span class="line">    preHead.next = head  //头结点指向开始节点，**关键**</span><br><span class="line">    let p = preHead, q = preHead</span><br><span class="line">    for (let i = 0; i &lt; n + 1; i++) &#123;  //q指针后移n+1位置</span><br><span class="line">       q=q.next</span><br><span class="line">    &#125;</span><br><span class="line">    while(q)&#123;  //p,q一起后移到q==null，此时p后面的即为要删除的元素</span><br><span class="line">        p=p.next</span><br><span class="line">        q=q.next</span><br><span class="line">    &#125;</span><br><span class="line">    p.next=p.next.next  //改变指针指向</span><br><span class="line">    let returnHead=preHead.next  //将新的链表赋给新节点</span><br><span class="line">    return returnHead</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>利用双指针找到要删除的结点的前一个结点进行删除，若删除的是头结点可以特判</p>
<h3 id="6-两两交换链表中的节点"><a href="#6-两两交换链表中的节点" class="headerlink" title="6.两两交换链表中的节点"></a>6.两两交换链表中的节点</h3><p><img src="/img/1589860185308.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//类似4，递归法</span><br><span class="line">var swapPairs = function(head) &#123;</span><br><span class="line">    if (!head || !head.next) return head;  //!head代表没节点，!head.next代表只有一个节点</span><br><span class="line">    let newHead=head.next  //原链表第二个节点存起来</span><br><span class="line">    head.next=swapPairs(newHead.next)  //新链表第二个节点指向递归内容（原链表第二个节点的后一节点），递归位置不能变，递归写在前面代表从后向前执行</span><br><span class="line">    newHead.next=head  //新链表第一个结点指向原链表第一个结点，写在递归之后</span><br><span class="line">    return newHead  //这是新返回的第一个节点</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>和前面的题的递归思路很想，也可以用迭代重新生成一个链的方式来解决</p>
<h3 id="7-链表求和"><a href="#7-链表求和" class="headerlink" title="7.链表求和"></a>7.链表求和</h3><p><img src="/img/1589990037719.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//使用栈空间，因为要逆序运算</span><br><span class="line">var addTwoNumbers = function (l1, l2) &#123;</span><br><span class="line">    let stack1 = [];</span><br><span class="line">    let stack2 = [];</span><br><span class="line">    let carry = 0;  //进制，非0即1</span><br><span class="line">    let dummy = new ListNode();//头结点，传不传0都可**</span><br><span class="line">    while (l1) &#123;</span><br><span class="line">        stack1.push(l1.val);  //节点值入栈**，注意val</span><br><span class="line">        l1 = l1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    while (l2) &#123;</span><br><span class="line">        stack2.push(l2.val);  //节点值入栈**</span><br><span class="line">        l2 = l2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    //进行相加</span><br><span class="line">    while (stack1.length || stack2.length || carry) &#123;   //carry为1的话，也要再执行一次，例[5][5]**</span><br><span class="line">        let stack1Num = stack1.pop() || 0;//解决个数不匹配问题</span><br><span class="line">        let stack2Num = stack2.pop() || 0;</span><br><span class="line">        let current = (stack1Num + stack2Num + carry) % 10;</span><br><span class="line">        carry = Math.floor((stack1Num + stack2Num + carry) / 10);</span><br><span class="line">        </span><br><span class="line">        let newNode = new ListNode(current);  //current为节点值，创建一个节点值为current的节点</span><br><span class="line">        newNode.next = dummy.next;  //注意用头插法插入结点保证顺序，两步走**</span><br><span class="line">        dummy.next = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    return dummy.next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>使用栈来进行逆序的运算的思想</p>
<h3 id="8-回文链表xx"><a href="#8-回文链表xx" class="headerlink" title="8.回文链表xx"></a>8.回文链表xx</h3><p><img src="/img/1590292514346.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var isPalindrome = function (head) &#123;</span><br><span class="line">    //递归反转链表</span><br><span class="line">    function reverseList(head)&#123;</span><br><span class="line">        let pre = null;</span><br><span class="line">        let next = null;</span><br><span class="line">        while(head)&#123;</span><br><span class="line">            next = head.next</span><br><span class="line">            head.next = pre;</span><br><span class="line">            pre = head;</span><br><span class="line">            head = next</span><br><span class="line">        &#125;</span><br><span class="line">        return pre;</span><br><span class="line">    &#125;</span><br><span class="line">    function cut(head,cutNode)&#123;//cut一个list</span><br><span class="line">        while(head.next != cutNode)&#123;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        head.next = null;</span><br><span class="line">    &#125;</span><br><span class="line">    function isEqual(head1,head2)&#123;//判断两个list是否相等</span><br><span class="line">        while(head1 &amp;&amp; head2)&#123;</span><br><span class="line">            if(head1.val != head2.val) return false;</span><br><span class="line">            head1 = head1.next;</span><br><span class="line">            head2 = head2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    if(head === null || head.next === null) return true;</span><br><span class="line">    //找到要cut的结点即中间的结点！！！</span><br><span class="line">    let fast = head;</span><br><span class="line">    let slow = head;</span><br><span class="line">    while(fast &amp;&amp; fast.next)&#123;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    cut(head,slow);</span><br><span class="line">    return isEqual(head,reverseList(slow))</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>一定要注意怎么去找的cut的结点，通过快指针比慢指针快一步的这种方法：<br>对于奇数个的链表fast会指向最后一个结点，slow会指向中间的结点<br>对于偶数个的链表fast会指向null, slow会指向中间偏右一个的结点</li>
<li>是把cutnode的前一个结点的next设置为null,从而让前半部分保持正序</li>
<li>后半部分是先以slow为起点，但是反转了过后就是以尾为起点</li>
<li>在比较两个list的时候只比较相同的个数所以不用管奇数个结点时多出来的那一个结点<h3 id="9-分隔链表xxx"><a href="#9-分隔链表xxx" class="headerlink" title="9.分隔链表xxx"></a>9.分隔链表xxx</h3><img src="/img/1592224449984.png" alt="Alt text"><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var splitListToParts = function(root, k) &#123;</span><br><span class="line">    let ans = [];</span><br><span class="line">    function helper(root,length,k)&#123;</span><br><span class="line">        if(k === 0) return;</span><br><span class="line">        if(length === 0)&#123;</span><br><span class="line">            ans.push(null);</span><br><span class="line">            helper(root,length,k-1);</span><br><span class="line">            return;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">        //要分的个数</span><br><span class="line">        let temp = Math.ceil(length/k);</span><br><span class="line">        let newNode = root;</span><br><span class="line">        let head = newNode;</span><br><span class="line">        let i = 1;</span><br><span class="line">        while(i &lt;= temp - 1)&#123;//剪下来这一段</span><br><span class="line">            root = root.next;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        let next = root.next;</span><br><span class="line">        root.next = null;//直接剪下来就好不需要重新生成</span><br><span class="line">        ans.push(newNode);</span><br><span class="line">        helper(next,length - temp,k-1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //求出链表的长度</span><br><span class="line">    let p = root;</span><br><span class="line">    let length = 0;</span><br><span class="line">    while(p)&#123;</span><br><span class="line">        length++;</span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125; </span><br><span class="line">    helper(root,length,k);</span><br><span class="line">    return ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="10-奇偶链表xx-328"><a href="#10-奇偶链表xx-328" class="headerlink" title="10.奇偶链表xx-328"></a>10.奇偶链表xx-328</h3><p><img src="/img/1590306608115.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var oddEvenList = function(head) &#123;</span><br><span class="line">    if(!head) return head;</span><br><span class="line">    let odd = head;</span><br><span class="line">    let even = head.next;</span><br><span class="line">    let temp = even;</span><br><span class="line">    while(even &amp;&amp; even.next)&#123;</span><br><span class="line">        odd.next = odd.next.next;</span><br><span class="line">        odd = odd.next;</span><br><span class="line">        even.next = even.next.next;</span><br><span class="line">        even = even.next;</span><br><span class="line">    &#125;</span><br><span class="line">    odd.next = temp;//最后连接奇数表和偶数表</span><br><span class="line">    return head;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="11-链表中间结点"><a href="#11-链表中间结点" class="headerlink" title="11.链表中间结点*"></a>11.链表中间结点*</h3><p><img src="/img/2021203-1.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//思路和判断链表是否有环一样：双指针法</span><br><span class="line">var middleNode = function (head) &#123;  //快指针每次两格，慢指针每次一格，快指针到尾，慢指针正好中间</span><br><span class="line">    let slow = head,</span><br><span class="line">        fast = head</span><br><span class="line">    while (fast &amp;&amp; fast.next) &#123;</span><br><span class="line">        slow = slow.next</span><br><span class="line">        fast = fast.next.next</span><br><span class="line">    &#125;</span><br><span class="line">    return slow</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="队列和栈"><a href="#队列和栈" class="headerlink" title="队列和栈"></a>队列和栈</h2><h3 id="1-用栈实现队列x-232"><a href="#1-用栈实现队列x-232" class="headerlink" title="1.用栈实现队列x*-232"></a>1.用栈实现队列x*-232</h3><p><img src="/img/1590404582240.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//都是调用数组方法来实现栈和队列不同的特性，如pop(),push(),shift(),没有peek()</span><br><span class="line">/**</span><br><span class="line"> * Initialize your data structure here.</span><br><span class="line"> */</span><br><span class="line">var MyQueue = function() &#123;</span><br><span class="line">    this.stack1 = [];        //都用this指向**</span><br><span class="line">    this.stack2 = [];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyQueue.prototype.push = function(x) &#123;</span><br><span class="line">    this.stack1.push(x);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyQueue.prototype.pop = function() &#123;</span><br><span class="line">    if(this.stack2.length !== 0) return this.stack2.pop();   //stack2不空，删除并返回栈顶</span><br><span class="line">    while(this.stack1.length !== 0) this.stack2.push(this.stack1.pop());  //栈为空先加入，再返回</span><br><span class="line">    return this.stack2.pop();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyQueue.prototype.peek = function() &#123;</span><br><span class="line">    if(this.stack2.length !== 0) return this.stack2[this.stack2.length - 1];//若stack2有元素则返回最后一个元素</span><br><span class="line">    else return this.stack1[0];//否则直接返回stack1的第一个元素即可</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyQueue.prototype.empty = function() &#123;</span><br><span class="line">    return this.stack1.length === 0 &amp;&amp; this.stack2.length == 0; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>用两个栈，把第一个栈依次出栈到第二个栈实现顺序的改变从而实现先入先出</p>
<h3 id="2-用队列实现栈x-225"><a href="#2-用队列实现栈x-225" class="headerlink" title="2.用队列实现栈x*-225"></a>2.用队列实现栈x*-225</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Initialize your data structure here.</span><br><span class="line"> */</span><br><span class="line">var MyStack = function() &#123;</span><br><span class="line">this.queue1=[];</span><br><span class="line">this.queue2=[];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Push element x onto stack. </span><br><span class="line"> * @param &#123;number&#125; x</span><br><span class="line"> * @return &#123;void&#125;</span><br><span class="line"> */</span><br><span class="line">MyStack.prototype.push = function(x) &#123;</span><br><span class="line">this.queue1.push(x);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Removes the element on top of the stack and returns that element.</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> */</span><br><span class="line">MyStack.prototype.pop = function() &#123;</span><br><span class="line">if(this.queue1.length!=0) return this.queue1.pop();</span><br><span class="line">else return this.queue2.shift(); </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Get the top element.</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> */</span><br><span class="line">MyStack.prototype.top = function() &#123;</span><br><span class="line">if(this.queue1.length!=0) return this.queue1[this.queue1.length-1];</span><br><span class="line">else return this.queue2[0];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Returns whether the stack is empty.</span><br><span class="line"> * @return &#123;boolean&#125;</span><br><span class="line"> */</span><br><span class="line">MyStack.prototype.empty = function() &#123;</span><br><span class="line">return this.queue1.length==0&amp;&amp;this.queue2.length==0</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>入队后把每一个其他值都出队再入队</p>
<h3 id="3-最小栈xx"><a href="#3-最小栈xx" class="headerlink" title="3.最小栈xx*"></a>3.最小栈xx*</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * initialize your data structure here.</span><br><span class="line"> */</span><br><span class="line">var MinStack = function() &#123;</span><br><span class="line">    this.minStack = [];</span><br><span class="line">    this.stack = [];</span><br><span class="line">    this.min = Number.MAX_SAFE_INTEGER;//最大安全值</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/** </span><br><span class="line"> * @param &#123;number&#125; x</span><br><span class="line"> * @return &#123;void&#125;</span><br><span class="line"> */</span><br><span class="line">MinStack.prototype.push = function(x) &#123;</span><br><span class="line">    this.min = Math.min(x,this.min);</span><br><span class="line">    this.minStack.push(this.min);</span><br><span class="line">    this.stack.push(x);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @return &#123;void&#125;</span><br><span class="line"> */</span><br><span class="line">MinStack.prototype.pop = function() &#123;</span><br><span class="line">    this.minStack.pop();</span><br><span class="line">    this.stack.pop();</span><br><span class="line">    let len = this.minStack.length;</span><br><span class="line">    this.min = len !== 0 ? this.minStack[len - 1] : Number.MAX_SAFE_INTEGER;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> */</span><br><span class="line">MinStack.prototype.top = function() &#123;</span><br><span class="line">    return this.stack[this.minStack.length - 1];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> */</span><br><span class="line">MinStack.prototype.getMin = function() &#123;</span><br><span class="line">    return this.min;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>用两个栈去实现，一个栈正常放数，另外一个栈每次push的时候都存放栈中的最小值。pop的时候就更新最小值为minStack的栈顶元素即可，若全都pop了要重置最小值<br>Number.MAX_SAFE_INTEGER代表了最大的安全值</p>
<h3 id="4-有效的括号-20"><a href="#4-有效的括号-20" class="headerlink" title="4.有效的括号-20*"></a>4.有效的括号-20*</h3><p><img src="/img/1590466177068.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var isValid = function (s) &#123;</span><br><span class="line">    if (s.length % 2 === 1) return false</span><br><span class="line">    let stack = []</span><br><span class="line">    for (let i = 0; i &lt; s.length; i++) &#123;</span><br><span class="line">        if (s[i] == &apos;(&apos; || s[i] == &apos;&#123;&apos; || s[i] == &apos;[&apos;) stack.push(s[i])  //字符串可直接s[i]获取元素</span><br><span class="line">        else &#123;</span><br><span class="line">            let newTop = stack[stack.length-1]  //获取栈顶元素，先不出栈</span><br><span class="line">            if(newTop==&apos;&#123;&apos;&amp;&amp;s[i]==&apos;&#125;&apos;||newTop==&apos;(&apos;&amp;&amp;s[i]==&apos;)&apos;||newTop==&apos;[&apos;&amp;&amp;s[i]==&apos;]&apos;)&#123;</span><br><span class="line">                stack.pop()  //如果匹配就出栈</span><br><span class="line">            &#125;else return false //不匹配返回false</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return stack.length==0  //最后栈为空，就是匹配完全，返回真</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="5-滑动窗口最大值"><a href="#5-滑动窗口最大值" class="headerlink" title="5.滑动窗口最大值*"></a>5.滑动窗口最大值*</h3><p><img src="/img/2021124-1.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//不推荐这种</span><br><span class="line">var maxSlidingWindow = function (nums, k) &#123;  //自己的解法，有点复杂,不可取</span><br><span class="line">    if(!nums.length) return []               //此处也可以写成nums.length===0，但不可以写nums===[]，会报</span><br><span class="line">    let ans = []                             //  undefined</span><br><span class="line">    let curr=[]</span><br><span class="line">    for(let i=0;i&lt;nums.length-k+1;i++)&#123;      //此处可以写成i&lt;=nums.length-k</span><br><span class="line">        curr=[]</span><br><span class="line">        for(let j=i;j&lt;k+i;j++)&#123;              //slice方法截取方便</span><br><span class="line">            curr.push(nums[j])</span><br><span class="line">        &#125;</span><br><span class="line">        curr.sort((a,b)=&gt;&#123;                   //Math.max获取最大值方便</span><br><span class="line">            return a-b</span><br><span class="line">        &#125;)</span><br><span class="line">        ans.push(curr[k-1])</span><br><span class="line">    &#125;</span><br><span class="line">    return ans</span><br><span class="line">&#125;;</span><br><span class="line">******************************************************************************</span><br><span class="line">//通过slice函数截取数组部分值，用math.max取最大值，值得借鉴</span><br><span class="line">var maxSlidingWindow = function (nums, k) &#123;</span><br><span class="line">    if (!nums.length) return []</span><br><span class="line">    let res = []</span><br><span class="line">    for (let i = 0; i &lt;= nums.length - k; i++) &#123;</span><br><span class="line">        res.push(Math.max(...nums.slice(i, k + i)))</span><br><span class="line">    &#125;</span><br><span class="line">    return res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6-每日温度x"><a href="#6-每日温度x" class="headerlink" title="6.每日温度x"></a>6.每日温度x</h3><p><img src="/img/1590471353778.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">常规方法：双层循环</span><br><span class="line">var dailyTemperatures = function (T) &#123;</span><br><span class="line">    let result = new Array(T.length).fill(0);//注意给一个初始化解决有一些为0的问题</span><br><span class="line">    for (let i = 0; i &lt; T.length; i++) &#123;</span><br><span class="line">        let current = T[i];</span><br><span class="line">        for (let j = i + 1; j &lt; T.length; j++) &#123;</span><br><span class="line">            if (T[j] &gt; current) &#123;</span><br><span class="line">                result[i] = j - i;</span><br><span class="line">                break;  //一定要结束循环，才能取到第一个大于current的数</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;;</span><br><span class="line">*****************************************************************************************</span><br><span class="line">栈方法：</span><br><span class="line">var dailyTemperatures = function (T) &#123;</span><br><span class="line">    let stack = [];</span><br><span class="line">    let ans = new Array(T.length).fill(0);//注意给一个初始化解决有一些为0的问题</span><br><span class="line">    for(let i=0;i&lt;T.length;i++)&#123;</span><br><span class="line">        //使用peek()无效，peek需要自己写方法实现</span><br><span class="line">        while (stack.length !== 0 &amp;&amp; T[stack[stack.length-1]] &lt; T[i]) &#123;</span><br><span class="line">            let idx = stack.pop();  //后一位&gt;前一位，出栈，直到不大于时，后一位进栈</span><br><span class="line">            ans[idx] = i - idx;  //下标相减</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(i);  //栈中存入下标***注意是下标</span><br><span class="line">    &#125; </span><br><span class="line">    return ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>用一个栈去存储T的下标维持一个递增栈<br>若比栈顶的元素对应的温度大就要让它出栈，并且序号之差就是相隔的距离</p>
<h3 id="7-下一个更大元素-IIx"><a href="#7-下一个更大元素-IIx" class="headerlink" title="7.下一个更大元素 IIx"></a>7.下一个更大元素 IIx</h3><p><img src="/img/1590547872819.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var nextGreaterElements = function (nums) &#123;</span><br><span class="line">    let stack = [];</span><br><span class="line">    let len = nums.length;</span><br><span class="line">    let ans = new Array(len).fill(-1);</span><br><span class="line">    for (let i = 0; i &lt; 2 * len; i++) &#123;**********</span><br><span class="line">        let index = i % len;//注意要取余数*********</span><br><span class="line">        while (stack.length !== 0 &amp;&amp; nums[stack[stack.length - 1]] &lt; nums[index]) &#123; //stack存储下标值</span><br><span class="line">            let idx = stack.pop();</span><br><span class="line">            ans[idx] = nums[index];</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(index);</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>思路和上一个题相似，就是要遍历数组长度2倍，下标取余即可</p>
<h3 id="8-逆波兰表达式求值"><a href="#8-逆波兰表达式求值" class="headerlink" title="8.逆波兰表达式求值"></a>8.逆波兰表达式求值</h3><p><img src="/img/1590555737460.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//逆波兰表达式是后缀表达式，本题要将其转成中缀表达式</span><br><span class="line">var evalRPN = function (tokens) &#123;</span><br><span class="line">    let stack = [];</span><br><span class="line">    for (let i of tokens) &#123;</span><br><span class="line">            switch (i) &#123;</span><br><span class="line">                case &quot;+&quot;:</span><br><span class="line">                stack.push(stack.pop() + stack.pop());</span><br><span class="line">                break;</span><br><span class="line">                case &apos;-&apos;:</span><br><span class="line">                let sub = stack.pop();</span><br><span class="line">                stack.push(stack.pop() - sub);</span><br><span class="line">                break;</span><br><span class="line">                case &apos;/&apos;:</span><br><span class="line">                let divider = stack.pop();</span><br><span class="line">                stack.push(parseInt(stack.pop() / divider,10));  //10 代表10进制,最好用Math.floor()</span><br><span class="line">                break;</span><br><span class="line">                case &apos;*&apos;:</span><br><span class="line">                stack.push(stack.pop() * stack.pop());</span><br><span class="line">                break;</span><br><span class="line">                default:</span><br><span class="line">                stack.push(parseInt(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    return stack.pop();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ol>
<li>switch的语法</li>
<li>注意除法和减法的顺序</li>
<li>JS中floor会向下保留整数，比如-1.2变成-2，ceil向上保留整数比如1.2-2</li>
<li>如果只是单纯保留整数部分就直接用parseInt即可parseInt(数字或字符串，进制)，注意默认不为10进制**</li>
</ol>
<h3 id="9-长度最小的子数组"><a href="#9-长度最小的子数组" class="headerlink" title="9.长度最小的子数组*"></a>9.长度最小的子数组*</h3><p><img src="/img/2021128-1.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">队列相加（也叫滑动窗口法），思想：逐个加入队列，直到满足条件，再逐个剔除，直到不满足条件时，再逐个往里加。</span><br><span class="line">var minSubArrayLen = function (s, nums) &#123;  //使用两个指针，长度取指针差值，再求最小</span><br><span class="line">    let first = 0, end = 0, sum = 0, min = nums.length + 1  //min不存在情况</span><br><span class="line">    while (end &lt; nums.length) &#123;</span><br><span class="line">        sum += nums[end++]  //进入队列的加和</span><br><span class="line">        while (sum &gt;= s) &#123;  //由题意：是 &gt;=</span><br><span class="line">            min = Math.min(min, end - first)</span><br><span class="line">            sum -= nums[first++]  //大于s后，出队列找最短大于s值</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return min == (nums.length + 1) ? 0 : min</span><br><span class="line">&#125;;  //O(n)、O(1)使用指针不必额外数组空间</span><br></pre></td></tr></table></figure>

<h3 id="10-无重复字符的最长子串"><a href="#10-无重复字符的最长子串" class="headerlink" title="10.无重复字符的最长子串**"></a>10.无重复字符的最长子串**</h3><p><img src="/img/2021201-1.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//滑动窗口</span><br><span class="line">var lengthOfLongestSubstring = function (s) &#123;</span><br><span class="line">    let ans = 0</span><br><span class="line">    let arr = []</span><br><span class="line">    for (let i = 0; i &lt; s.length; i++) &#123;</span><br><span class="line">        let index = arr.indexOf(s[i])</span><br><span class="line">        if (index !== -1) &#123; //找到相同元素，删除重复元素及之前的元素</span><br><span class="line">            arr.splice(0, index + 1)</span><br><span class="line">        &#125;</span><br><span class="line">        arr.push(s[i])  //要在删除相同元素的操作后推进</span><br><span class="line">        ans = Math.max(ans, arr.length)</span><br><span class="line">    &#125;</span><br><span class="line">    return ans</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="11-螺旋矩阵II"><a href="#11-螺旋矩阵II" class="headerlink" title="11.螺旋矩阵II"></a>11.螺旋矩阵II</h3><p><img src="/img/20210312_04.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var generateMatrix = function (n) &#123;</span><br><span class="line">    let res=new Array(n);  //定义二维数组</span><br><span class="line">    for(let i=0;i&lt;n;i++)&#123;</span><br><span class="line">        res[i]=new Array(n);</span><br><span class="line">    &#125;</span><br><span class="line">    let startx = 0, starty = 0; // 定义每循环一个圈的起始位置</span><br><span class="line">    let loop = Math.floor(n / 2); // 每个圈循环几次，例如n为奇数3，那么loop = 1 只是循环一圈，矩阵中间的值需要单独处理</span><br><span class="line">    let mid = Math.floor(n / 2); // 矩阵中间的位置，例如：n为3， 中间的位置就是(1，1)，n为5，中间位置为(2, 2)</span><br><span class="line">    let count = 1; // 用来给矩阵中每一个空格赋值</span><br><span class="line">    let offset = 1; // 需要控制每一条边遍历的长度，第一圈最右的1个不遍历，左闭右开。</span><br><span class="line">    let i, j;</span><br><span class="line">    while (loop&gt;0) &#123;</span><br><span class="line">        loop--;</span><br><span class="line">        i = startx;</span><br><span class="line">        j = starty;</span><br><span class="line"></span><br><span class="line">        // 下面开始的四个for就是模拟转了一圈</span><br><span class="line">        // 模拟填充上行从左到右(左闭右开)</span><br><span class="line">        for (j = starty; j &lt; starty + n - offset; j++) &#123;</span><br><span class="line">            res[startx][j] = count++;</span><br><span class="line">        &#125;</span><br><span class="line">        // 模拟填充右列从上到下(左闭右开)</span><br><span class="line">        for (i = startx; i &lt; startx + n - offset; i++) &#123;</span><br><span class="line">            res[i][j] = count++;</span><br><span class="line">        &#125;</span><br><span class="line">        // 模拟填充下行从右到左(左闭右开)</span><br><span class="line">        for (; j &gt; starty; j--) &#123;</span><br><span class="line">            res[i][j] = count++;</span><br><span class="line">        &#125;</span><br><span class="line">        // 模拟填充左列从下到上(左闭右开)</span><br><span class="line">        for (; i &gt; startx; i--) &#123;</span><br><span class="line">            res[i][j] = count++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 第二圈开始的时候，起始位置要各自加1， 例如：第一圈起始位置是(0, 0)，第二圈起始位置是(1, 1)</span><br><span class="line">        startx++;</span><br><span class="line">        starty++;</span><br><span class="line"></span><br><span class="line">        // offset 控制每一圈里每一条边遍历的长度</span><br><span class="line">        offset += 2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 如果n为奇数的话，需要单独给矩阵最中间的位置赋值</span><br><span class="line">    if (n % 2==1) &#123;</span><br><span class="line">        res[mid][mid] = count;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><h3 id="1-数组中两个数的和为给定值"><a href="#1-数组中两个数的和为给定值" class="headerlink" title="1.数组中两个数的和为给定值*"></a>1.数组中两个数的和为给定值*</h3><p><img src="/img/1590563829414.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var twoSum = function (nums, target) &#123;</span><br><span class="line">    let map = new Map();</span><br><span class="line">    for (let i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">        let temp = map.get(target - nums[i]);</span><br><span class="line">        if (temp !== undefined &amp;&amp; temp != i ) &#123;</span><br><span class="line">            return new Array(temp, i);</span><br><span class="line">        &#125;</span><br><span class="line">        map.set(nums[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">注：看双指针第一题</span><br></pre></td></tr></table></figure>

<h4 id="1-1三数之和"><a href="#1-1三数之和" class="headerlink" title="1.1三数之和**"></a>1.1三数之和**</h4><p><img src="/img/2021124-2.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//双指针：定住一个，左右指针遍历，再求和判断是否满足条件</span><br><span class="line">var threeSum = function(nums) &#123;</span><br><span class="line">    let ans = [];</span><br><span class="line">    if(nums.length &lt; 3) return ans;</span><br><span class="line">    nums.sort((a, b) =&gt; a - b); // 排序</span><br><span class="line">    const len = nums.length;</span><br><span class="line">    for (let i = 0; i &lt; len ; i++) &#123;   //定住的元素就是for每次循环的值</span><br><span class="line">        if(nums[i] &gt; 0) break; // 如果当前数字大于0，则三数之和一定大于0，所以结束循环</span><br><span class="line">        if(i &gt; 0 &amp;&amp; nums[i] == nums[i-1]) continue;//将定住的元素去重，满足三个元素对数组重复元素仅使用一次</span><br><span class="line">        let L = i+1;</span><br><span class="line">        let R = len-1;</span><br><span class="line">        while(L &lt; R)&#123;</span><br><span class="line">            const sum = nums[i] + nums[L] + nums[R];</span><br><span class="line">            if(sum == 0)&#123;</span><br><span class="line">                ans.push([nums[i],nums[L],nums[R]]);//推入数组形式注意([])</span><br><span class="line">                while (L&lt;R &amp;&amp; nums[L] == nums[L+1]) L++; // 左指针元素去重，遍历过的就不遍历了</span><br><span class="line">                while (L&lt;R &amp;&amp; nums[R] == nums[R-1]) R--; // 右指针去重，满足题意：避免重复三元组</span><br><span class="line">                L++;</span><br><span class="line">                R--;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (sum &lt; 0) L++;</span><br><span class="line">            else if (sum &gt; 0) R--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;        </span><br><span class="line">    return ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="1-2四数之和"><a href="#1-2四数之和" class="headerlink" title="1.2四数之和"></a>1.2四数之和</h4><p><img src="/img/20210316_4png.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var fourSum = function (nums, target) &#123;   //就是比三数多一层for循环和去重，依次5数之和，6数之和都能求</span><br><span class="line">    let ans = [];</span><br><span class="line">    if (nums.length &lt; 4) return ans;</span><br><span class="line">    nums.sort((a, b) =&gt; a - b); // 排序</span><br><span class="line">    const len = nums.length;</span><br><span class="line">    for (let i = 0; i &lt; len; i++) &#123;</span><br><span class="line">        if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) continue;  //定住两个元素，遍历左右指针</span><br><span class="line">        for (let k = i + 1; k &lt; len; k++) &#123;</span><br><span class="line">            if (k &gt; i + 1 &amp;&amp; nums[k] == nums[k - 1]) continue;</span><br><span class="line">            let L = k + 1;</span><br><span class="line">            let R = len - 1;</span><br><span class="line">            while (L &lt; R) &#123;</span><br><span class="line">                const sum = nums[i] + nums[k] + nums[L] + nums[R];</span><br><span class="line">                if (sum == target) &#123;</span><br><span class="line">                    ans.push([nums[i], nums[k], nums[L], nums[R]]);//推入数组形式注意([])</span><br><span class="line">                    while (L &lt; R &amp;&amp; nums[L] == nums[L + 1]) L++; // 左指针元素去重</span><br><span class="line">                    while (L &lt; R &amp;&amp; nums[R] == nums[R - 1]) R--; // 右指针去重，满足题意：避免重复三元组</span><br><span class="line">                    L++;</span><br><span class="line">                    R--;</span><br><span class="line">                &#125;</span><br><span class="line">                else if (sum &lt; target) L++;</span><br><span class="line">                else if (sum &gt; target) R--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="1-3四数之和II"><a href="#1-3四数之和II" class="headerlink" title="1.3四数之和II"></a>1.3四数之和II</h4><p><img src="/img/20210316_3.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var fourSumCount = function (A, B, C, D) &#123;</span><br><span class="line">    let map = new Map();</span><br><span class="line">    let res = 0;</span><br><span class="line">    for (let i = 0; i &lt; A.length; i++) &#123;   //hash存两数和，再对比两数和</span><br><span class="line">        for (let j = 0; j &lt; B.length; j++) &#123;</span><br><span class="line">            let sum=A[i]+B[j];</span><br><span class="line">            if(map.has(sum)) map.set(sum,map.get(sum)+1);</span><br><span class="line">            else map.set(sum,1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (let i = 0; i &lt; C.length; i++) &#123;</span><br><span class="line">        for (let j = 0; j &lt; D.length; j++) &#123;</span><br><span class="line">            let sum=-(C[i]+D[j]);</span><br><span class="line">            if(map.has(sum)) res+=map.get(sum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;;  //O(n^2)</span><br></pre></td></tr></table></figure>

<h3 id="2-判断数组是否含有重复元素"><a href="#2-判断数组是否含有重复元素" class="headerlink" title="2.判断数组是否含有重复元素"></a>2.判断数组是否含有重复元素</h3><p><img src="/img/1590564032386.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var containsDuplicate = function(nums) &#123;</span><br><span class="line">    let len = nums.length;</span><br><span class="line">    let map = new Map();</span><br><span class="line">    for(let i = 0;i &lt; len;i++)&#123;</span><br><span class="line">        if(map.has(nums[i])) return true;</span><br><span class="line">        else map.set(nums[i],i);</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="3-数组中出现次数超一半数字"><a href="#3-数组中出现次数超一半数字" class="headerlink" title="3.数组中出现次数超一半数字*"></a>3.数组中出现次数超一半数字*</h3><p><img src="/img/2021121(2).png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var majorityElement = function (nums) &#123;</span><br><span class="line">    let map = new Map()</span><br><span class="line">    for (let item of nums) &#123;</span><br><span class="line">        if (map.has(item)) &#123;</span><br><span class="line">            map.set(item, map.get(item) + 1)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            map.set(item, 1)</span><br><span class="line">        &#125;</span><br><span class="line">        if (map.get(item) &gt; nums.length / 2) &#123;</span><br><span class="line">            return item</span><br><span class="line">            break</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="4-两个数组的交集"><a href="#4-两个数组的交集" class="headerlink" title="4.两个数组的交集*"></a>4.两个数组的交集*</h3><p><img src="/img/2021121(3).png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var intersection = function(nums1, nums2) &#123;</span><br><span class="line">    let numsOne=[...new Set(nums1)]  //数组去重</span><br><span class="line">    let numsTwo=[...new Set(nums2)]</span><br><span class="line">    let res=[]</span><br><span class="line">    let map=new Map()  //hash表存储，只有这样定义才能使用map.get/map.set等方法</span><br><span class="line">    for(let i=0;i&lt;numsOne.length;i++)&#123;  //数组一存入hash表</span><br><span class="line">        let item=numsOne[i]</span><br><span class="line">        if(map.has(item))&#123;   //这步没必要判断</span><br><span class="line">            map.set(item,map.get(item)+1)</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            map.set(item,1)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(let i=0;i&lt;numsTwo.length;i++)&#123;  //数组二存入hash表时判断表中是否已有该元素。</span><br><span class="line">        let item=numsTwo[i]</span><br><span class="line">        if(map.has(item))&#123;</span><br><span class="line">           res.push(item)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res</span><br><span class="line">&#125;;</span><br><span class="line">//简化版</span><br><span class="line">var intersection = function(nums1, nums2) &#123;</span><br><span class="line">    let numsOne=[...new Set(nums1)];</span><br><span class="line">    let numsTwo=[...new Set(nums2)];</span><br><span class="line">    let res=[];</span><br><span class="line">    let map=new Map();</span><br><span class="line">    for(let i of numsOne)&#123;</span><br><span class="line">        map.set(i,1)</span><br><span class="line">    &#125;</span><br><span class="line">    for(let i of numsTwo)&#123;</span><br><span class="line">        if(map.has(i))&#123;</span><br><span class="line">            res.push(i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-最长和谐子序列xx-594"><a href="#5-最长和谐子序列xx-594" class="headerlink" title="5. 最长和谐子序列xx-594"></a>5. 最长和谐子序列xx-594</h3><p><img src="/img/1590566647003.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var findLHS = function(nums) &#123;   //此处使用数组和hash表没区别，只有处理字符串，有26个字母限制时，使用数组比                                  //hash表省空间</span><br><span class="line">    let map = [];</span><br><span class="line">    for(num of nums)&#123;</span><br><span class="line">        map[num] = map[num] === undefined ? 1 : map[num] + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    let longest = 0;</span><br><span class="line">    for(num of nums)&#123;</span><br><span class="line">        longest = Math.max( longest , (map[num] + map[num+1]) || 0);//注意这个地方map[num + 1]可能为undefined所以要||0</span><br><span class="line">    &#125;</span><br><span class="line">    return longest;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注意看题目这个序列不一定连续</p>
<h3 id="6-最长连续序列xx"><a href="#6-最长连续序列xx" class="headerlink" title="6. 最长连续序列xx"></a>6. 最长连续序列xx</h3><p><img src="/img/1592227063281.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var longestConsecutive = function(nums) &#123;</span><br><span class="line">    //构建哈希表</span><br><span class="line">    let map = new Map();</span><br><span class="line">    for(num of nums)&#123;</span><br><span class="line">        let count = map.get(num);</span><br><span class="line">        if(count === undefined)&#123;</span><br><span class="line">            map.set(num,1);//注意是1</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            map.set(num,count + 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    let longest = 0;</span><br><span class="line">    //再遍历一次找最长的长度</span><br><span class="line">    for(num of nums)&#123;</span><br><span class="line">        //只有当这个值的前一个值没有出现时才可能是最长序列的开头，也可以先排序，但不推荐，时间复杂度太高</span><br><span class="line">        if(map.get(num - 1) === undefined)&#123;</span><br><span class="line">        let count = 0;</span><br><span class="line">        while(map.get(num) !== undefined)&#123;//不为空才执行</span><br><span class="line">            count++;</span><br><span class="line">            num++;  //精髓：每一趟for循环时查找最远距离</span><br><span class="line">        &#125;</span><br><span class="line">        longest = Math.max(count,longest); //每次遍历完一段count就比较一次</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return longest;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注意是最长的连续序列要一直递增+1才可以</p>
<h3 id="7-快乐数"><a href="#7-快乐数" class="headerlink" title="7.快乐数*"></a>7.快乐数*</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//同双指针10，就是找重复元素，hash也行，双指针也行</span><br><span class="line">var isHappy = function (n) &#123;</span><br><span class="line">    let map = new Map();</span><br><span class="line">    let sum;</span><br><span class="line">    n = n + &apos;&apos;;</span><br><span class="line">    while (sum != 1) &#123;</span><br><span class="line">        sum = 0;</span><br><span class="line">        for (let i = 0; i &lt; n.length; i++) &#123;</span><br><span class="line">            sum += n[i] * n[i];</span><br><span class="line">        &#125;</span><br><span class="line">        n=sum+&apos;&apos;;</span><br><span class="line">        if(map.has(sum)) return false;</span><br><span class="line">        map.set(sum,1);</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="1-数组扁平化，去重，排序"><a href="#1-数组扁平化，去重，排序" class="headerlink" title="1.数组扁平化，去重，排序"></a>1.数组扁平化，去重，排序</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var arr = [ [1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [12, 13, [14] ] ] ], 10]</span><br><span class="line">// 扁平化(多维降到一维数组)</span><br><span class="line">const flat = arr.flat(Infinity);</span><br><span class="line"></span><br><span class="line">// 去重</span><br><span class="line">const unique = (array) =&gt; Array.from(new Set(array))  //new Set()后是类数组，如&#123;1,2,2,3&#125;，可执行数组方法</span><br><span class="line">                                                      //Array.from将这种特殊的对象-类数组转成数组。</span><br><span class="line">// 排序</span><br><span class="line">const sort = (array) =&gt; array.sort((a, b) =&gt; a-b)</span><br><span class="line">return sort</span><br><span class="line"></span><br><span class="line">补充：flat() 方法对node版本有要求，至少需要12.0以上，通过array.some() + concat来实现这个flat()，这个对node版本的限制比较低</span><br><span class="line">while(arr.some(Array.isArray))&#123;</span><br><span class="line">    arr = [].concat(...arr)</span><br><span class="line">  &#125; //console.log(arr);</span><br></pre></td></tr></table></figure>

<h3 id="2-只出现一次数字"><a href="#2-只出现一次数字" class="headerlink" title="2.只出现一次数字"></a>2.只出现一次数字</h3><p><img src="/img/2021123.png" alt></p>
<p>注：不使用额外空间，所以不用map</p>
<p><strong>我们将循环的数组元素存入map中，再找某元素时，无需遍历map，只需再循环一遍数组，用map.get处理，相当于遍历了map</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var singleNumber = function(nums) &#123;  //只有一个单数，其余两两出现，找出不连续的即可，符合题意</span><br><span class="line">    nums = nums.sort((a, b) =&gt; &#123;  </span><br><span class="line">        return a-b</span><br><span class="line">    &#125;)</span><br><span class="line">    for (let i = 0; i&lt;nums.length;i+=2)&#123;</span><br><span class="line">        if (nums[i] != nums[i+1]) &#123;</span><br><span class="line">            return nums[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">//也可以使用两个指针，每次走两步，若两指针不相等时，返回慢指针所指的值</span><br><span class="line">****************************************************************************************</span><br><span class="line">map方法：好用但不符合题意</span><br><span class="line">var singleNumber = function (nums) &#123;</span><br><span class="line">    let map = new Map()</span><br><span class="line">    for(let i=0;i&lt;nums.length;i++)&#123;</span><br><span class="line">        let item=nums[i]</span><br><span class="line">        if(map.has(item))&#123;</span><br><span class="line">            map.set(item,map.get(item)+1)</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            map.set(item,1)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(let item of nums)&#123;</span><br><span class="line">        if(map.get(item)===1)&#123;</span><br><span class="line">            return item</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-合并区间"><a href="#3-合并区间" class="headerlink" title="3.合并区间*"></a>3.合并区间*</h3><p><img src="/img/2021130-2.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var merge = function (intervals) &#123;</span><br><span class="line">    if (!intervals) return [];</span><br><span class="line">    intervals.sort((a,b)=&gt; a[0]-b[0]); //按左侧,各自首部排序</span><br><span class="line">    let ans = [intervals[0]];  //第一项赋值作为初始化</span><br><span class="line">    for (let i = 1; i &lt; intervals.length; i++) &#123; // i=1开始，第二项</span><br><span class="line">        if (ans[ans.length - 1][1] &gt;= intervals[i][0]);  //第一项尾部&gt;第二项首部时，有交集</span><br><span class="line">          ans[ans.length - 1][1] = Math.max(ans[ans.length - 1][1], intervals[i][1])//第1尾部比第2尾部</span><br><span class="line">        else ans.push(intervals[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;;</span><br><span class="line">//时间复杂度：O(nlogn)，n = intervals.length。arr.sort() 使用快速排序的平均时间复杂度为 O(nlogn) 。</span><br><span class="line">//空间复杂度：O(n)，n = intervals.length。输出数组 res ，极端情况下包含数组 intervals 中所有元素。</span><br></pre></td></tr></table></figure>

<h3 id="4-有效三角形个数"><a href="#4-有效三角形个数" class="headerlink" title="4.有效三角形个数*"></a>4.有效三角形个数*</h3><p><img src="/img/2021203-2.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var triangleNumber = function (nums) &#123;</span><br><span class="line">    if (nums.length &lt; 3) return 0;</span><br><span class="line">    nums.sort((a, b) =&gt; a - b);  //递增数组,写&#123;&#125;就得写return，不写&#123;&#125;不写return</span><br><span class="line">    let len = nums.length;</span><br><span class="line">    let count = 0;</span><br><span class="line">    for (let i = len - 1; i &gt; 1; i--) &#123;//从后往前，固定最长边，若nums[L]+nums[R]&gt;nums[i]，那么L后皆满足</span><br><span class="line">        let L = 0;</span><br><span class="line">        let R = i - 1;</span><br><span class="line">        while (L &lt; R) &#123;</span><br><span class="line">            if ((nums[L] + nums[R]) &gt; nums[i]) &#123;  //只需判断两数之和&gt;第三个数即可</span><br><span class="line">                count += R - L;</span><br><span class="line">                R--;</span><br><span class="line">            &#125; else L++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符串多用数组表映射、转ASCII值、字符串原生方法、正则表达式</p>
<h3 id="1-有效的字母异位词x"><a href="#1-有效的字母异位词x" class="headerlink" title="1.有效的字母异位词x*"></a>1.有效的字母异位词x*</h3><p><img src="/img/1590635482200.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//因为题目所只有小写字母，考虑长度26位数组更好，使用map的空间消耗要比数组大一些的，因为map要维护红黑树或者哈希表，而且还要做哈希函数。所以数组更加简单直接有效！</span><br><span class="line">var isAnagram = function(s, t) &#123;</span><br><span class="line">    let maps = new  Array(26).fill(0);</span><br><span class="line">    let mapt = new  Array(26).fill(0);</span><br><span class="line">    for(let i of s) maps[i.charCodeAt() - &apos;a&apos;.charCodeAt()]++;//注意js中字符串的相减不会自动转换为ascii码</span><br><span class="line">    for(let i of t) mapt[i.charCodeAt() - &apos;a&apos;.charCodeAt()]++;</span><br><span class="line">    for(let i = 0;i &lt; 26;i++)&#123;</span><br><span class="line">        if(maps[i] !== mapt[i]) return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;;</span><br><span class="line">****************************************************************************************</span><br><span class="line">注：LeetCode-383赎金信问题，也是数组方法更优化</span><br><span class="line">var canConstruct = function (ransomNote, magazine) &#123;</span><br><span class="line">    let arr = new Array(26).fill(0);</span><br><span class="line">    for (let i of magazine) &#123;</span><br><span class="line">        arr[i.charCodeAt() - &apos;a&apos;.charCodeAt()]++;</span><br><span class="line">    &#125;</span><br><span class="line">    for (let i of ransomNote) &#123;</span><br><span class="line">        arr[i.charCodeAt() - &apos;a&apos;.charCodeAt()]--;</span><br><span class="line">        if (arr[i.charCodeAt() - &apos;a&apos;.charCodeAt()] &lt; 0) return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="字符串和数字的相加减总结"><a href="#字符串和数字的相加减总结" class="headerlink" title="字符串和数字的相加减总结"></a>字符串和数字的相加减总结</h4><ol>
<li>字符串+字符串<br>始终是字符串的拼接</li>
<li>数字字符串 */- 数字字符串<br>会把字符串强制转换为Number进行计算，number≠ASCII<br>如：’123.123’ - ‘1’ = Number(‘123.123’) - Number(‘1’) = 122.123</li>
</ol>
<p><strong>但是Number只会转换成功那些符合数字规范的字符串，像是’123as’就会转换成NaN,最后的结果也只会是NaN</strong></p>
<ol start="3">
<li>字符串 + 数字<br>同样也是字符串的拼接</li>
<li>字符串 */- 数字<br>同样将字符串用Number()强制转换再进行运算</li>
<li>字符串和整数间的比较</li>
</ol>
<p>字符串与整型数字： console.log(‘21’&gt;3) –21&gt;3 true   将字符串数字转化为对应整型数值,再进行数值的比较</p>
<p>字符串之间比较：比较ascll码值 console.log(‘21’&gt;’3’) –’21’&gt;’3’ false</p>
<h4 id="parseInt-和-Number-的区别"><a href="#parseInt-和-Number-的区别" class="headerlink" title="parseInt() 和 Number()的区别"></a>parseInt() 和 Number()的区别</h4><p>parseInt(数字或者字符串,<strong>基于多少进制转换*)</strong>一般为10，默认不是10<br>parseInt()会转换字符串开头首部数字部分,也会保留浮点数的整数部分，不向上或者向下取整<br>如：123asd =&gt; 123, asd123 =&gt; NaN,‘’123.123‘ =&gt; 123, 123.12 =&gt; 123<br>Number()会强制转换其他类型为数字</p>
<h4 id="所有类型的相加相减总结"><a href="#所有类型的相加相减总结" class="headerlink" title="所有类型的相加相减总结"></a>所有类型的相加相减总结</h4><ol>
<li>所有类型和字符串相加都会强制转换为字符串再拼接<br>‘123’ + 1 = ‘123’ + String(1) = ‘1231’<br>‘123’ + NaN = ‘123NaN’<br>‘123’ + undefined = ‘123undefined’</li>
<li>其他的遇到再总结吧</li>
</ol>
<h3 id="2-最长回文串"><a href="#2-最长回文串" class="headerlink" title="2.最长回文串*"></a>2.最长回文串*</h3><p><img src="/img/1590672019416.png" alt="Alt text"><br>注意只是用这些数字，并没有顺序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var longestPalindrome = function (s) &#123;</span><br><span class="line">    let maps = new Array(58).fill(0); //ASCII值是A-65，z-122，差了58位</span><br><span class="line">    for (i of s) maps[i.charCodeAt() - &apos;A&apos;.charCodeAt()]++; //maps数组填充0</span><br><span class="line">    let count = 0;                   //计算总回文长度</span><br><span class="line">    let flag = false;                 //对于回文中间字母仅取一次，一定要这么写</span><br><span class="line">    for (i of maps) &#123;</span><br><span class="line">        if (i % 2 == 1) &#123;            //i为奇数时</span><br><span class="line">            if (flag == false) &#123;</span><br><span class="line">                flag = true;          //关闭开关</span><br><span class="line">                count++;              //计数加一</span><br><span class="line">            &#125;</span><br><span class="line">            i--;                      //关键点：*i代表字符个数*，若i=1,i--为0，i=3,i--为2，这2个也可以加上</span><br><span class="line">        &#125;</span><br><span class="line">        count += i;                   //计算总的长度</span><br><span class="line">    &#125;</span><br><span class="line">    return count;</span><br><span class="line">&#125;;</span><br><span class="line">//注：不可仅计算偶数个数+1，有时可能没有多余字符，如[b,b]</span><br></pre></td></tr></table></figure>

<p>注意不需要注意顺序，最长的个数就是所有值的偶数部分或者如果有奇数的话就+1</p>
<h3 id="3-同构字符串-205"><a href="#3-同构字符串-205" class="headerlink" title="3.同构字符串-205"></a>3.同构字符串-205</h3><p><img src="/img/1590673502524.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var isIsomorphic = function(s, t) &#123;</span><br><span class="line">    let maps = new Array(123).fill(-1);   //z为122</span><br><span class="line">    let mapt = new Array(123).fill(-1);</span><br><span class="line">    for(let i = 0;i &lt; s.length;i++)&#123;</span><br><span class="line">        let temps = s[i].charCodeAt();</span><br><span class="line">        let tempt = t[i].charCodeAt();</span><br><span class="line">        if(maps[temps] != mapt[tempt]) return false;</span><br><span class="line">        maps[temps] = i;</span><br><span class="line">        mapt[tempt] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>用一个map存放每一个值上次出现的位置来判断值的位置相等不相等即可</p>
<h3 id="4-回文子串xxx"><a href="#4-回文子串xxx" class="headerlink" title="4.回文子串xxx"></a>4.回文子串xxx</h3><p><img src="/img/1590726518373.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var countSubstrings = function(s) &#123;</span><br><span class="line">    function extendSubstrings(s,start,end)&#123;</span><br><span class="line">        while(start &gt;= 0 &amp;&amp; end &lt; s.length &amp;&amp; s[start] === s[end])&#123;</span><br><span class="line">            ans++;</span><br><span class="line">            start--;  //start左移要--</span><br><span class="line">            end++;  //end右移要++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    let ans = 0;</span><br><span class="line">    for(let i = 0;i &lt; s.length;i++)&#123;</span><br><span class="line">        extendSubstrings(s,i,i);  //找拥有奇数个元素的个数，1个a的个数 + 3个a的个数 + 5个a的个数...</span><br><span class="line">        extendSubstrings(s,i,i+1); //偶数个a的个数，2个a的个数+4个a的个数...</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>以每一个元素为中心（奇数）或者是<strong>以每一个元素和后一个元素一起</strong>（偶数）为中心向两侧扩展<br>可以使用<strong>马拉车算法对这个算法进行优化，使时间复杂度降低到O(2n)即(n)的水平</strong></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&mid=2247485998&idx=1&sn=ecccf562324dac313a23964325145c78&chksm=fa0e65afcd79ecb9058babb2310f019e0ed5e5822503cce6a0d734d4fe2306b696d706f0bad8&scene=21#wechat_redirect" target="_blank" rel="noopener">马拉车算法详解</a></p>
<h3 id="5-回文数x"><a href="#5-回文数x" class="headerlink" title="5.回文数x"></a>5.回文数x</h3><p>题目要求不能转换为字符串进行解决<br><img src="/img/1590731832438.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var isPalindrome = function(x) &#123;</span><br><span class="line">     var str=x.toString();//转字符串</span><br><span class="line">     if((str.split(&apos;&apos;).reverse().join(&apos;&apos;))===str)&#123;//分割+翻转+组合</span><br><span class="line">         return true;</span><br><span class="line">     &#125;else&#123;</span><br><span class="line">         return false;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br><span class="line">***********************************************************************************************</span><br><span class="line">var isPalindrome = function (x) &#123;    //不转字符串，纯数学运算</span><br><span class="line">    if (x &lt; 0 || (x % 10 == 0 &amp;&amp; x != 0)) return false;  //负数、结尾==0都不是回文串</span><br><span class="line">    let revertedNumber = 0;</span><br><span class="line">    while (x &gt; revertedNumber) &#123;   //前一半小于，等于后一半时结束循环</span><br><span class="line">        revertedNumber = x % 10 + revertedNumber * 10;   //翻转后一半的数字</span><br><span class="line">        x = Math.floor(x / 10);</span><br><span class="line">    &#125;</span><br><span class="line">    return x == revertedNumber || x == Math.floor(revertedNumber / 10);  //奇数个时可/10来消除影响</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6-计数二进制子串xxx"><a href="#6-计数二进制子串xxx" class="headerlink" title="6.计数二进制子串xxx"></a>6.计数二进制子串xxx</h3><p><img src="/img/1590737944236.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var countBinarySubstrings = function (s) &#123;</span><br><span class="line">    let pre = 0;   //用变量pre承接前一组0/1的个数</span><br><span class="line">    let cur = 1;</span><br><span class="line">    let ans = 0;</span><br><span class="line">    for (let i = 1; i &lt; s.length; i++) &#123;</span><br><span class="line">        if (s[i] === s[i - 1]) cur++;</span><br><span class="line">        else &#123;</span><br><span class="line">            ans += Math.min(pre, cur);</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans += Math.min(pre, cur);//注意最后要再加一次</span><br><span class="line">    return ans;</span><br><span class="line">&#125;;    // O(n)/O(1)</span><br><span class="line">********************************************************************************************</span><br><span class="line">var countBinarySubstrings = function(s) &#123;</span><br><span class="line">    **************************</span><br><span class="line">    let count=[];                 //此部分将每组0和1个数存入数组中，如[0,0,1,1,0,1,1]-count=[2,2,1,2]</span><br><span class="line">    let num=1;</span><br><span class="line">    let ans=0;</span><br><span class="line">    for(let i = 0; i &lt; s.length - 1; i++)&#123;</span><br><span class="line">        if(s[i]==s[i+1])&#123;</span><br><span class="line">            num++;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            count.push(num);</span><br><span class="line">            num=1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    count.push(num);</span><br><span class="line">    **************************</span><br><span class="line">     for (let j = 0; j &lt; count.length - 1; j++) &#123;</span><br><span class="line">        ans += Math.min(count[j], count[j + 1]);   //求每两组的贡献总和</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;;    // O(n)/O(n)</span><br></pre></td></tr></table></figure>

<p>这种只需要保留前后两个值的问题可以不用全部保存，就直接用两个值保存然后更新即可</p>
<h3 id="7-翻转字符串里的单词"><a href="#7-翻转字符串里的单词" class="headerlink" title="7.翻转字符串里的单词*"></a>7.翻转字符串里的单词*</h3><p><img src="/img/2021128-2.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var reverseWords = function (s) &#123;                      //trim去除两端所有空格，split正则表达</span><br><span class="line">    return s.trim().split(/\s+/g).reverse().join(&quot; &quot;)  //\s匹配空格，+匹配多个空格,g全局匹配</span><br><span class="line">    //return s.trim().split(&apos; &apos;).filter(v=&gt;(v !== &apos;&apos;)).reverse().join(&apos; &apos;)  过滤器也可</span><br><span class="line">&#125;;</span><br><span class="line">//时间和空间都是O(n)，空间O(n)用来存储字符串分割之后的结果</span><br></pre></td></tr></table></figure>

<h3 id="8-字符串相加"><a href="#8-字符串相加" class="headerlink" title="8.字符串相加*"></a>8.字符串相加*</h3><p><img src="/img/2021130-1.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var addStrings = function (num1, num2) &#123;</span><br><span class="line">    while (num1.length &gt; num2.length) num2 = &apos;0&apos; + num2;</span><br><span class="line">    while (num2.length &gt; num1.length) num1 = &apos;0&apos; + num1;  //先补0对齐</span><br><span class="line">    let res = &apos;&apos;;  //结果字符串</span><br><span class="line">    let pre = 0;   //进位</span><br><span class="line">    for (let i = num1.length - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">        let sum = +num1[i] + +num2[i] + pre;  //+号将字符转数字</span><br><span class="line">        if (sum &gt; 9) &#123;   //模10的结果 +res字符串</span><br><span class="line">            pre = 1;</span><br><span class="line">            res = (sum % 10) + res;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            pre = 0;</span><br><span class="line">            res = sum + res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return pre == 1 ? &apos;1&apos; + res : res;  //判断第一位是否要进位</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="8-1字符串转数字方法"><a href="#8-1字符串转数字方法" class="headerlink" title="8.1字符串转数字方法"></a>8.1字符串转数字方法</h4><p>1.字符串在运算操作中会被当做数字类型来处理：s*=1</p>
<p>2.字符前加‘+’：console.log(+s);</p>
<p>3.string的两个转换函数，只对string有效：parseInt(s); // 234    parseFloat(s); //234</p>
<p>4.强制类型转换：Number(s); // 234</p>
<p>数字转字符串：1.toString()     2.数字+任何字符串” “：console.log(num+””);</p>
<h3 id="9-最长公共前缀"><a href="#9-最长公共前缀" class="headerlink" title="9.最长公共前缀*"></a>9.最长公共前缀*</h3><p><img src="/img/2021203-3.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var longestCommonPrefix = function (strs) &#123;</span><br><span class="line">    if(strs.length==0) return &apos;&apos;;</span><br><span class="line">    if(strs.length==1) return strs[0];</span><br><span class="line">    let res = &apos;&apos;;</span><br><span class="line">    for (let i = 0; i &lt; strs[0].length; i++) &#123;  //横向比较，取第一个字符串</span><br><span class="line">        for (let j = 1; j &lt; strs.length; j++) &#123;  //从第二个字符串开始比较</span><br><span class="line">            if (strs[0][i] != strs[j][i]) return res;</span><br><span class="line">        &#125;</span><br><span class="line">        res += strs[0][i];</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><p>定义左右指针，多是while循环判断</p>
<h3 id="1-两数之和-II-输入有序数组-167"><a href="#1-两数之和-II-输入有序数组-167" class="headerlink" title="1.两数之和 II - 输入有序数组-167"></a>1.两数之和 II - 输入有序数组-167</h3><p><img src="/img/1590844727155.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//注意是升序的数组，且输出为index1&lt;index2</span><br><span class="line">var twoSum = function (numbers, target) &#123;</span><br><span class="line">    let left = 0, right = numbers.length - 1;  //双指针</span><br><span class="line">    while (left &lt; right) &#123;                    //升序数组，从最大和最小点开始遍历</span><br><span class="line">        if (numbers[left] + numbers[right] == target) &#123;</span><br><span class="line">            return [left + 1, right + 1];</span><br><span class="line">        &#125; else if (numbers[left] + numbers[right] &lt; target) &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-两数平方和-633"><a href="#2-两数平方和-633" class="headerlink" title="2.两数平方和-633"></a>2.两数平方和-633</h3><p><img src="/img/1590845239364.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var judgeSquareSum = function(c) &#123;</span><br><span class="line">    let right = Math.floor(Math.sqrt(c)),</span><br><span class="line">        left = 0;</span><br><span class="line">    </span><br><span class="line">    while(left &lt;= right)&#123;</span><br><span class="line">        let sum = right * right + left * left;</span><br><span class="line">        if(sum === c) return true;</span><br><span class="line">        if(sum &gt; c) right--;</span><br><span class="line">        else left++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return false;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="3-反转字符串中的元音字母-345"><a href="#3-反转字符串中的元音字母-345" class="headerlink" title="3.反转字符串中的元音字母-345"></a>3.反转字符串中的元音字母-345</h3><p><img src="/img/1590846646548.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var reverseVowels = function(s) &#123;</span><br><span class="line">    let sArray = s.split(&apos;&apos;);</span><br><span class="line">    let map = [&apos;a&apos;,&apos;e&apos;,&apos;i&apos;,&apos;o&apos;,&apos;u&apos;,&apos;A&apos;,&apos;E&apos;,&apos;I&apos;,&apos;O&apos;,&apos;U&apos;];</span><br><span class="line">    let len = sArray.length;</span><br><span class="line">    let left = 0,</span><br><span class="line">        right = len - 1;</span><br><span class="line">    while(left &lt; right)&#123;</span><br><span class="line">        let flagleft = map.indexOf(s[left]),</span><br><span class="line">            flagright = map.indexOf(s[right]);</span><br><span class="line">        if(flagleft === -1 ) left++;</span><br><span class="line">        if(flagright === -1) right--;</span><br><span class="line">        if(flagright !== -1 &amp;&amp; flagleft !== -1)&#123;</span><br><span class="line">            [sArray[left],sArray[right]] = [sArray[right],sArray[left]];</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return sArray.join(&apos;&apos;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ol>
<li>字符串不能改，要转换成array再改</li>
<li>字符串转array .split(‘分隔的字符串’)</li>
<li>array转字符串 .join(‘要连接每个元素的字符’)</li>
</ol>
<h3 id="4-验证回文字符串-Ⅱx-680"><a href="#4-验证回文字符串-Ⅱx-680" class="headerlink" title="4.验证回文字符串 Ⅱx-680"></a>4.验证回文字符串 Ⅱx-680</h3><p><img src="/img/1590847872558.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var validPalindrome = function (s) &#123;    //在基本的验证回文方法中，递归调用右边减一或左边加一情况。</span><br><span class="line">    function isPalindrome(s, left, right) &#123;</span><br><span class="line">        while (left &lt; right) &#123;</span><br><span class="line">            if (s[left++] != s[right--]) return false;</span><br><span class="line">            //等价于 if (s[left] != s[right]) &#123;return false;&#125;</span><br><span class="line">                       left++;right--;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    let left = 0,</span><br><span class="line">        right = s.length - 1;</span><br><span class="line">    while (left &lt; right) &#123;</span><br><span class="line">        if (s[left++] != s[right--]) return isPalindrome(s, left - 1, right) || isPalindrome(s, left, right + 1);//注意left++和right--过后就已经改变了</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;;</span><br><span class="line">*******************************************************************************************</span><br><span class="line">//LeetCode-125，验证回文字符串，正则+双指针</span><br><span class="line">var isPalindrome = function (s) &#123;</span><br><span class="line">    s = s.replace(/[^0-9a-zA-Z]/g, &apos;&apos;).toLowerCase()  //对于&quot;A man, a plan, a canal: Panama&quot;这样的</span><br><span class="line">    let i = 0, len = s.length, j = len - 1            //[^..]代表未包含的，用空字符代替，再转小写</span><br><span class="line">    while (i &lt; j) &#123;</span><br><span class="line">        if (s[i] == s[j]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return false</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>很巧妙的写法不用再自己写代码判断，分离出一个功能</p>
<h3 id="5-合并两个有序数组x-88"><a href="#5-合并两个有序数组x-88" class="headerlink" title="5.合并两个有序数组x-88*"></a>5.合并两个有序数组x-88*</h3><p><img src="/img/1590848756823.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//双指针法,从后往前比较，填充m+n的数组，若从前到后也可，不过需要将nums1先存起来，时间复杂度O(m+n),O(m)</span><br><span class="line">var merge = function (nums1, m, nums2, n) &#123;</span><br><span class="line">    let p1 = m - 1,</span><br><span class="line">        p2 = n - 1,</span><br><span class="line">        MAX_Length = m + n - 1;</span><br><span class="line">    while (p1 &gt;= 0 &amp;&amp; p2 &gt;= 0) &#123;</span><br><span class="line">        if (nums1[p1] &lt; nums2[p2]) nums1[MAX_Length--] = nums2[p2--];</span><br><span class="line">        else nums1[MAX_Length--] = nums1[p1--];</span><br><span class="line">    &#125;</span><br><span class="line">    //若nums1中的值比较小，p1很快就到0索引，我们要将nums2合并到nums1中，所以此处为p2</span><br><span class="line">    while(p2&gt;=0) nums1[MAX_Length--] = nums2[p2--];</span><br><span class="line">    return nums1;   //该题最后只能返回nums1，不能返回其他额外数组</span><br><span class="line">&#125;;时间复杂度O(m+n),O(1),最优解</span><br><span class="line">********************************************************************************************</span><br><span class="line">//巧妙的数组排序</span><br><span class="line">var merge = function (nums1, m, nums2, n) &#123;</span><br><span class="line">    nums1.splice(m);//由题意得:初始化nums1和nums2数组值，splice直接对原数组修改，所以不用slice(会生成新数组)</span><br><span class="line">    nums2.splice(n);//删除index==n开始及之后的值</span><br><span class="line">    nums1.push(...nums2);</span><br><span class="line">    nums1.sort((a, b) =&gt; a - b);</span><br><span class="line">&#125;;时间复杂度O((m+n)log(m+n)),O(1)</span><br></pre></td></tr></table></figure>

<p>从后往前遍历这样就可以不用多用一个数组来存储遍历后的值</p>
<h3 id="6-判断链表是否有环"><a href="#6-判断链表是否有环" class="headerlink" title="6.判断链表是否有环**"></a>6.判断链表是否有环**</h3><p><img src="/img/1590849597646.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var hasCycle = function (head) &#123;</span><br><span class="line">    if (!head) return false</span><br><span class="line">    let fast = head.next</span><br><span class="line">    let slow = head</span><br><span class="line">    while (fast &amp;&amp; fast.next) &#123;  //后面要用到fast.next.next，此处要判断fast.next是否为空</span><br><span class="line">        slow = slow.next</span><br><span class="line">        fast = fast.next.next</span><br><span class="line">        if (fast == slow) &#123;</span><br><span class="line">            return true</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//加强版，要求返回环入口的节点</span><br><span class="line">var detectCycle = function (head) &#123;</span><br><span class="line">    if (!head) return head;</span><br><span class="line">    let fast = head;</span><br><span class="line">    let slow = head;</span><br><span class="line">    while (fast &amp;&amp; fast.next) &#123;</span><br><span class="line">        slow = slow.next</span><br><span class="line">        fast = fast.next.next</span><br><span class="line">        if (fast == slow) &#123;  //没有环就不可能再相遇，相遇必在环内。</span><br><span class="line">            fast = head;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                if (slow == fast) &#123;</span><br><span class="line">                    return slow;</span><br><span class="line">                &#125;</span><br><span class="line">                fast = fast.next;</span><br><span class="line">                slow = slow.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="/img/20210316_1.png" alt="Alt text"></p>
<p>相遇时，慢指针走的距离：D+S1<br>假设相遇时快指针已经绕环 n 次，它走的距离：D+n(S1+S2)+S1<br>因为快指针的速度是 2 倍，所以相同时间走的距离也是 2 倍：<br>D+n(S1+S2)+S1 = 2(D+S1)<br>即 (n-1)S1+ nS2=D(n−1)S1+nS2=D<br>我们不关心绕了几次环，取 n = 1 这种特定情况，消掉 S1：<br>D=S2</p>
<p>怎么利用 D=S2 求入环点<br>在循环的过程中，快慢指针相遇，位置相同了，可以确定出相遇点<br>为了确定「入环点」，我们「人为制造」快慢指针在入环点相遇<br>让快指针从头节点出发，速度改为和慢指针一样，慢指针留在首次相遇点，同时出发<br>因为 D = S2D=S2 ，二者速度相同，所以会同时到达入环点。</p>
<h3 id="7-通过删除字母匹配到字典里最长单词x"><a href="#7-通过删除字母匹配到字典里最长单词x" class="headerlink" title="7.通过删除字母匹配到字典里最长单词x"></a>7.通过删除字母匹配到字典里最长单词x</h3><p><img src="/img/1590851228784.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var findLongestWord = function (s, d) &#123;</span><br><span class="line">    let maxlen = 0;</span><br><span class="line">    let maxS = &apos;&apos;;</span><br><span class="line">    function isEqual(s1, s2) &#123;</span><br><span class="line">        let p1 = 0,</span><br><span class="line">            p2 = 0;</span><br><span class="line">        let len1 = s1.length,</span><br><span class="line">            len2 = s2.length;</span><br><span class="line">        if (maxlen &gt; len2 || len2 &gt; len1) return false;</span><br><span class="line">        while (p1 &lt; len1 &amp;&amp; p2 &lt; len2)&#123;</span><br><span class="line">            if(s1[p1] === s2[p2])&#123;</span><br><span class="line">                p1++;</span><br><span class="line">                p2++;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                p1++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(p2 === len2) return true;</span><br><span class="line">        else return false;    </span><br><span class="line">    &#125;</span><br><span class="line">    for(let s2 of d)&#123;</span><br><span class="line">        if(isEqual(s,s2))&#123;</span><br><span class="line">            if(s2.length === maxS.length) maxS = maxS &lt; s2 ? maxS : s2;</span><br><span class="line">            else&#123;</span><br><span class="line">                maxS = s2;</span><br><span class="line">                maxlen = s2.length;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return maxS;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="8-接雨水"><a href="#8-接雨水" class="headerlink" title="8.接雨水*"></a>8.接雨水*</h3><p><img src="/img/2021122-1.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//双指针法</span><br><span class="line">var trap = function (height) &#123;</span><br><span class="line">    let ans = 0;</span><br><span class="line">    let left = 0, right = height.length - 1;</span><br><span class="line">    let left_max = 0, right_max = 0;</span><br><span class="line">    while (left &lt; right) &#123;    //左指针和右指针相遇为界，一次遍历</span><br><span class="line">        if(height[left]&lt;=height[right])&#123; //找出左右较小的那一个</span><br><span class="line">        ***************************************************************************</span><br><span class="line">            if(height[left]&gt;left_max)&#123;   //找出局部中左侧高于当前位置的index</span><br><span class="line">                left_max=height[left];    //因为右侧已经高于左侧，所以会形成积水</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                ans+=left_max-height[left];  //用左侧最大值减去当前块为积水量</span><br><span class="line">            &#125;</span><br><span class="line">        ***************************************************************************</span><br><span class="line">        上面if、else区域可替换成：</span><br><span class="line">            left_max = Math.max(left_max, height[left]);</span><br><span class="line">            ans += left_max - height[left];</span><br><span class="line">        ***************************************************************************</span><br><span class="line">            left++;      //@@@left++写在外面</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            if(height[right]&gt;right_max)&#123;  //右侧同理</span><br><span class="line">                right_max=height[right];</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                ans+=right_max-height[right];</span><br><span class="line">            &#125;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;     //时间复杂度O(n),空间复杂度O(1)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="9-移除元素"><a href="#9-移除元素" class="headerlink" title="9.移除元素*"></a>9.移除元素*</h3><p><img src="/img/20210312_03.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//数组的元素在内存地址中是连续的，不能单独删除数组中的某个元素，只能覆盖***.</span><br><span class="line">var removeElement = function (nums, val) &#123;  //双层for循环，但时间复杂度高</span><br><span class="line">    let len = nums.length;</span><br><span class="line">    for (let i = 0; i &lt; len; i++) &#123;</span><br><span class="line">        if (nums[i] == val) &#123;</span><br><span class="line">            for (let j = i + 1; j &lt; len; j++) &#123;</span><br><span class="line">                nums[j-1]=nums[j];</span><br><span class="line">            &#125;</span><br><span class="line">            i--;</span><br><span class="line">            len--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return len;</span><br><span class="line">&#125;;</span><br><span class="line">****************************************************************************************</span><br><span class="line">//优化：双指针法：最后返回的数组长度，但打印的是删除后的数组</span><br><span class="line">var removeElement = function (nums, val) &#123;</span><br><span class="line">    let len = nums.length;</span><br><span class="line">    let slow = 0;let fast = 0;</span><br><span class="line">    while(fast &lt; len) &#123;  //快慢指针一起移动，快指针所指覆盖慢指针值</span><br><span class="line">        if(nums[fast]!==val)&#123;</span><br><span class="line">           nums[slow]=nums[fast];</span><br><span class="line">           slow++;</span><br><span class="line">        &#125;</span><br><span class="line">        fast++;</span><br><span class="line">    &#125;</span><br><span class="line">    return slow;</span><br><span class="line">&#125;;</span><br><span class="line">**************************************************************************</span><br><span class="line">//LeetCode-80，删除有序数组中的重复项II：使每个元素最多出现两次 ，返回删除后数组的新长度。使用 O(1) 额外空间</span><br><span class="line">var removeDuplicates = function(nums) &#123;</span><br><span class="line">    let len = nums.length;</span><br><span class="line">    for (let i = 0; i &lt; len-2; i++) &#123;</span><br><span class="line">        if (nums[i] == nums[i+2]) &#123;</span><br><span class="line">            for (let j = i + 2; j &lt; len; j++) &#123;</span><br><span class="line">                nums[j-1]=nums[j];</span><br><span class="line">            &#125;</span><br><span class="line">            i--;</span><br><span class="line">            len--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return len;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="10-快乐数"><a href="#10-快乐数" class="headerlink" title="10.快乐数*"></a>10.快乐数*</h3><p><img src="/img/20210316_2.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var isHappy = function (n) &#123;</span><br><span class="line">    function getsum(n) &#123;  //平方和算法</span><br><span class="line">        n = n + &apos;&apos;;</span><br><span class="line">        let len = n.length;</span><br><span class="line">        let sum = 0;</span><br><span class="line">        for (let i = 0; i &lt; len; i++) &#123;</span><br><span class="line">            sum += n[i] ** 2;</span><br><span class="line">        &#125;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line">    let slow = n;  //双指针移动</span><br><span class="line">    let fast = getsum(n);</span><br><span class="line">    while (fast != 1 &amp;&amp; slow != fast) &#123;</span><br><span class="line">        slow = getsum(slow);</span><br><span class="line">        fast = getsum(getsum(fast));</span><br><span class="line">    &#125;</span><br><span class="line">    return fast == 1</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="1-排序的方式总结-JS"><a href="#1-排序的方式总结-JS" class="headerlink" title="1.排序的方式总结(JS)"></a>1.排序的方式总结(JS)</h3><h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><ol>
<li><p>思想<br>第一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，然后再从剩余的未排序元素中寻找到最小（大）元素，然后放到已排序的序列的末尾。 以此类推，直到全部待排序的数据元素的个数为零。 选择排序是不稳定的排序方法。</p>
</li>
<li><p>代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function selectSort(arr) &#123;</span><br><span class="line">    let len = arr.length;</span><br><span class="line">    for (let i = 0; i &lt; len - 1; i++) &#123;</span><br><span class="line">        let minIndex = i;</span><br><span class="line">        for (let j = i + 1; j &lt; len; j++) &#123;</span><br><span class="line">            if (arr[j] &lt; arr[minIndex]) minIndex = j;</span><br><span class="line">        &#125;</span><br><span class="line">        [arr[minIndex], arr[i]] = [arr[i], arr[minIndex]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let arr = [4,3,2,1];</span><br><span class="line">selectSort(arr);</span><br><span class="line">console.log(arr);</span><br></pre></td></tr></table></figure>
</li>
<li><p>分析</p>
</li>
</ol>
<ul>
<li>时间复杂度<pre><code>* O(n2)
* 最好最坏都是O(n2)</code></pre></li>
<li>空间<pre><code>*  O(1)</code></pre></li>
<li>不稳定</li>
</ul>
<h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><ol>
<li><p>思想<br><img src="/img/1590907447140.png" alt="Alt text"></p>
</li>
<li><p>代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function insertSort(arr) &#123;</span><br><span class="line">    let len = arr.length;</span><br><span class="line">    for (let i = 1; i &lt; len; i++) &#123;</span><br><span class="line">        let temp = arr[i];</span><br><span class="line">        let j;</span><br><span class="line">        for (j = i - 1; j &gt;= 0; j--) &#123;</span><br><span class="line">            if(temp &lt; arr[j]) [arr[j],arr[j + 1]] = [arr[j + 1], arr[j]];</span><br><span class="line">            else break;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j + 1] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let arr = [20,3,4,2,51,23,45];</span><br><span class="line">insertSort(arr);</span><br><span class="line">console.log(arr);</span><br></pre></td></tr></table></figure>
</li>
<li><p>分析</p>
</li>
</ol>
<ul>
<li>时间复杂度<pre><code>* 平均： O(n2)
* 最差：O(n2)
* 最优：O(n)已经有序</code></pre></li>
<li>空间复杂度<pre><code>* O(1)</code></pre></li>
<li>稳定<h4 id="冒泡"><a href="#冒泡" class="headerlink" title="冒泡"></a>冒泡</h4></li>
</ul>
<p>1.思想<br>就是n-1趟排序，把最大的值浮上去<br>2.代码</p>
<ul>
<li><p>没有优化的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function bubbleSort(arr) &#123;</span><br><span class="line">    let len = arr.length;</span><br><span class="line">    for (let i = 1; i &lt; len; i++) &#123;//总共排序len - 1趟</span><br><span class="line">        for (let j = 0; j &lt; len - i; j++) &#123;    //长度-1</span><br><span class="line">            if (arr[j] &gt; arr[j + 1]) [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let arr = [4,3,2,1,1,2,5,25,6,22];</span><br><span class="line">bubbleSort(arr);</span><br><span class="line">console.log(arr);</span><br></pre></td></tr></table></figure>
</li>
<li><p>优化后的冒泡排序<br>就是加个标识：如果某一趟排序没有交换顺序说明已经有序无须再继续</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function bubbleSort(arr) &#123;</span><br><span class="line">    let len = arr.length;</span><br><span class="line">    for (let i = 1; i &lt; len; i++) &#123;//总共排序len - 1趟</span><br><span class="line">        let flag = true;</span><br><span class="line">        for (let j = 0; j &lt; len - i; j++) &#123;</span><br><span class="line">            if (arr[j] &gt; arr[j + 1])&#123;</span><br><span class="line">                [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];</span><br><span class="line">                flag = false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(flag) break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let arr = [4,3,2,1,1,2,5,25,6,22]</span><br><span class="line">bubbleSort(arr);</span><br><span class="line">console.log(arr);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol start="3">
<li>分析(优化后)</li>
</ol>
<ul>
<li>时间复杂度<pre><code>* O(n2)
* O(n) 最优
* O(n2)最差</code></pre></li>
<li>稳定<h4 id="二路归并x"><a href="#二路归并x" class="headerlink" title="二路归并x"></a>二路归并x</h4></li>
</ul>
<ol>
<li>思想<br>把一个数组二分，先对左边进行二路归并，再对右边进行二路归并使左右两边有序，再把左右两边组合为一个连续的数组。需要把一个数组的<strong>连续</strong>的两个有序的部分组合称为一个有序的部分。</li>
<li>代码</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function mergeSort(arr, left, right) &#123;</span><br><span class="line">    function merge(arr, l1, r1, l2, r2) &#123;</span><br><span class="line">        let p1 = l1,</span><br><span class="line">            p2 = l2;</span><br><span class="line"></span><br><span class="line">        let temp = [];</span><br><span class="line"></span><br><span class="line">        while (p1 &lt;= r1 &amp;&amp; p2 &lt;= r2) &#123;</span><br><span class="line">            if (arr[p1] &lt; arr[p2]) temp.push(arr[p1++]);</span><br><span class="line">            else temp.push(arr[p2++]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        while (p1 &lt;= r1) temp.push(arr[p1++]);</span><br><span class="line">        while (p2 &lt;= r2) temp.push(arr[p2++]);</span><br><span class="line"></span><br><span class="line">        for (let i = 0; i &lt; temp.length; i++) &#123;</span><br><span class="line">            arr[i + l1] = temp[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    let mid = Math.floor((left + right) / 2);  </span><br><span class="line">    if (left &lt; right) &#123;</span><br><span class="line">        mergeSort(arr, left, mid);</span><br><span class="line">        mergeSort(arr, mid + 1, right);</span><br><span class="line">        merge(arr, left, mid, mid + 1, right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">arr = [4, 3, 2, 1, 1, 2, 5, 25, 6, 22]</span><br><span class="line">mergeSort(arr,0,arr.length - 1);</span><br><span class="line">console.log(arr);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>分析</li>
</ol>
<ul>
<li>时间复杂度<pre><code>* O(nlogn)</code></pre></li>
<li>空间复杂度<pre><code>* O(n)</code></pre></li>
<li>稳定</li>
</ul>
<h4 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h4><ol>
<li>思想<br>调整一个序列的第一个值的位置使得让其左边的值都小于等于它，右边的值都大于等于它，然后再最左边和右边进行递归，双while循环</li>
<li>实现</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function quickSort(arr, left, right) &#123;</span><br><span class="line">    function partition(arr, left, right) &#123;</span><br><span class="line">        let temp = arr[left];</span><br><span class="line">        while (left &lt; right) &#123;</span><br><span class="line">            while (arr[right] &gt;= temp &amp;&amp; left &lt; right) right--;</span><br><span class="line">            arr[left] = arr[right];</span><br><span class="line">            while (arr[left] &lt;= temp &amp;&amp; left &lt; right) left++;  //left&lt;right要存在</span><br><span class="line">            arr[right] = arr[left];</span><br><span class="line">        &#125;</span><br><span class="line">        arr[left] = temp;</span><br><span class="line">        return left;    </span><br><span class="line">    &#125;</span><br><span class="line">    //调用分区方法</span><br><span class="line">    if (left &lt; right) &#123;</span><br><span class="line">        let mid = partition(arr, left, right);</span><br><span class="line">        quickSort(arr, left, mid - 1);</span><br><span class="line">        quickSort(arr, mid + 1, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let arr = [4, 3, 2, 1, 1, 2, 5, 25, 6, 22]</span><br><span class="line">quickSort(arr, 0, arr.length - 1);</span><br><span class="line">console.log(arr);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>分析</li>
</ol>
<ul>
<li>时间复杂度<pre><code>* O(nlogn)</code></pre></li>
<li>不稳定<h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4></li>
</ul>
<ol>
<li><p>思想<br>先建立一个大顶堆，再进行堆排序，注意堆是一棵完全二叉树，下标要从1开始，所以要调整一下下标</p>
</li>
<li><p>实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function heapSort(arr) &#123;</span><br><span class="line">    //向下调整</span><br><span class="line">    function downAdjust(left, right) &#123;</span><br><span class="line">        let lchild = left * 2;</span><br><span class="line">        let rchild = lchild + 1;</span><br><span class="line">        if (lchild &gt; right) return;</span><br><span class="line">        //找到lchild和rchild中的较大值，并把较大的值赋给lchild</span><br><span class="line">        if (rchild &lt;= right &amp;&amp; arr[lchild] &lt; arr[rchild]) [lchild, rchild] = [rchild, lchild];</span><br><span class="line">        //与这个结点比较</span><br><span class="line">        if (arr[left] &lt; arr[lchild]) &#123;</span><br><span class="line">            [arr[left], arr[lchild]] = [arr[lchild], arr[left]];</span><br><span class="line">            downAdjust(lchild, right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //假设arr不从1下标开始</span><br><span class="line">    arr.push(arr[0]);</span><br><span class="line">    var len = arr.length - 1;</span><br><span class="line"></span><br><span class="line">    //从倒数第一个非叶子结点开始向下调整得到大顶堆</span><br><span class="line">    for (let i = Math.floor(len / 2); i &gt; 0; i--) &#123;</span><br><span class="line">        downAdjust(i, len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //再进行堆排序</span><br><span class="line">    for(let i = len; i &gt; 0;i--)&#123;</span><br><span class="line">        [arr[i],arr[1]] = [arr[1],arr[i]];</span><br><span class="line">        downAdjust(1,i-1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //再去掉这个空值</span><br><span class="line">    arr.shift();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">arr = [2, 3, 12, 41, 32, 12, 3];</span><br><span class="line">heapSort(arr);</span><br><span class="line">console.log(arr);</span><br></pre></td></tr></table></figure>
</li>
<li><p>分析</p>
</li>
</ol>
<ul>
<li>时间复杂度<pre><code>* O(nlogn)</code></pre></li>
<li>不稳定<h4 id="排序方式比较"><a href="#排序方式比较" class="headerlink" title="排序方式比较"></a>排序方式比较</h4><img src="/img/1591672890948.png" alt="Alt text"></li>
</ul>
<h3 id="2-调数组顺序使奇数在偶数前"><a href="#2-调数组顺序使奇数在偶数前" class="headerlink" title="2.调数组顺序使奇数在偶数前*"></a>2.调数组顺序使奇数在偶数前*</h3><p><img src="/img/2021121.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var exchange = function (nums) &#123; //快速排序</span><br><span class="line">    let r = nums.length - 1;</span><br><span class="line">    let temp;</span><br><span class="line">    let i = 0, j = r;</span><br><span class="line">    while (i &lt; j) &#123;</span><br><span class="line">        while (i &lt; j &amp;&amp; nums[i] % 2 == 1)</span><br><span class="line">            i++;</span><br><span class="line">        while (i &lt; j &amp;&amp; nums[j] % 2 == 0) &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        if (i &lt; j) &#123;</span><br><span class="line">            temp=nums[j];</span><br><span class="line">            nums[j] = nums[i];</span><br><span class="line">            nums[i]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return nums;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="3-数组中的第K个最大元素"><a href="#3-数组中的第K个最大元素" class="headerlink" title="3.数组中的第K个最大元素**"></a>3.数组中的第K个最大元素**</h3><p><img src="/img/1591675240874.png" alt="Alt text"></p>
<p>解法1:直接用js内置的sort()<br>**注意：内置sort会把所有的东西都转换为字符串进行比较，所以要转换成数字比较</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var findKthLargest = function (nums, k) &#123;</span><br><span class="line">    nums.sort((a,b)=&gt;&#123;  //转为数值比较   ***不写大括号的直接a-b</span><br><span class="line">        return a-b</span><br><span class="line">    &#125;)</span><br><span class="line">    let len=nums.length</span><br><span class="line">    return nums[len-k]  //len-k为第k大的数</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>解法2:使用大/小顶堆</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var findKthLargest = function (nums, k) &#123;</span><br><span class="line">    //创建大顶堆</span><br><span class="line">    //向下调整</span><br><span class="line">    function downAdjust(nums, low, high) &#123;</span><br><span class="line">        let lchild = low * 2;</span><br><span class="line">        let rchild = lchild + 1;</span><br><span class="line">        if (lchild &gt; high) return;</span><br><span class="line">        if (rchild &lt;= high &amp;&amp; nums[lchild] &lt; nums[rchild]) [lchild, rchild] = [rchild, lchild];</span><br><span class="line">        if (nums[low] &lt; nums[lchild]) &#123;</span><br><span class="line">            [nums[lchild], nums[low]] = [nums[low], nums[lchild]];</span><br><span class="line">            downAdjust(nums, lchild, high);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //调整为大顶堆</span><br><span class="line">    nums.push(nums[0]);</span><br><span class="line">    let len = nums.length - 1;</span><br><span class="line">    for (let i = Math.floor(len / 2); i &gt; 0; i--) &#123;</span><br><span class="line">        downAdjust(nums, i, len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //通过大顶堆排序取第k个值，不用全部都排，只排到第k个即可</span><br><span class="line">    for (let i = len; i &gt; len - k; i--) &#123;</span><br><span class="line">        [nums[1], nums[i]] = [nums[i], nums[1]];</span><br><span class="line">        downAdjust(nums, 1, i - 1);</span><br><span class="line">    &#125;</span><br><span class="line">    return nums[len - k + 1];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(findKthLargest([3,2,3,1,2,4,5,5,6,7,7,8,2,3,1,1,1,10,11,5,6,2,4,7,8,5,6],2));</span><br></pre></td></tr></table></figure>

<p>解法3:快排</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var findKthLargest = function (nums, k) &#123;</span><br><span class="line">    //快排逆序</span><br><span class="line">    //实现分配函数使nums第一个值的左边都大于它，右边都小于它，一遍快排</span><br><span class="line">    let len = nums.length</span><br><span class="line">    function partition(nums, l, r) &#123;</span><br><span class="line">        let temp = nums[l]   //存的是左值，不能写0</span><br><span class="line">        let first = l, end = r</span><br><span class="line">        while (first &lt; end) &#123;</span><br><span class="line">            while (first &lt; end &amp;&amp; nums[end] &gt; temp) end--;</span><br><span class="line">            nums[first] = nums[end]</span><br><span class="line">            while (first &lt; end &amp;&amp; nums[first] &lt;= temp) first++;</span><br><span class="line">            nums[end] = nums[first]</span><br><span class="line">        &#125;</span><br><span class="line">        nums[first] = temp</span><br><span class="line">        return first              //返回的是分界下标</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //递归进行快排，实现全部排序</span><br><span class="line">    function quick(nums, l, r) &#123;</span><br><span class="line">        if (l &gt; r) return</span><br><span class="line">        let curr = partition(nums, l, r)</span><br><span class="line">        quick(nums, l, curr - 1)</span><br><span class="line">        quick(nums, curr + 1, r)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    quick(nums, 0, len - 1)</span><br><span class="line">    return nums[len - k]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="4-出现频率最多的-k-个元素-桶排序-x"><a href="#4-出现频率最多的-k-个元素-桶排序-x" class="headerlink" title="4.出现频率最多的 k 个元素(桶排序)x"></a>4.出现频率最多的 k 个元素(桶排序)x</h3><p><img src="/img/1591686781430.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var topKFrequent = function (nums, k) &#123;</span><br><span class="line">  //首先建立每个值的频率键值对</span><br><span class="line">  let map = new Map();</span><br><span class="line">  nums.forEach(function (item) &#123;</span><br><span class="line">      //注意只能通过.get去访问map中的值</span><br><span class="line">      if (map.has(item)) map.set(item,map.get(item)+1);</span><br><span class="line">      else map.set(item, 1 );</span><br><span class="line">  &#125;)</span><br><span class="line">  //以频率为数组下标放入一个数组中   **遍历map方法**</span><br><span class="line">  let arr = [];</span><br><span class="line">  map.forEach(function (value, key) &#123;</span><br><span class="line">      if (!arr[value]) arr[value] = [];</span><br><span class="line">      arr[value].push(key);</span><br><span class="line">  &#125;)</span><br><span class="line">  //逆序遍历数组取k个元素放入result数组</span><br><span class="line">  let result = [];</span><br><span class="line">  let len = arr.length - 1;</span><br><span class="line">  let count = 0;</span><br><span class="line">  for(let i = len;i &gt; 0;i--)&#123;</span><br><span class="line">      if(arr[i])&#123;</span><br><span class="line">          //注意因为答案唯一所以不用在此处再进行一次遍历判断是否已经达到了k个</span><br><span class="line">          result.push(...arr[i]);</span><br><span class="line">          count += arr[i].length;</span><br><span class="line">      &#125;</span><br><span class="line">      if(count == k) break;</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//方法二：</span><br><span class="line">//1.遍历数组，将数组的值作为 key, 值的个数作为 value，存入一个 map 中</span><br><span class="line">//2.遍历 map，将 map 里面的 key 和 value，作为一个对象 &#123;key:key,value:value&#125; 存入一个数组中</span><br><span class="line">//3.将对象数组根据 value 从大到小排序</span><br><span class="line">//4.截取对象数组的前 K 个值，返回其 key 组成的数组即可</span><br><span class="line">var topKFrequent = function(nums, k) &#123;</span><br><span class="line">    // 1.遍历数组，将所有结果存储到 map 中</span><br><span class="line">    let map = new Map()</span><br><span class="line">    for (let item of nums) &#123;</span><br><span class="line">        if (map.has(item)) &#123;</span><br><span class="line">            let count = map.get(item) + 1</span><br><span class="line">            map.set(item, count)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            map.set(item, 1)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 2.把数据存入一个对象数组</span><br><span class="line">    let array = []</span><br><span class="line">    for (let [key, value] of map) &#123;</span><br><span class="line">        array.push(&#123;</span><br><span class="line">            key,</span><br><span class="line">            value</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    // 3.将对象数组根据 value 从大到小排序</span><br><span class="line">    array.sort((a, b) =&gt; &#123;</span><br><span class="line">        return b.value - a.value</span><br><span class="line">    &#125;)</span><br><span class="line">    // 4.截取前k个，返回其key值组成的数组，这里map为数组遍历方法</span><br><span class="line">    return array.slice(0,k).map(item =&gt; &#123;</span><br><span class="line">        return item.key</span><br><span class="line">    &#125;)</span><br><span class="line">    //和第四步同理</span><br><span class="line">    //let res = []</span><br><span class="line">    //for (let item of arr.slice(0,k)) &#123;</span><br><span class="line">    //   res.push(item.key)</span><br><span class="line">    //&#125;</span><br><span class="line">    //return res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="5-根据字符出现频率排序"><a href="#5-根据字符出现频率排序" class="headerlink" title="5.根据字符出现频率排序"></a>5.根据字符出现频率排序</h3><p><img src="/img/1591688030276.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var frequencySort = function (s) &#123;</span><br><span class="line">    let map = new Map();</span><br><span class="line">    let len = s.length;</span><br><span class="line">    for (let i = 0; i &lt; len; i++) &#123;</span><br><span class="line">        if (map.has(s[i])) map.set(s[i], map.get(s[i]) + 1);</span><br><span class="line">        else map.set(s[i], 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    let arr = [];</span><br><span class="line">    map.forEach(function (val, key) &#123;</span><br><span class="line">        if (!arr[val]) arr[val] = [];  //有多个相同个数的字符，push到一个数组中</span><br><span class="line">        arr[val].push(key);</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    let ans = &apos;&apos;;</span><br><span class="line">    for (let i = arr.length - 1; i &gt; 0; i--) &#123;</span><br><span class="line">        if (arr[i]) &#123;  // 新数组有空位，要判断是否存在</span><br><span class="line">            arr[i].forEach(function (item) &#123;  //一个数组中多个字符分别遍历</span><br><span class="line">                for (let j = 0; j &lt; i; j++) ans += item;  //对每一个元素都加上对应的频率次</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6-颜色分类-荷兰国旗问题"><a href="#6-颜色分类-荷兰国旗问题" class="headerlink" title="6.颜色分类(荷兰国旗问题)"></a>6.颜色分类(荷兰国旗问题)</h3><p><img src="/img/1591728035315.png" alt="Alt text"></p>
<p><strong>三路快排</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var sortColors = function (nums) &#123;</span><br><span class="line">    let zero = 0,</span><br><span class="line">        one = 0,</span><br><span class="line">        two = nums.length - 1;</span><br><span class="line">    while (one &lt;= two) &#123;</span><br><span class="line">        if (nums[one] === 0) &#123;</span><br><span class="line">            [nums[one], nums[zero]] = [nums[zero], nums[one]];</span><br><span class="line">            one++;</span><br><span class="line">            zero++;</span><br><span class="line">        &#125; else if (nums[one] === 1) &#123;</span><br><span class="line">            one++;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            [nums[one], nums[two]] = [nums[two], nums[one]];</span><br><span class="line">            two--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return nums;</span><br><span class="line">&#125;;</span><br><span class="line">***************************************************************************************</span><br><span class="line">方法二：</span><br><span class="line">var sortColors = function (nums) &#123;  //使用数组方法将0删除再插到头部，将2删除再接到尾部</span><br><span class="line">    let len = nums.length</span><br><span class="line">    for (let i = 0; i &lt; len; i++) &#123;</span><br><span class="line">        if (nums[i] === 0) &#123;</span><br><span class="line">            nums.splice(i, 1)</span><br><span class="line">            nums.unshift(0)         //每次插到头部时，指针指向新插入元素</span><br><span class="line">        &#125;</span><br><span class="line">        if (nums[i] === 2) &#123;</span><br><span class="line">            nums.splice(i, 1)</span><br><span class="line">            nums.push(2)</span><br><span class="line">            len--                   //</span><br><span class="line">            i--                     //每次删除一元素，指针不动，后一元素补上</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return nums</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h2><h3 id="1-分发饼干-455"><a href="#1-分发饼干-455" class="headerlink" title="1.分发饼干-455*"></a>1.分发饼干-455*</h3><p><img src="/img/1591761997045.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var findContentChildren = function (g, s) &#123;</span><br><span class="line">    let Glen = g.length, Slen = s.length;</span><br><span class="line">    g.sort((a, b) =&gt; a - b);  //对g，s排序</span><br><span class="line">    s.sort((a, b) =&gt; a - b);</span><br><span class="line">    let count = 0;</span><br><span class="line">    for (let i = 0, j = 0; i &lt; Glen &amp;&amp; j &lt; Slen; i++ , j++) &#123;</span><br><span class="line">        while (j &lt; Slen &amp;&amp; g[i] &gt; s[j]) &#123;  //需求大于饼干量，该饼干量无法满足任何人，作废</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        if (j &lt; Slen) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-无重叠区间x"><a href="#2-无重叠区间x" class="headerlink" title="2.无重叠区间x"></a>2.无重叠区间x</h3><p><img src="/img/1591773030872.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//找不重叠的区间，对右区间排序</span><br><span class="line">var eraseOverlapIntervals = function (intervals) &#123;</span><br><span class="line">    if (intervals.length == 0) return 0</span><br><span class="line">    intervals.sort((a, b) =&gt; a[1] - b[1])  //移除区间数量最少，让每个子区间右值越小，其余的空闲区间就越大</span><br><span class="line">    let right = intervals[0][1]</span><br><span class="line">    let count = 0</span><br><span class="line">    for (let i = 1; i &lt; intervals.length; i++) &#123;</span><br><span class="line">        if (intervals[i][0] &gt;= right) &#123;</span><br><span class="line">            right = intervals[i][1]  //不重叠改变指针</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            count++                  //重叠时i指针后移，自动过滤右值大的子区间</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return count</span><br><span class="line">&#125;;</span><br><span class="line">若是用左值来排序，要考虑[[1,100],[1,10],[2,20]]这种包含关系，做出判断，并删除右值大的一项[1,100]</span><br></pre></td></tr></table></figure>

<h3 id="3-用最少数量的箭引爆气球"><a href="#3-用最少数量的箭引爆气球" class="headerlink" title="3.用最少数量的箭引爆气球"></a>3.用最少数量的箭引爆气球</h3><p><img src="/img/1591774211370.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//找不重叠区间即可，不重叠就加一，重叠继续</span><br><span class="line">var findMinArrowShots = function(points) &#123;</span><br><span class="line">    if(!points[0]) return 0;</span><br><span class="line">    //先排序</span><br><span class="line">    points.sort((x,y)=&gt;&#123;</span><br><span class="line">        return x[1] - y[1];</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    //再找不重叠区间</span><br><span class="line">    let account = 1;</span><br><span class="line">    let end = points[0][1];</span><br><span class="line"></span><br><span class="line">    for(let i = 1;i &lt; points.length;i++)&#123;</span><br><span class="line">        if(end &lt; points[i][0])&#123;</span><br><span class="line">            account++;</span><br><span class="line">            end = points[i][1];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return account;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>思路与上一个题类似，都是对重叠区间的处理问题</p>
<h3 id="4-根据身高重建队列xx-406"><a href="#4-根据身高重建队列xx-406" class="headerlink" title="4.根据身高重建队列xx-406"></a>4.根据身高重建队列xx-406</h3><p><img src="/img/1591776160717.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//先按身高从大到小排序，按照身高排序之后，优先按身高高的people的k来插入，后序插入节点也不会影响前面已经插入的节点</span><br><span class="line">var reconstructQueue = function(people) &#123;</span><br><span class="line">    //按照身高降序排序，若身高相同按K升序来排序***</span><br><span class="line">    people.sort((x,y)=&gt;&#123;</span><br><span class="line">        if(x[0] !== y[0]) return y[0] - x[0];</span><br><span class="line">        else return x[1] - y[1];</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    let ans = [];   //插入空数组</span><br><span class="line">    people.forEach(function(person)&#123;</span><br><span class="line">        ans.splice(person[1],0,person);  //注意splice方法进行插入，删除数组的用法</span><br><span class="line">    &#125;);</span><br><span class="line">    //等同于</span><br><span class="line">    //for (let i = 0; i &lt; people.length; i++) &#123;</span><br><span class="line">    //   ans.splice(people[i][1], 0, people[i])</span><br><span class="line">    //&#125;</span><br><span class="line"></span><br><span class="line">    return ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="5-买卖股票的最佳时机xx-121"><a href="#5-买卖股票的最佳时机xx-121" class="headerlink" title="5.买卖股票的最佳时机xx-121*"></a>5.买卖股票的最佳时机xx-121*</h3><p><img src="/img/1591777069363.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var maxProfit = function(prices) &#123;</span><br><span class="line">    let profit = 0;</span><br><span class="line">    let minPrice = 9999999;</span><br><span class="line">    prices.forEach(function(price)&#123;</span><br><span class="line">        minPrice = Math.min(minPrice,price);</span><br><span class="line">        profit = Math.max(profit,price - minPrice);</span><br><span class="line">    &#125;)</span><br><span class="line">    return profit;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6-买卖股票的最佳时机-II"><a href="#6-买卖股票的最佳时机-II" class="headerlink" title="6.买卖股票的最佳时机 II*"></a>6.买卖股票的最佳时机 II*</h3><p><img src="/img/1591777883709.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var maxProfit = function (prices) &#123;</span><br><span class="line">    let ans = 0;</span><br><span class="line">    let len = prices.length;</span><br><span class="line">    for (let i = 0; i &lt; len-1; i++) &#123;</span><br><span class="line">        ans += prices[i+1] - prices[i] &gt; 0 ? prices[i+1] - prices[i] : 0;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>能获得的最大收益就是所有的涨，不用考虑买入。找到递增的时间段，累加即可；</p>
<h3 id="7-种花问题x"><a href="#7-种花问题x" class="headerlink" title="7.种花问题x"></a>7.种花问题x</h3><p><img src="/img/1591842317492.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var canPlaceFlowers = function (flowerbed, n) &#123;</span><br><span class="line">    let i = 0;</span><br><span class="line">    let account = 0;</span><br><span class="line">    let len = flowerbed.length;</span><br><span class="line">    while (i &lt; len) &#123;</span><br><span class="line">        if (flowerbed[i] === 1) i = i + 2;</span><br><span class="line">        else &#123;</span><br><span class="line">            let pre = i === 0 ? 0 : flowerbed[i - 1];   //i为索引值，判断左右边界情况</span><br><span class="line">            let next = i === len - 1 ? 0 : flowerbed[i + 1];</span><br><span class="line">            if (pre === 0 &amp;&amp; next === 0) &#123;</span><br><span class="line">                account++;</span><br><span class="line">                flowerbed[i] = 1;</span><br><span class="line">                i = i + 2;</span><br><span class="line">            &#125;else i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return account &gt;= n;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="8-判断子序列x"><a href="#8-判断子序列x" class="headerlink" title="8.判断子序列x"></a>8.判断子序列x</h3><p><img src="/img/1591843099026.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//子序列 是不要求连续的,子数组和子串一样，是需要连续的</span><br><span class="line">var isSubsequence = function(s, t) &#123;</span><br><span class="line">    let len = s.length;</span><br><span class="line">    let flag = true;</span><br><span class="line">    for(let i = 0;i &lt; len;i++)&#123;</span><br><span class="line">        let index = t.indexOf(s[i]);</span><br><span class="line">        if(index == -1)&#123;</span><br><span class="line">            flag = false;</span><br><span class="line">            break;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            t = t.substring(index + 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return flag;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="9-非递减数列x"><a href="#9-非递减数列x" class="headerlink" title="9.非递减数列x"></a>9.非递减数列x</h3><p><img src="/img/1591844645186.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//题中非递减数列定义的是：递增数列+等于，所以数组中只能有一对相邻的递减值，同时考虑改变这对值时，对前后序列的影响</span><br><span class="line">//如[3,4,2,3]就不能单纯找一对递减的[4,2]</span><br><span class="line">var checkPossibility = function (nums) &#123;   //要想递增，要么前一项缩小，要么后一项增大</span><br><span class="line">    let flag = nums[0] &gt; nums[1] ? false : true;  //后悔数，用于标识改变元素一次--此处判断因后续要用到i-1</span><br><span class="line">    for (let i = 1; i &lt; nums.length; i++) &#123;</span><br><span class="line">        if (nums[i] &gt; nums[i + 1]) &#123;  //找到递减的一对</span><br><span class="line">            if (flag) &#123;               //若为true，代表还没改变过</span><br><span class="line">                if(nums[i-1]&lt;nums[i+1])&#123;  //i的后一项大于i的前一项，改i值可递增（瞻前顾后法）</span><br><span class="line">                    nums[i]=nums[i+1];</span><br><span class="line">                    flag=false;</span><br><span class="line">                &#125;</span><br><span class="line">                else if(nums[i-1]&gt;nums[i+1])&#123;</span><br><span class="line">                    nums[i+1]=nums[i];</span><br><span class="line">                    flag=false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else&#123;                 //一次机会用完，还有其他递减对，所以flase</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="10-最大子序和x"><a href="#10-最大子序和x" class="headerlink" title="10.最大子序和x*"></a>10.最大子序和x*</h3><p><img src="/img/1591865820028.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//动态规划解法</span><br><span class="line">var maxSubArray = function (nums) &#123;</span><br><span class="line">    let pre = nums[0];   //数组为[-1]单个元素时</span><br><span class="line">    let max = pre;</span><br><span class="line">    let len = nums.length;</span><br><span class="line">    for (let i = 1; i &lt; len; i++) &#123;</span><br><span class="line">        if (pre &lt; 0) &#123;</span><br><span class="line">            pre = nums[i];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            pre += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        max = Math.max(pre, max);</span><br><span class="line">    &#125;</span><br><span class="line">    return max;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="11-划分字母区间xxx"><a href="#11-划分字母区间xxx" class="headerlink" title="11.划分字母区间xxx"></a>11.划分字母区间xxx</h3><p><img src="/img/1591867918905.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//找到每个字符的最远距离，若索引i==最远距离索引，一段结束。</span><br><span class="line">var partitionLabels = function (S) &#123;</span><br><span class="line">    let len = S.length;</span><br><span class="line">    let pos = [];</span><br><span class="line">    let l = 0,</span><br><span class="line">        r = 0;</span><br><span class="line">    let ans = [];</span><br><span class="line">    //用一个数组存储所有的字符最后一次出现的下标</span><br><span class="line">    for (let i = 0; i &lt; len; i++) &#123;</span><br><span class="line">        pos[S[i].charCodeAt() - 97] = i;   //97是小写字母a的ASCII值</span><br><span class="line">    &#125;</span><br><span class="line">    for (let i = 0; i &lt; len; i++) &#123;</span><br><span class="line">        //更新一个区间的右边界</span><br><span class="line">        r = Math.max(r, pos[S[i].charCodeAt() - 97]);</span><br><span class="line">        //如果更新了过后仍然处在右边界上说明找到了一个区间</span><br><span class="line">        if (i === r) &#123;</span><br><span class="line">            ans.push(r - l + 1);</span><br><span class="line">            l = i + 1;</span><br><span class="line">            r = i + 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;;</span><br><span class="line">**********************************************************************************</span><br><span class="line">//自己的方法</span><br><span class="line">var partitionLabels = function (S) &#123;</span><br><span class="line">    let index = 0;  //存储最远下标</span><br><span class="line">    let len = S.length;</span><br><span class="line">    let ans = [];</span><br><span class="line">    for (let i = 0; i &lt; len; i++) &#123;</span><br><span class="line">        let indexEnd = S.lastIndexOf(S[i]);  //找到当前字符最远下标</span><br><span class="line">        index = Math.max(index, indexEnd);   //记录最远下标</span><br><span class="line">        if (index == i) &#123;   //一段结束</span><br><span class="line">            ans.push(i + 1);</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //此时ans是累加长度</span><br><span class="line">    for (let j = ans.length - 1; j &gt; 0; j--) &#123;  //截取长度</span><br><span class="line">        ans[j] = ans[j] - ans[j - 1];</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="12-盛最多水的容器"><a href="#12-盛最多水的容器" class="headerlink" title="12.盛最多水的容器"></a>12.盛最多水的容器</h3><p><img src="/img/1591868079911.png" alt="Alt text"></p>
<p><strong>双指针+贪心</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var maxArea = function (height) &#123;</span><br><span class="line">    function computeArea(x, y) &#123; //求积水面积方法</span><br><span class="line">        let temp = Math.min(height[x], height[y]);</span><br><span class="line">        return temp * (y - x);</span><br><span class="line">    &#125;</span><br><span class="line">    let left = 0;</span><br><span class="line">    let right = height.length - 1;</span><br><span class="line">    let max = 0;</span><br><span class="line">    while(left &lt; right)&#123;</span><br><span class="line">        max = Math.max(computeArea(left,right),max);</span><br><span class="line">        if(height[left] &lt; height[right])&#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return max;</span><br><span class="line">&#125;;</span><br><span class="line">********************************************************************************</span><br><span class="line">//自己的方法：求面积最大，从坐标最长开始，有短边的，改变短边坐标，math.max记录最大</span><br><span class="line">var maxArea = function (height) &#123;</span><br><span class="line">    let max = 0;  //记录最大面积</span><br><span class="line">    let l = 0; let r = height.length - 1;</span><br><span class="line">    let len = height.length - 1;  //起始和终点坐标长度</span><br><span class="line">    while (l &lt; r) &#123;</span><br><span class="line">        if (height[l] &lt;= height[r]) &#123;  //左边较小</span><br><span class="line">            max = Math.max(max, height[l] * len);  //纪录最大面积</span><br><span class="line">            l++;   //左边前进一位</span><br><span class="line">            len--; //长边短一位</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            max = Math.max(max, height[r] * len);</span><br><span class="line">            r--;</span><br><span class="line">            len--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return max;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>题目让我们查找某个数优先考虑二分查找，基础是排好序的数组，时间复杂度O(logn)</p>
<p>因为向下取整，所以左侧一定要+1，右侧看情况：</p>
<p>1.若要找的值在目标值左侧，如第一题，输入8，目标值2.82842，要找的是2，那么l&lt;=r; r=mid-1，return r，最后两指针一定重合执行最后一次; 2.若要找的值在目标值右侧，如第7题，[1,3,5,6]，目标值2，找到3对应的索引，l&lt;r; r=mid，return l或r都行;两指针一定相邻执行最后一次；3.若单纯找某值，默认使用l&lt;r结构；</p>
<p>边界问题：题5</p>
<h3 id="1-x-的平方根x"><a href="#1-x-的平方根x" class="headerlink" title="1.x 的平方根x*"></a>1.x 的平方根x*</h3><p><img src="/img/1591939607879.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//二分查找多是这个结构，while(l&lt;r),let mid=...</span><br><span class="line">var mySqrt = function(x) &#123;</span><br><span class="line">    let l = 0;</span><br><span class="line">    let r = x;</span><br><span class="line">    while(l &lt;= r)&#123;</span><br><span class="line">    //要向下取整</span><br><span class="line">        let mid = Math.floor((l + r) / 2);</span><br><span class="line">        let powerMin = mid * mid;</span><br><span class="line">        if(powerMin &gt; x)&#123;</span><br><span class="line">            r = mid - 1;</span><br><span class="line">        &#125;else if(powerMin &lt; x)&#123;</span><br><span class="line">            l = mid + 1;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //注意最后都要返回r</span><br><span class="line">    return r;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>原理在于总有一次在+1或者-1后左边界或者右边界会跨过真实的平方值，而跨过之后谁跨过就不会再发生变化直到l &gt; r，此时r指向的是真实平方值的整数部分</p>
<h3 id="2-寻找比目标字母大的最小字母x"><a href="#2-寻找比目标字母大的最小字母x" class="headerlink" title="2.寻找比目标字母大的最小字母x"></a>2.寻找比目标字母大的最小字母x</h3><p><img src="/img/1591943950399.png" alt="Alt text"></p>
<p>我的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var nextGreatestLetter = function (letters, target) &#123;</span><br><span class="line">    let ans = &apos;&apos;;</span><br><span class="line">    for (let i = 0; i &lt; letters.length; i++) &#123;</span><br><span class="line">        if (letters[i] &gt; target) &#123;  //可以直接比，无需转ASCII-str.charCodeAt()</span><br><span class="line">            ans = letters[i];</span><br><span class="line">            break;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (ans == &apos;&apos;) ans = letters[0];</span><br><span class="line">    return ans;</span><br><span class="line">&#125;;</span><br><span class="line">//时间复杂度O(n),可采用二分查找</span><br></pre></td></tr></table></figure>

<p>二分查找：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var nextGreatestLetter = function (letters, target) &#123;</span><br><span class="line">    let l = 0;</span><br><span class="line">    let h = letters.length - 1;</span><br><span class="line">    //因为h=mid没有-1所以只能用l &lt; h而不能取等否则会死循环</span><br><span class="line">    //最后退出循环的条件一定是l===h,此时l代表着唯一有可能满足条件的位置</span><br><span class="line">    //所以去判断l是否满足条件就可以判断是否存在这样的元素</span><br><span class="line">    while(l &lt; h)&#123;</span><br><span class="line">        let mid = Math.floor((l + r) / 2);</span><br><span class="line">        //注意此处是找到第一个大于target的值，所以是大于符号</span><br><span class="line">        if(letters[mid] &gt; target)&#123;</span><br><span class="line">        //这个值有可能就是第一个大于target的值，所以不-1</span><br><span class="line">            h = mid;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            l = mid + 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return letters[l] &gt; target ? letters[l] : letters[0];  //都小于目标值，循环返回第一个</span><br><span class="line">&#125;;</span><br><span class="line">//时间复杂度O(logn)</span><br></pre></td></tr></table></figure>

<h3 id="3-有序数组中的单一元素xx"><a href="#3-有序数组中的单一元素xx" class="headerlink" title="3.有序数组中的单一元素xx"></a>3.有序数组中的单一元素xx</h3><p><img src="/img/1591948604865.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var singleNonDuplicate = function(nums) &#123;</span><br><span class="line">    let l = 0;</span><br><span class="line">    let h = nums.length - 1;</span><br><span class="line">    while(l &lt; h)&#123;</span><br><span class="line">        let mid = l + Math.floor((h - l)/2);</span><br><span class="line">        if(mid % 2 === 1 )&#123;</span><br><span class="line">            mid--;</span><br><span class="line">        &#125;</span><br><span class="line">        if(nums[mid] === nums[mid + 1])&#123;</span><br><span class="line">            l = mid + 2;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            h = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return nums[l];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="4-第一个错误的版本"><a href="#4-第一个错误的版本" class="headerlink" title="4.第一个错误的版本"></a>4.第一个错误的版本</h3><p><img src="/img/1591948658858.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var solution = function(isBadVersion) &#123;</span><br><span class="line">    return function(n) &#123;</span><br><span class="line">        let l = 1;</span><br><span class="line">        let h = n;</span><br><span class="line">        while(l &lt; h)&#123;</span><br><span class="line">            let mid = Math.floor((l + h)/2);</span><br><span class="line">            if(isBadVersion(mid))&#123;</span><br><span class="line">                h = mid;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                l = mid + 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return l;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="5-寻找旋转排序数组中的最小值"><a href="#5-寻找旋转排序数组中的最小值" class="headerlink" title="5.寻找旋转排序数组中的最小值"></a>5.寻找旋转排序数组中的最小值</h3><p><img src="/img/1591951201805.png" alt="Alt text"></p>
<p>把这个数组看成两个部分，l和h各指向一个部分，最小值只能在右边那个部分，取mid发现若发现比nums[h]小则说明mid在l部分，要+1，否则说明mid在h部分并且可能是最小值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var findMin = function (nums) &#123;</span><br><span class="line">    let l = 0;</span><br><span class="line">    let h = nums.length - 1;</span><br><span class="line">    if(nums[0] &lt; nums[h]) return nums[0];</span><br><span class="line">    while (l &lt; h) &#123;            //此时l&lt;r，没有等号时，L进一，h不退，返回时就是nums[l]</span><br><span class="line">                               //有等号时，都会进位，l=mid+1;h=mid-1;返回nums[h+1]</span><br><span class="line">        let mid = Math.floor((l + h) / 2);</span><br><span class="line">        if(nums[mid] &gt; nums[h])&#123;</span><br><span class="line">            l = mid + 1;   //若L不进一，最后剩两位时，会死循环，例[4,5,6,7,0,1,2]</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            h = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return nums[l];  //最后l和r指针重合</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6-在排序数组中查找元素的第一个和最后一个位置"><a href="#6-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="6.在排序数组中查找元素的第一个和最后一个位置"></a>6.在排序数组中查找元素的第一个和最后一个位置</h3><p><img src="/img/1591953844248.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var searchRange = function (nums, target) &#123;</span><br><span class="line">    function binarySearch(nums, target) &#123;//第一个值为target的可能的位置</span><br><span class="line">        let l = 0;</span><br><span class="line">        //注意下标从nums.length开始，因为target+1的值可能比所有的值都大，而我们要找的是target+1的位置，所以target+1的位置是可能在nums.length的，所以要从nums.length开始</span><br><span class="line">        //并且mid的值在此处是不可能取到nums[length]的，因为是向下取整，r又至少比l大1，并且循环条件是不取等，所以r至少比mid大1</span><br><span class="line">        let r = nums.length;</span><br><span class="line">        while (l &lt; r) &#123;</span><br><span class="line">            let mid = l + Math.floor((r - l)/2);  //防溢出</span><br><span class="line">            if (nums[mid] &lt; target) &#123;</span><br><span class="line">                l = mid + 1;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                r = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //找到第一个值为target的下标</span><br><span class="line">    let index1 = binarySearch(nums,target);</span><br><span class="line">    if(nums[index1] !== target)&#123;</span><br><span class="line">        return [-1,-1];</span><br><span class="line">    &#125;</span><br><span class="line">    let index2 = binarySearch(nums,target + 1);</span><br><span class="line">    return [index1,index2 - 1];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="7-搜索插入位置"><a href="#7-搜索插入位置" class="headerlink" title="7.搜索插入位置"></a>7.搜索插入位置</h3><p><img src="/img/20210312_2.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var searchInsert = function (nums, target) &#123;</span><br><span class="line">    let len=nums.length;</span><br><span class="line">    if(target&gt;nums[len-1]) return len;   //最后一个元素单独判断</span><br><span class="line">    let l = 0, r = nums.length - 1;</span><br><span class="line">    while (l &lt; r) &#123;</span><br><span class="line">        let mid = Math.floor(l + ((r - l) / 2));  // 防止溢出 等同于(left + right)/2;</span><br><span class="line">        if (nums[mid] &lt; target) &#123;</span><br><span class="line">            l = mid+1;</span><br><span class="line">        &#125; else  &#123;</span><br><span class="line">            r = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return l;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="分治（先pass）"><a href="#分治（先pass）" class="headerlink" title="分治（先pass）"></a>分治（先pass）</h2><h3 id="1-为运算表达式设计优先级"><a href="#1-为运算表达式设计优先级" class="headerlink" title="1.为运算表达式设计优先级"></a>1.为运算表达式设计优先级</h3><p><img src="/img/1592015669804.png" alt="Alt text"></p>
<p>1.基本分治方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var diffWaysToCompute = function (input) &#123;</span><br><span class="line">    let len = input.length;</span><br><span class="line">    let ans = [];</span><br><span class="line">    for (let i = 0; i &lt; len; i++) &#123;</span><br><span class="line">        if (input[i] === &apos;+&apos; || input[i] === &apos;-&apos; || input[i] === &apos;*&apos;) &#123;</span><br><span class="line">            let l = diffWaysToCompute(input.substring(0, i));</span><br><span class="line">            let r = diffWaysToCompute(input.substring(i + 1));</span><br><span class="line">            for (let j = 0; j &lt; l.length; j++) &#123;</span><br><span class="line">                for (let k = 0; k &lt; r.length; k++) &#123;</span><br><span class="line">                    switch (input[i]) &#123;</span><br><span class="line">                        case &apos;+&apos;:</span><br><span class="line">                            ans.push(l[j] + r[k]);</span><br><span class="line">                            break;</span><br><span class="line">                        case &apos;-&apos;:</span><br><span class="line">                            ans.push(l[j] - r[k]);</span><br><span class="line">                            break;</span><br><span class="line">                        case &apos;*&apos;:</span><br><span class="line">                            ans.push(l[j] * r[k]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //如果全部都为数字，那就直接把这个字符串转换了过后放入数组</span><br><span class="line">    //也相当于递归边界</span><br><span class="line">    if(ans.length === 0)&#123;</span><br><span class="line">        ans.push(parseInt(input));</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>2.使用一个map记录每一个input的值防止重复递归</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var diffWaysToCompute = function (input) &#123;</span><br><span class="line">    let map = new Map();</span><br><span class="line">    function helper(input) &#123;</span><br><span class="line">        let temp = map.get(input);</span><br><span class="line">        if(temp) return temp;</span><br><span class="line">        let len = input.length;</span><br><span class="line">        let ans = [];</span><br><span class="line">        for (let i = 0; i &lt; len; i++) &#123;</span><br><span class="line">            if (input[i] === &apos;+&apos; || input[i] === &apos;-&apos; || input[i] === &apos;*&apos;) &#123;</span><br><span class="line">                let l = diffWaysToCompute(input.substring(0, i));</span><br><span class="line">                let r = diffWaysToCompute(input.substring(i + 1));</span><br><span class="line">                for (let j = 0; j &lt; l.length; j++) &#123;</span><br><span class="line">                    for (let k = 0; k &lt; r.length; k++) &#123;</span><br><span class="line">                        switch (input[i]) &#123;</span><br><span class="line">                            case &apos;+&apos;:</span><br><span class="line">                                ans.push(l[j] + r[k]);</span><br><span class="line">                                break;</span><br><span class="line">                            case &apos;-&apos;:</span><br><span class="line">                                ans.push(l[j] - r[k]);</span><br><span class="line">                                break;</span><br><span class="line">                            case &apos;*&apos;:</span><br><span class="line">                                ans.push(l[j] * r[k]);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (ans.length === 0) &#123;</span><br><span class="line">            ans.push(parseInt(input));</span><br><span class="line">        &#125;</span><br><span class="line">        map.set(input,ans);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">    return helper(input);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-不同的二叉搜索树-IIx"><a href="#2-不同的二叉搜索树-IIx" class="headerlink" title="2.不同的二叉搜索树 IIx"></a>2.不同的二叉搜索树 IIx</h3><p><img src="/img/1592018521874.png" alt="Alt text"></p>
<p>思路与上一个题类似</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">var generateTrees = function (n) &#123;</span><br><span class="line"></span><br><span class="line">  //如果n小于1则特判</span><br><span class="line">    if(n &lt; 1) return [];</span><br><span class="line"></span><br><span class="line">    function helper(l, r) &#123;//由l-r组成的二叉搜索树</span><br><span class="line">        let ans = [];</span><br><span class="line">        for (let i = l; i &lt;= r; i++) &#123;</span><br><span class="line">            let leftChildren = helper(l,i - 1);</span><br><span class="line">            let rightChildren = helper(i + 1,r);</span><br><span class="line">            for(let j = 0;j &lt; leftChildren.length;j++)&#123;</span><br><span class="line">                for(let k = 0;k &lt; rightChildren.length;k++)&#123;</span><br><span class="line">                    let root = new TreeNode(i);</span><br><span class="line">                    root.left = leftChildren[j];</span><br><span class="line">                    root.right = rightChildren[k];</span><br><span class="line">                    ans.push(root);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">//如果没有生成结点则要push一个null</span><br><span class="line">        if(ans.length === 0)&#123;</span><br><span class="line">            ans.push(null);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return helper(1,n);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h3><h4 id="1-二进制矩阵中的最短路径"><a href="#1-二进制矩阵中的最短路径" class="headerlink" title="1.二进制矩阵中的最短路径"></a>1.二进制矩阵中的最短路径</h4><p><img src="/img/1592033758255.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;number[][]&#125; grid</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> */</span><br><span class="line">var shortestPathBinaryMatrix = function (grid) &#123;</span><br><span class="line">    let directions = [[1, -1], [1, 0], [1, 1], [0, -1], [0, 1], [-1, -1], [-1, 0], [-1, 1]];</span><br><span class="line">    if (grid[0][0] === 1) return -1;</span><br><span class="line">    if(grid[0][0] === 0 &amp;&amp; grid.length === 1) return 1;</span><br><span class="line">    let queue = [];</span><br><span class="line">    queue.push([0, 0]);</span><br><span class="line">    let dis = 1;</span><br><span class="line">    while (queue.length !== 0) &#123;</span><br><span class="line">        let len = queue.length;</span><br><span class="line">        dis++;</span><br><span class="line">        for (let i = 0; i &lt; len; i++) &#123;</span><br><span class="line">            let head = queue.shift();</span><br><span class="line">            [x, y] = head;</span><br><span class="line">            for (let i = 0; i &lt; directions.length; i++) &#123;</span><br><span class="line">                let direction = directions[i];</span><br><span class="line">                [new_x, new_y] = [x + direction[0], y + direction[1]];</span><br><span class="line">                if (new_x === grid.length - 1 &amp;&amp; new_y === grid.length - 1 &amp;&amp; grid[new_x][new_y] === 0) &#123;</span><br><span class="line">                    return dis;</span><br><span class="line">                &#125;</span><br><span class="line">                if (new_x &gt;= 0 &amp;&amp; new_x &lt; grid.length &amp;&amp; new_y &gt;= 0 &amp;&amp; new_y &lt; grid.length &amp;&amp; grid[new_x][new_y] === 0) &#123;</span><br><span class="line">                    queue.push([new_x, new_y]);</span><br><span class="line">                    grid[new_x][new_y] = 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-完全平方数x"><a href="#2-完全平方数x" class="headerlink" title="2.完全平方数x"></a>2.完全平方数x</h4><p><img src="/img/1592036141771.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;number&#125; n</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> */</span><br><span class="line">var numSquares = function (n) &#123;</span><br><span class="line">    //首先打表获得小于等于n的完全平方数</span><br><span class="line">    function generateSquares(n) &#123;</span><br><span class="line">        let squares = [];</span><br><span class="line">        for (let i = 1; i * i &lt;= n; i++) &#123;</span><br><span class="line">            squares.push(i * i);</span><br><span class="line">        &#125;</span><br><span class="line">        return squares;</span><br><span class="line">    &#125;</span><br><span class="line">    let squares = generateSquares(n);</span><br><span class="line"></span><br><span class="line">    //再BFS找到个数</span><br><span class="line">    let q = [];</span><br><span class="line">    let marked = [];</span><br><span class="line">    q.push(n);</span><br><span class="line">    marked[n] = false;</span><br><span class="line">    let ans = 0;</span><br><span class="line"></span><br><span class="line">    while (q.length !== 0) &#123;</span><br><span class="line">        let len = q.length;</span><br><span class="line">        ans++;</span><br><span class="line">        for (let i = 0; i &lt; len; i++) &#123;</span><br><span class="line">            let head = q.shift();</span><br><span class="line">            for (let j = 0; j &lt; squares.length; j++) &#123;</span><br><span class="line">                let temp = head - squares[j];</span><br><span class="line">                //因为递增所以一旦开始小于0后面的也小于0</span><br><span class="line">                if(temp &lt; 0)&#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                if(temp === 0)&#123;</span><br><span class="line">                    return ans;</span><br><span class="line">                &#125;</span><br><span class="line">                if(marked[temp] === undefined)&#123;</span><br><span class="line">                    marked[temp] = false;</span><br><span class="line">                    q.push(temp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="3-单词接龙x"><a href="#3-单词接龙x" class="headerlink" title="3.单词接龙x"></a>3.单词接龙x</h4><p><img src="/img/1592039666051.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;string&#125; beginWord</span><br><span class="line"> * @param &#123;string&#125; endWord</span><br><span class="line"> * @param &#123;string[]&#125; wordList</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> */</span><br><span class="line">var ladderLength = function (beginWord, endWord, wordList) &#123;</span><br><span class="line">    wordList.push(beginWord);</span><br><span class="line">    //先判断一下endWord在词典中的位置，如果没有返回0</span><br><span class="line">    let end = 0;</span><br><span class="line">    let start = wordList.length - 1;</span><br><span class="line">    for (; end &lt; wordList.length; end++) &#123;</span><br><span class="line">        if (wordList[end] === endWord) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (end === wordList.length) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	//再进行BFS</span><br><span class="line">    let g = buildGraphic(wordList);//打一张临接表存储</span><br><span class="line">    let q = [];</span><br><span class="line">    let marked = [];</span><br><span class="line">    q.push(start);</span><br><span class="line">    marked[start] = false;</span><br><span class="line">    let ans = 0;</span><br><span class="line">    while (q.length !== 0) &#123;</span><br><span class="line">        ans++;</span><br><span class="line">        let len = q.length;</span><br><span class="line">        for (let i = 0; i &lt; len; i++) &#123;</span><br><span class="line">            let f = q.shift();</span><br><span class="line">            if (f === end) &#123;</span><br><span class="line">                return ans;</span><br><span class="line">            &#125;</span><br><span class="line">            for (let temp of g[f]) &#123;</span><br><span class="line">                if (marked[temp] === undefined) &#123;</span><br><span class="line">                    marked[temp] = false;</span><br><span class="line">                    q.push(temp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //打表生成一个邻接表来存储每一个在wordList中的单词的连接关系</span><br><span class="line">    function buildGraphic(wordList) &#123;</span><br><span class="line">        let graph = [];</span><br><span class="line">        for (let i = 0; i &lt; wordList.length; i++) &#123;</span><br><span class="line">            graph[i] = [];</span><br><span class="line">            for (let j = 0; j &lt; wordList.length; j++) &#123;</span><br><span class="line">                if (isConnect(wordList[i], wordList[j])) &#123;//如果相连</span><br><span class="line">                    graph[i].push(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return graph;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //判断两个字符串能否改变一个字符就相等</span><br><span class="line">    //注意：完全相等返回false</span><br><span class="line">    function isConnect(x, y) &#123;</span><br><span class="line">        let temp = 0;</span><br><span class="line">        for (let i = 0; i &lt; x.length; i++) &#123;</span><br><span class="line">            if (x[i] !== y[i]) &#123;</span><br><span class="line">                if (temp &gt; 1) &#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    temp++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return temp === 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><h4 id="1-岛屿的最大面积"><a href="#1-岛屿的最大面积" class="headerlink" title="1.岛屿的最大面积*"></a>1.岛屿的最大面积*</h4><p><img src="/img/1592112641121.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var maxAreaOfIsland = function (grid) &#123;</span><br><span class="line">    directions = [[1, 0], [-1, 0], [0, 1], [0, -1]];</span><br><span class="line">    let m = grid.length;</span><br><span class="line">    let n = grid[0].length;</span><br><span class="line">    let result = 0;</span><br><span class="line">    for (let i = 0; i &lt; m; i++) &#123;</span><br><span class="line">        for (let j = 0; j &lt; n; j++) &#123;</span><br><span class="line">            result = Math.max(result, dfs(grid, i, j));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line"></span><br><span class="line">    function dfs(grid, x, y) &#123;</span><br><span class="line">        if (x &lt; 0 || y &lt; 0 || x &gt;= grid.length || y &gt;= grid[0].length || grid[x][y] === 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        grid[x][y] = 0;</span><br><span class="line">        let ans = 1;</span><br><span class="line">        for (let direction of directions) &#123;</span><br><span class="line">            let new_x = x + direction[0];</span><br><span class="line">            let new_y = y + direction[1];</span><br><span class="line">            ans += dfs(grid, new_x, new_y);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-岛屿数量"><a href="#2-岛屿数量" class="headerlink" title="2.岛屿数量"></a>2.岛屿数量</h4><p><img src="/img/1592113643704.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;character[][]&#125; grid</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> */</span><br><span class="line">var numIslands = function (grid) &#123;</span><br><span class="line"></span><br><span class="line">    directions = [[1, 0], [-1, 0], [0, 1], [0, -1]];</span><br><span class="line">    let m = grid.length;</span><br><span class="line">    let n = grid[0] ? grid[0].length : 0;</span><br><span class="line">    let result = 0;</span><br><span class="line">    for (let i = 0; i &lt; m; i++) &#123;</span><br><span class="line">        for (let j = 0; j &lt; n; j++) &#123;</span><br><span class="line">            result += dfs(grid, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line"></span><br><span class="line">    function dfs(grid, x, y) &#123;</span><br><span class="line">        if (x &lt; 0 || y &lt; 0 || x &gt;= m || y &gt;= n || grid[x][y] === &apos;0&apos;) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        grid[x][y] = &apos;0&apos;;</span><br><span class="line">        for (let direction of directions) &#123;</span><br><span class="line">            let new_x = x + direction[0];</span><br><span class="line">            let new_y = y + direction[1];</span><br><span class="line">            dfs(grid, new_x, new_y);</span><br><span class="line">        &#125;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="3-朋友圈x"><a href="#3-朋友圈x" class="headerlink" title="3.朋友圈x"></a>3.朋友圈x</h4><p><img src="/img/1592115136407.png" alt="Alt text"></p>
<p>注意<br>1:这个是一个nXn的对称矩阵<br>2:朋友的传递看的是整行或整列不是矩阵相邻</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;number[][]&#125; M</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> */</span><br><span class="line">var findCircleNum = function (M) &#123;</span><br><span class="line">    let len = M.length;</span><br><span class="line">    let result = 0;</span><br><span class="line">    let visited = [];</span><br><span class="line">    for (let i = 0; i &lt; len; i++) &#123;</span><br><span class="line">        if (visited[i] === undefined) &#123;</span><br><span class="line">            dfs(M, i);</span><br><span class="line">            result++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line"></span><br><span class="line">    function dfs(M, x) &#123;</span><br><span class="line">        visited[x] = true;</span><br><span class="line">        for (let i = 0; i &lt; len; i++) &#123;</span><br><span class="line">            if (M[x][i] === 1 &amp;&amp; visited[i] === undefined) &#123;</span><br><span class="line">                M[x][i] = 0;</span><br><span class="line">                dfs(M, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="4-被围绕的区域x"><a href="#4-被围绕的区域x" class="headerlink" title="4.被围绕的区域x"></a>4.被围绕的区域x</h4><p><img src="/img/1592117125027.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;character[][]&#125; board</span><br><span class="line"> * @return &#123;void&#125; Do not return anything, modify board in-place instead.</span><br><span class="line"> */</span><br><span class="line">var solve = function (board) &#123;</span><br><span class="line">    let directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];</span><br><span class="line">    let m = board.length;</span><br><span class="line">    let n = board[0] ? board[0].length : 0;</span><br><span class="line">    for (let i = 0; i &lt; m; i++) &#123;</span><br><span class="line">        dfs(board, i, 0);</span><br><span class="line">        dfs(board, i, n - 1);</span><br><span class="line">    &#125;</span><br><span class="line">    for (let i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        dfs(board, 0, i);</span><br><span class="line">        dfs(board, m - 1, i);</span><br><span class="line">    &#125;</span><br><span class="line">    for (let i = 0; i &lt; m; i++) &#123;</span><br><span class="line">        for (let j = 0; j &lt; n; j++) &#123;</span><br><span class="line">            if (board[i][j] === &apos;T&apos;) &#123;</span><br><span class="line">                board[i][j] = &apos;O&apos;;</span><br><span class="line">            &#125; else if (board[i][j] === &apos;O&apos;) &#123;</span><br><span class="line">                board[i][j] = &apos;X&apos;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return board;</span><br><span class="line"></span><br><span class="line">    function dfs(board, x, y) &#123;</span><br><span class="line">        if (x &lt; 0 || x &gt;= m || y &lt; 0 || y &gt;= n || board[x][y] !== &apos;O&apos;) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        board[x][y] = &apos;T&apos;;</span><br><span class="line">        for (let direction of directions) &#123;</span><br><span class="line">            dfs(board, x + direction[0], y + direction[1]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注意：<br>1:边界上的O和与边界O相连的O是不会被围绕的，剩下的都是会被围绕的<br>2:所以可以先求出所有边界O组成的联通区域先设成T，再遍历一次矩阵把O改为X，T改为O</p>
<h4 id="5-太平洋大西洋水流问题x"><a href="#5-太平洋大西洋水流问题x" class="headerlink" title="5.太平洋大西洋水流问题x"></a>5.太平洋大西洋水流问题x</h4><p><img src="/img/1592122699534.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;number[][]&#125; matrix</span><br><span class="line"> * @return &#123;number[][]&#125;</span><br><span class="line"> */</span><br><span class="line">var pacificAtlantic = function (matrix) &#123;</span><br><span class="line">    if (matrix == null || matrix.length === 0) &#123;</span><br><span class="line">        return [];</span><br><span class="line">    &#125;</span><br><span class="line">    let directions = [[1, 0], [-1, 0], [0, 1], [0, -1]];</span><br><span class="line">    let m = matrix.length;</span><br><span class="line">    let n = matrix[0].length;</span><br><span class="line">    let ans = [];</span><br><span class="line">    let canReachPcf = generateArray(m, n);</span><br><span class="line">    let canReachAlt = generateArray(m, n);</span><br><span class="line">    for (let i = 0; i &lt; m; i++) &#123;</span><br><span class="line">        dfs(i, 0, canReachPcf);</span><br><span class="line">        dfs(i, n - 1, canReachAlt);</span><br><span class="line">    &#125;</span><br><span class="line">    for (let i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        dfs(0, i, canReachPcf);</span><br><span class="line">        dfs(m - 1, i, canReachAlt);</span><br><span class="line">    &#125;</span><br><span class="line">    for (let i = 0; i &lt; m; i++) &#123;</span><br><span class="line">        for (let j = 0; j &lt; n; j++) &#123;</span><br><span class="line">            if (canReachPcf[i][j] === true &amp;&amp; canReachAlt[i][j] === true) &#123;</span><br><span class="line">                ans.push([i, j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return ans;</span><br><span class="line"></span><br><span class="line">    function generateArray(m, n) &#123;</span><br><span class="line">        let res = [];</span><br><span class="line">        for (let i = 0; i &lt; m; i++) &#123;</span><br><span class="line">            res.push([]);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function dfs(x, y, canReach) &#123;</span><br><span class="line"></span><br><span class="line">        if (canReach[x][y] === true) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        canReach[x][y] = true;</span><br><span class="line">        for (let direction of directions) &#123;</span><br><span class="line">            let new_x = x + direction[0];</span><br><span class="line">            let new_y = y + direction[1];</span><br><span class="line">            if (new_x &lt; 0 || new_x &gt;= m || new_y &lt; 0 || new_y &gt;= n || matrix[x][y] &gt; matrix[new_x][new_y]) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            dfs(new_x, new_y, canReach);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注意二维数组的创建问题<br>同样是从边缘出发，找到能流到边缘的类</p>
<h2 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h2><p>一种优先搜索算法，枚举搜索尝试过程中找到解决方法，时间复杂度O(2^n)。</p>
<h4 id="1-电话号码的字母组合"><a href="#1-电话号码的字母组合" class="headerlink" title="1.电话号码的字母组合*"></a>1.电话号码的字母组合*</h4><p><img src="/img/1592186167929.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var letterCombinations = function(digits) &#123;</span><br><span class="line">    if(digits.length === 0) return [];</span><br><span class="line">    let hash = [0,1,&apos;abc&apos;,&apos;def&apos;,&apos;ghi&apos;,&apos;jkl&apos;,&apos;mno&apos;,&apos;pqrs&apos;,&apos;tuv&apos;,&apos;wxyz&apos;];</span><br><span class="line">    let ans = [];</span><br><span class="line">    let temp = [];</span><br><span class="line">    dfs(digits);</span><br><span class="line">    return ans;</span><br><span class="line">    </span><br><span class="line">    //写个递归函数</span><br><span class="line">    function dfs(digits)&#123;</span><br><span class="line">        //给一个递归终止条件</span><br><span class="line">        if(digits.length === 0)&#123;</span><br><span class="line">            ans.push(temp.join(&apos;&apos;));  //数组转字符串</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        let c = digits[0];</span><br><span class="line">        let s = hash[parseInt(c)];</span><br><span class="line"></span><br><span class="line">        let len = s.length;</span><br><span class="line">        for(let i = 0;i &lt; len;i++)&#123;</span><br><span class="line">            temp.push(s[i]);</span><br><span class="line">            dfs(digits.substring(1)); //(start,end)不包括end截取</span><br><span class="line">            temp.pop();  //在原数组上删除最后一个，若有变量承接，承接删除的元素</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-复原IP地址"><a href="#2-复原IP地址" class="headerlink" title="2.复原IP地址*"></a>2.复原IP地址*</h4><p><img src="/img/1592188363333.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var restoreIpAddresses = function(s) &#123;</span><br><span class="line">    let ans = [];</span><br><span class="line">    let temp = [];</span><br><span class="line">    backTracking(s,0);</span><br><span class="line">    return ans;</span><br><span class="line">    </span><br><span class="line">    function backTracking(s,intNumber)&#123;</span><br><span class="line">		//若已有4组数且无剩余数字则添加返回，否则结束函数执行</span><br><span class="line">        if(intNumber === 4)&#123;</span><br><span class="line">            if(s.length === 0)&#123;</span><br><span class="line">                ans.push(temp.join(&apos;.&apos;));</span><br><span class="line">            &#125;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        let len = s.length;</span><br><span class="line">        for(let i = 0;i &lt; len;i++)&#123;</span><br><span class="line">            let part = s.substring(0,i + 1);  //此处注意</span><br><span class="line">            //注意不能有两位数是0开头的</span><br><span class="line">            if(part[0] === &apos;0&apos; &amp;&amp; part.length &gt; 1)&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            part = parseInt(part);</span><br><span class="line">            //&gt;255则剪枝</span><br><span class="line">            if(part &gt; 255)&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            temp.push(part);</span><br><span class="line">            backTracking(s.substring(i + 1),intNumber + 1);</span><br><span class="line">            temp.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="3-单词搜索x"><a href="#3-单词搜索x" class="headerlink" title="3.单词搜索x"></a>3.单词搜索x</h4><p><img src="/img/1592291237992.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;character[][]&#125; board</span><br><span class="line"> * @param &#123;string&#125; word</span><br><span class="line"> * @return &#123;boolean&#125;</span><br><span class="line"> */</span><br><span class="line">var exist = function (board, word) &#123;</span><br><span class="line">    let directions = [[1, 0], [-1, 0], [0, 1], [0, -1]];</span><br><span class="line">    let m = board.length;</span><br><span class="line">    let n = board[0].length;</span><br><span class="line">    let visited = generateArray(m, n);</span><br><span class="line">    //遍历整个board利用回溯法解决该问题</span><br><span class="line">    for (let i = 0; i &lt; m; i++) &#123;</span><br><span class="line">        for (let j = 0; j &lt; n; j++) &#123;</span><br><span class="line">            if (backtracking(visited, i, j, 0)) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //以某一个字母开始能不能通过DFS找到字符串的方式</span><br><span class="line">    function backtracking(visited, i, j, index) &#123;</span><br><span class="line"></span><br><span class="line">        if (i &gt;= m || i &lt; 0 || j &gt;= n || j &lt; 0 || visited[i][j] === true || board[i][j] !== word[index]) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //为true的递归边界</span><br><span class="line">        if (index === word.length - 1) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        visited[i][j] = true;</span><br><span class="line"></span><br><span class="line">        for (let d of directions) &#123;</span><br><span class="line">            let new_i = i + d[0];</span><br><span class="line">            let new_j = j + d[1];</span><br><span class="line">            if (backtracking(visited, new_i, new_j, index + 1)) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //因为是有可能从一个起点开始只能满足部分的要求，所以如果这个点不行的话要把visited修改为false;</span><br><span class="line">        visited[i][j] = false;</span><br><span class="line"></span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function generateArray(m, n) &#123;</span><br><span class="line">        let res = [];</span><br><span class="line">        for (let i = 0; i &lt; m; i++) &#123;</span><br><span class="line">            res.push(new Array(n).fill(false));</span><br><span class="line">        &#125;</span><br><span class="line">        //记得返回</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="4-二叉树的所有路径"><a href="#4-二叉树的所有路径" class="headerlink" title="4.二叉树的所有路径**"></a>4.二叉树的所有路径**</h4><p><img src="/img/1592293121431.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var binaryTreePaths = function(root) &#123;</span><br><span class="line">    let ans = [];</span><br><span class="line">    let temp = [];</span><br><span class="line">    helper(root);</span><br><span class="line">    return ans;</span><br><span class="line"></span><br><span class="line">    //回溯：回溯的本质就是遍历，就是在遍历的过程中去增加一些条件来筛选排序或者返回到上一层</span><br><span class="line">    //这种依托于另外一个功能的实现，在这个实现的基础上进行调整或者功能的组合在树中是应用得非常广泛的</span><br><span class="line">    function helper(root)&#123;</span><br><span class="line">        if(!root)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if(!root.left &amp;&amp; !root.right)&#123;</span><br><span class="line">            temp.push(root.val);</span><br><span class="line">            ans.push(temp.join(&quot;-&gt;&quot;));</span><br><span class="line">            temp.pop();</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        temp.push(root.val);</span><br><span class="line">        helper(root.left);</span><br><span class="line">        helper(root.right);</span><br><span class="line">        temp.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*******************************************************************************</span><br><span class="line">//前序遍历更简单点</span><br><span class="line">var binaryTreePaths = function (root) &#123;</span><br><span class="line">    let ans = [];</span><br><span class="line">    function dfs(root, path) &#123;  //传了参数，就不需要剪枝了，每层函数path不同的</span><br><span class="line">        if (root) &#123;</span><br><span class="line">            path += root.val.toString();</span><br><span class="line">            if (root.left == null &amp;&amp; root.right == null) &#123;</span><br><span class="line">                ans.push(path);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                path += &apos;-&gt;&apos;;</span><br><span class="line">                dfs(root.left, path);</span><br><span class="line">                dfs(root.right, path);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(root, &apos;&apos;);</span><br><span class="line">    return ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="5-全排列"><a href="#5-全排列" class="headerlink" title="5.全排列"></a>5.全排列</h4><p><img src="/img/1592294642841.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var permute = function (nums) &#123;</span><br><span class="line">    let len = nums.length;</span><br><span class="line">    let pos = new Array(len).fill(0);</span><br><span class="line">    let temp = [];</span><br><span class="line">    let ans = [];</span><br><span class="line">    backtracking(0);//添加参数</span><br><span class="line">    return ans;</span><br><span class="line"></span><br><span class="line">    function backtracking(index) &#123;</span><br><span class="line">        if(index &gt;= len)&#123;</span><br><span class="line">            //注意push进去的是指针，要重新创建一个一样的数组放进去才行</span><br><span class="line">            let t = temp.slice(0);</span><br><span class="line">            ans.push(t);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (let i = 0; i &lt; len; i++) &#123;</span><br><span class="line">            if(pos[i] === 0)&#123;</span><br><span class="line">                temp[i] = nums[index];</span><br><span class="line">                pos[i] = 1;</span><br><span class="line">                backtracking(index + 1);</span><br><span class="line">                pos[i] = 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="6-有重复值的全排列"><a href="#6-有重复值的全排列" class="headerlink" title="6.有重复值的全排列"></a>6.有重复值的全排列</h4><p><img src="/img/1592302524401.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var permuteUnique = function (nums) &#123;</span><br><span class="line">    let len = nums.length;</span><br><span class="line">    let visited = new Array(len).fill(0);</span><br><span class="line">    nums.sort(function(x,y)&#123;</span><br><span class="line">        return x - y;</span><br><span class="line">    &#125;)</span><br><span class="line">    let ans = [];</span><br><span class="line">    let temp = [];</span><br><span class="line">    backtracking(0);</span><br><span class="line">    return ans;</span><br><span class="line"></span><br><span class="line">    function backtracking(index) &#123;</span><br><span class="line">        if (index &gt;= len) &#123;</span><br><span class="line">            ans.push(temp.slice(0));</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //对index位选一个数字放进去</span><br><span class="line">        for (let i = 0; i &lt; len; i++) &#123;</span><br><span class="line">            // 防止重复</span><br><span class="line">            if (i !== 0 &amp;&amp; nums[i] === nums[i - 1] &amp;&amp; !visited[i - 1]) &#123;</span><br><span class="line">                continue;  </span><br><span class="line">            &#125;</span><br><span class="line">            //如果下标为i的数字没有放进去</span><br><span class="line">            if (visited[i] === 0) &#123;</span><br><span class="line">                visited[i] = 1;</span><br><span class="line">                temp.push(nums[i]);</span><br><span class="line">                //然后递归排下一个位置</span><br><span class="line">                backtracking(index + 1);</span><br><span class="line">                temp.pop();</span><br><span class="line">                visited[i] = 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="7-组合"><a href="#7-组合" class="headerlink" title="7.组合"></a>7.组合</h4><p><img src="/img/1592664433672.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var combine = function (n, k) &#123;</span><br><span class="line">    let result = [];</span><br><span class="line">    let temp = [];</span><br><span class="line">    backtracking(n, 1, 1 ,k);</span><br><span class="line">    return result;</span><br><span class="line">    </span><br><span class="line">    function backtracking(n, num, start, k) &#123;</span><br><span class="line">        if (num &gt; k) &#123;</span><br><span class="line">            result.push(temp.slice(0));</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (let i = start; i &lt;= n; i++) &#123;</span><br><span class="line">            temp.push(i);</span><br><span class="line">            backtracking(n, num + 1, i + 1, k);</span><br><span class="line">            temp.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>递归从这一次的数字+1开始，即start = i + 1</p>
<h4 id="8-组合求和"><a href="#8-组合求和" class="headerlink" title="8.组合求和"></a>8.组合求和</h4><p><img src="/img/1592719856281.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;number[]&#125; candidates</span><br><span class="line"> * @param &#123;number&#125; target</span><br><span class="line"> * @return &#123;number[][]&#125;</span><br><span class="line"> */</span><br><span class="line">var combinationSum = function(candidates, target) &#123;</span><br><span class="line">    candidates.sort(function(x,y)&#123;</span><br><span class="line">        return x - y;</span><br><span class="line">    &#125;)</span><br><span class="line">    let len = candidates.length;</span><br><span class="line">    let temp = [];</span><br><span class="line">    let ans = [];</span><br><span class="line">    let marked = new Array(len).fill(0);</span><br><span class="line">    backtracking(0,0);</span><br><span class="line">    return ans;</span><br><span class="line"></span><br><span class="line">    function backtracking(sum,start)&#123;</span><br><span class="line">        if(sum === target)&#123;</span><br><span class="line">            ans.push(temp.slice(0));</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if(sum &gt; target) return;</span><br><span class="line">        for(let i  = start;i &lt; len;i++)&#123;</span><br><span class="line">            if(i &gt; 0 &amp;&amp; candidates[i] === candidates[i-1] &amp;&amp; marked[i - 1] === 0)&#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            marked[i] = 1;     </span><br><span class="line">            temp.push(candidates[i]);</span><br><span class="line">            backtracking(sum + candidates[i],i);</span><br><span class="line">            temp.pop();</span><br><span class="line">            marked[i] = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="9-组合总和-IIx"><a href="#9-组合总和-IIx" class="headerlink" title="9.组合总和 IIx"></a>9.组合总和 IIx</h4><p><img src="/img/1592667119982.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;number[]&#125; candidates</span><br><span class="line"> * @param &#123;number&#125; target</span><br><span class="line"> * @return &#123;number[][]&#125;</span><br><span class="line"> */</span><br><span class="line">var combinationSum2 = function (candidates, target) &#123;</span><br><span class="line">    let temp = [];</span><br><span class="line">    let ans = [];</span><br><span class="line">    let len = candidates.length;</span><br><span class="line">    let marked = new Array(len).fill(0);</span><br><span class="line"></span><br><span class="line">    candidates.sort(function (x, y) &#123;</span><br><span class="line">        return x - y;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    backtracking(0, 0);</span><br><span class="line"></span><br><span class="line">    return ans;</span><br><span class="line"></span><br><span class="line">    function backtracking(start, sum) &#123;</span><br><span class="line"></span><br><span class="line">        if (sum === target) &#123;</span><br><span class="line">            ans.push(temp.slice(0));</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        for (let i = start; i &lt; len; i++) &#123;</span><br><span class="line">            if (i &gt; 0 &amp;&amp; candidates[i - 1] === candidates[i] &amp;&amp; marked[i - 1] === 0) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            if (sum &lt; target) &#123;</span><br><span class="line">                temp.push(candidates[i]);</span><br><span class="line">                sum += candidates[i];</span><br><span class="line">                marked[i] = 1;</span><br><span class="line">                backtracking(i + 1, sum);</span><br><span class="line">                temp.pop();</span><br><span class="line">                sum -= candidates[i];</span><br><span class="line">                marked[i] = 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="10-组合总和-III"><a href="#10-组合总和-III" class="headerlink" title="10.组合总和 III"></a>10.组合总和 III</h4><p><img src="/img/1592667842937.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;number&#125; k</span><br><span class="line"> * @param &#123;number&#125; n</span><br><span class="line"> * @return &#123;number[][]&#125;</span><br><span class="line"> */</span><br><span class="line">var combinationSum3 = function (k, n) &#123;</span><br><span class="line">    let result = [];</span><br><span class="line">    let temp = [];</span><br><span class="line"></span><br><span class="line">    backtracking(n, 0, 1, k, 0);</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    function backtracking(n, num, start, k, sum) &#123;</span><br><span class="line"></span><br><span class="line">        if (num === k) &#123;</span><br><span class="line">            if (sum === n) &#123;</span><br><span class="line">                result.push(temp.slice(0));</span><br><span class="line">            &#125;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (sum &gt; n) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (let i = start; i &lt;= 9; i++) &#123;</span><br><span class="line">            if (sum &lt; n) &#123;</span><br><span class="line">                temp.push(i);</span><br><span class="line">                backtracking(n, num + 1, i + 1, k, sum + i);</span><br><span class="line">                temp.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="11-子集"><a href="#11-子集" class="headerlink" title="11.子集"></a>11.子集</h4><p><img src="/img/1592668339024.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;number[]&#125; nums</span><br><span class="line"> * @return &#123;number[][]&#125;</span><br><span class="line"> */</span><br><span class="line">var subsets = function(nums) &#123;</span><br><span class="line">    let temp = [];</span><br><span class="line">    let ans = [];</span><br><span class="line">    let len = nums.length;</span><br><span class="line"></span><br><span class="line">    backtracking(0);</span><br><span class="line"></span><br><span class="line">    return ans;</span><br><span class="line"></span><br><span class="line">    function backtracking(i)&#123;</span><br><span class="line">        if(i === len)&#123;</span><br><span class="line">            ans.push(temp.slice(0));</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        temp.push(nums[i]);</span><br><span class="line">        backtracking(i + 1);</span><br><span class="line">        temp.pop();</span><br><span class="line">        backtracking(i + 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="12-子集-II"><a href="#12-子集-II" class="headerlink" title="12.子集 II"></a>12.子集 II</h4><p><img src="/img/1592669677344.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;number[]&#125; nums</span><br><span class="line"> * @return &#123;number[][]&#125;</span><br><span class="line"> */</span><br><span class="line">var subsetsWithDup = function (nums) &#123;</span><br><span class="line">    nums.sort(function (x, y) &#123;</span><br><span class="line">        return x - y;</span><br><span class="line">    &#125;)</span><br><span class="line">    let len = nums.length;</span><br><span class="line">    let temp = [];</span><br><span class="line">    let ans = [];</span><br><span class="line">    let marked = new Array(len).fill(0);</span><br><span class="line"></span><br><span class="line">    backtracking(0,0);</span><br><span class="line"></span><br><span class="line">    return ans;</span><br><span class="line"></span><br><span class="line">    function backtracking(k,start) &#123;//已经放了k个位置和起始下标</span><br><span class="line">        if(k === len)&#123;</span><br><span class="line">            ans.push(temp.slice(0));</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (let i = start; i &lt;= len; i++) &#123;</span><br><span class="line"></span><br><span class="line">            if(i &gt; 0 &amp;&amp; nums[i] === nums[i - 1] &amp;&amp; marked[i - 1] === 0)&#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (i === len) &#123;</span><br><span class="line">                backtracking(k + 1,i);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                temp.push(nums[i]);</span><br><span class="line">                marked[i] = 1;</span><br><span class="line">                backtracking(k + 1, i + 1);</span><br><span class="line">                temp.pop();</span><br><span class="line">                marked[i] = 0;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>重复元素的处理套路，先排序，如果这个数和前一个相等并且前一个没有用到则跳过避免重复，这里使用了一个i === len来判断是否需要在k位置放入元素</p>
<h4 id="13-分割回文串"><a href="#13-分割回文串" class="headerlink" title="13.分割回文串"></a>13.分割回文串</h4><p><img src="/img/1592751478881.png" alt="Alt text"><br>方法1: 使用了回溯法，遍历每一个子字符串长度为1，2，3…情况<br>即第一个字符串长度1，2，3…len<br>第二个为2,3,4…len<br>…</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;string&#125; s</span><br><span class="line"> * @return &#123;string[][]&#125;</span><br><span class="line"> */</span><br><span class="line">var partition = function (s) &#123;</span><br><span class="line">    let temp = [];</span><br><span class="line">    let ans = [];</span><br><span class="line">    let len = s.length;</span><br><span class="line"></span><br><span class="line">    backtracking(0, len - 1);</span><br><span class="line"></span><br><span class="line">    return ans;</span><br><span class="line"></span><br><span class="line">    function backtracking(start, end) &#123;</span><br><span class="line">        if (start &gt; end) &#123;</span><br><span class="line">            ans.push(temp.slice(0));</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (let i = start; i &lt;= end; i++) &#123;</span><br><span class="line">            if (isPalindrome(start, i)) &#123;</span><br><span class="line">                temp.push(s.slice(start, i + 1));</span><br><span class="line">                backtracking(i + 1, end);</span><br><span class="line">                temp.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function isPalindrome(start, i) &#123;</span><br><span class="line">        while (start &lt; i) &#123;</span><br><span class="line">            if (s[start] !== s[i]) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            start++;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>方法2:分治</p>
<blockquote>
<p>将大问题分解为小问题，利用小问题的结果，解决当前大问题。</p>
</blockquote>
<blockquote>
<p>这道题的话，举个例子。</p>
</blockquote>
<blockquote>
<p>aabb<br>先考虑在第 1 个位置切割，a | abb<br>这样我们只需要知道 abb 的所有结果，然后在所有结果的头部把 a 加入<br>abb 的所有结果就是 [a b b] [a bb]<br>每个结果头部加入 a，就是 [a a b b] [a a bb]</p>
</blockquote>
<blockquote>
<p>aabb<br>再考虑在第 2 个位置切割，aa | bb<br>这样我们只需要知道 bb 的所有结果，然后在所有结果的头部把 aa 加入<br>bb 的所有结果就是 [b b] [bb]<br>每个结果头部加入 aa,就是 [aa b b] [aa bb]</p>
</blockquote>
<blockquote>
<p>aabb<br>再考虑在第 3 个位置切割，aab|b<br>因为 aab 不是回文串，所有直接跳过</p>
</blockquote>
<blockquote>
<p>aabb<br>再考虑在第 4 个位置切割，aabb |<br>因为 aabb 不是回文串，所有直接跳过</p>
</blockquote>
<blockquote>
<p>最后所有的结果就是所有的加起来<br>[a a b b] [a a bb] [aa b b] [aa bb]</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;string&#125; s</span><br><span class="line"> * @return &#123;string[][]&#125;</span><br><span class="line"> */</span><br><span class="line">var partition = function (s) &#123;</span><br><span class="line">    return partitionHelper(s);</span><br><span class="line"></span><br><span class="line">    function partitionHelper(s) &#123;</span><br><span class="line"></span><br><span class="line">        let ans = [];</span><br><span class="line">        let len = s.length;</span><br><span class="line"></span><br><span class="line">        for (let i = 0; i &lt; len; i++) &#123;</span><br><span class="line">            let l = s.slice(0, i + 1);</span><br><span class="line">            if (isPalindrome(l) === false) continue;</span><br><span class="line">            let r = partitionHelper(s.slice(i + 1, len));</span><br><span class="line">            for (let j = 0; j &lt; r.length; j++) &#123;</span><br><span class="line">                r[j].unshift(l);</span><br><span class="line">                let temp = r[j];</span><br><span class="line">                ans.push(temp.slice(0));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (ans.length === 0) ans.push([]);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    function isPalindrome(s) &#123;</span><br><span class="line">        let start = 0;</span><br><span class="line">        let end = s.length - 1;</span><br><span class="line">        while (start &lt; end) &#123;</span><br><span class="line">            if (s[start] !== s[end]) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>方法3:分治 + 动态规划<br>先打表生成dp数组存储位置start,end的对应字符串是否是回文的<br>就是利用了动态规划的思想判断是否一个字符串是回文字符串</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;string&#125; s</span><br><span class="line"> * @return &#123;string[][]&#125;</span><br><span class="line"> */</span><br><span class="line">var partition = function (s) &#123;</span><br><span class="line">    let dp = generateArray(s.length, s.length);</span><br><span class="line">    //生成dp[start][end]是否为回文序列的dp数组</span><br><span class="line">    for (let len = 1; len &lt;= s.length; len++) &#123;//长度为len</span><br><span class="line">        for (let i = 0; i &lt;= s.length - len; i++) &#123;//起始下标为i</span><br><span class="line">            let j = i + len - 1;</span><br><span class="line">            dp[i][j] = s[i] === s[j] &amp;&amp; (len &lt; 3 || dp[i + 1][j - 1]) ? 1 : 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return partitionHelper(0, s.length - 1);</span><br><span class="line"></span><br><span class="line">    function partitionHelper(start, end) &#123;</span><br><span class="line"></span><br><span class="line">        let ans = [];</span><br><span class="line"></span><br><span class="line">        for (let i = start; i &lt;= end; i++) &#123;</span><br><span class="line">            let l = s.slice(start, i + 1);</span><br><span class="line">            if (dp[start][i] === 0) continue;</span><br><span class="line">            let r = partitionHelper(i + 1, end);</span><br><span class="line">            for (let j = 0; j &lt; r.length; j++) &#123;</span><br><span class="line">                r[j].unshift(l);</span><br><span class="line">                let temp = r[j];</span><br><span class="line">                ans.push(temp.slice(0));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (ans.length === 0) ans.push([]);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function generateArray(m, n) &#123;</span><br><span class="line">        let res = [];</span><br><span class="line">        for (let i = 0; i &lt; m; i++) &#123;</span><br><span class="line">            res.push(new Array(n).fill(0));</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="动态规划-DP"><a href="#动态规划-DP" class="headerlink" title="动态规划(DP)"></a>动态规划(DP)</h2><h4 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列*"></a>斐波那契数列*</h4><h5 id="1-斐波那契数列"><a href="#1-斐波那契数列" class="headerlink" title="1.斐波那契数列*"></a>1.斐波那契数列*</h5><p><img src="/img/20210311_1.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var fib = function (n) &#123;</span><br><span class="line">    if(n&lt;=1) return n;</span><br><span class="line">    let dp = [];</span><br><span class="line">    dp[0] = 0;</span><br><span class="line">    dp[1] = 1;</span><br><span class="line">    for (let i = 2; i &lt;= n; i++) &#123;</span><br><span class="line">        dp[i] = dp[i - 1] + dp[i - 2];</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[n];</span><br><span class="line">&#125;;//时间复杂度O(n),空间复杂度O(n),因为需要记录整个序列。</span><br><span class="line"></span><br><span class="line">var fib = function (n) &#123;</span><br><span class="line">    if (n &lt;= 1) return n;</span><br><span class="line">    let dp = [];</span><br><span class="line">    dp[0] = 0;</span><br><span class="line">    dp[1] = 1;</span><br><span class="line">    for (let i = 2; i &lt;= n; i++) &#123;</span><br><span class="line">        let sum = dp[0] + dp[1];  //仅用两个值即可</span><br><span class="line">        dp[0] = dp[1];</span><br><span class="line">        dp[1] = sum;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[1];</span><br><span class="line">&#125;;//时间复杂度O(n),空间复杂度O(1)。</span><br></pre></td></tr></table></figure>

<h5 id="2-爬楼梯"><a href="#2-爬楼梯" class="headerlink" title="2.爬楼梯"></a>2.爬楼梯</h5><p><img src="/img/1592190757011.png" alt="Alt text"></p>
<p>方法1:若n=5，爬1级，则剩下4级要爬；爬2级，则剩下3级要爬；爬4级有几种方式？爬3级有几种方式？于是，爬 5 级楼梯的方式数 = 爬 4 级楼梯的方式数 + 爬 3 级楼梯的方式数。逐渐向下划分：1级时，1种，2级时，2种，作为基础层。题目要求正整数，所以不划分0级和1级。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var climbStairs = function (n) &#123;</span><br><span class="line">    let dip = [];</span><br><span class="line">    dip[1] = 1;</span><br><span class="line">    dip[2] = 2;  //基础层</span><br><span class="line">    for (let i = 3; i &lt;= n; i++) &#123;  //向上一直找到n</span><br><span class="line">        dip[i] = dip[i - 1] + dip[i - 2];</span><br><span class="line">    &#125;</span><br><span class="line">    return dip[n];</span><br><span class="line">&#125;;//时间复杂度O(n),空间复杂度O(n)</span><br><span class="line">//面试官要求优化的话：</span><br><span class="line">for (let i = 3; i &lt;= n; i++) &#123;</span><br><span class="line">        let sum = dp[1] + dp[2];  //仅用两个值即可</span><br><span class="line">        dp[1] = dp[2];</span><br><span class="line">        dp[2] = sum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>递归式：f(n) = f(n-1) + f(n-2);</p>
<h5 id="3-最小花费爬楼梯"><a href="#3-最小花费爬楼梯" class="headerlink" title="3.最小花费爬楼梯"></a>3.最小花费爬楼梯</h5><p><img src="/img/20210311_2.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var minCostClimbingStairs = function (cost) &#123;</span><br><span class="line">    let dp = [];</span><br><span class="line">    let len = cost.length;</span><br><span class="line">    dp[0] = cost[0];  //数组下标从0开始</span><br><span class="line">    dp[1] = cost[1];</span><br><span class="line">    for (let i = 2; i &lt;= len; i++) &#123;</span><br><span class="line">        dp[i] = Math.min(dp[i - 1], dp[i - 2]) + cost[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return Math.min(dp[len - 1], dp[len - 2]);  //注意最后一步可以理解为不用花费，所以取倒数第一步，第二步的最小值</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line">//同样的，for循环中还可以优化成，空间复杂度O(n)</span><br><span class="line">let dpi = min(dp[0], dp[1]) + cost[i];</span><br><span class="line">    dp[0] = dp[1]; // 记录一下前两位</span><br><span class="line">    dp[1] = dpi;</span><br></pre></td></tr></table></figure>

<h5 id="4-打家劫舍"><a href="#4-打家劫舍" class="headerlink" title="4.打家劫舍"></a>4.打家劫舍</h5><p><img src="/img/1592192049565.png" alt="Alt text"></p>
<p>正向递推（最优）</p>
<p>此处动态规划方程：dp[n] = MAX( dp[n-1], dp[n-2] + num )，num为最后一位。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var rob = function (nums) &#123;</span><br><span class="line">    let len = nums.length;</span><br><span class="line">    if (len == 0) return 0;</span><br><span class="line">    let dp = [];</span><br><span class="line">    dp[0] = 0;</span><br><span class="line">    dp[1] = nums[0];</span><br><span class="line">    for (let i = 2; i &lt;= len; i++) &#123;</span><br><span class="line">        dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i - 1]);</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[len];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="4-打家劫舍-II"><a href="#4-打家劫舍-II" class="headerlink" title="4.打家劫舍 II"></a>4.打家劫舍 II</h5><p><img src="/img/1592826362148.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//掐头去尾，考虑两种情况：偷第1间；不偷第1间，偷最后1间，这两种情况就包括了两间都不偷的情况。所以我们可以将数组分为含有第1间房和不含第1间房的两个数组。</span><br><span class="line">var rob = function (nums) &#123;</span><br><span class="line">    let len = nums.length;</span><br><span class="line">    if (len == 0) return 0;</span><br><span class="line">    if (len == 1) return nums[0];  //特殊情况</span><br><span class="line">    let nums1 = nums.slice(0, len - 1);</span><br><span class="line">    let nums2 = nums.slice(1);</span><br><span class="line">    </span><br><span class="line">    //在两个数组上运用常规打家劫舍问题</span><br><span class="line">    function rober(nums) &#123;</span><br><span class="line">        let dp = [];</span><br><span class="line">        dp[0] = 0;</span><br><span class="line">        dp[1] = nums[0];</span><br><span class="line">        for (let i = 2; i &lt;= nums.length; i++) &#123;</span><br><span class="line">            dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i - 1]);</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[nums.length];</span><br><span class="line">    &#125;</span><br><span class="line">    let ans1 = rober(nums1);</span><br><span class="line">    let ans2 = rober(nums2);</span><br><span class="line">    return Math.max(ans1, ans2);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>与上一个题的思路类似，只是分成两种情况来比大小</p>
<h5 id="5-母牛生产"><a href="#5-母牛生产" class="headerlink" title="5.母牛生产"></a>5.母牛生产</h5><p><img src="/img/1592827092586.png" alt="Alt text"><br>每一年成熟的牛 = 去年成熟的牛 + 3年前成熟的牛生产出的牛（3年后成熟了）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var rob = function (n) &#123;</span><br><span class="line">    let dp = [];</span><br><span class="line">    dp[1] = 1;  //第一年1头</span><br><span class="line">    dp[2] = 2;  //第二年2头</span><br><span class="line">    dp[3] = 3;  //第三年3头</span><br><span class="line">    for (let i = 4; i &lt;= n; i++) &#123;</span><br><span class="line">        dp[i] = dp[i - 1] + dp[i - 3];</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="矩阵的最小路径和"><a href="#矩阵的最小路径和" class="headerlink" title="矩阵的最小路径和"></a>矩阵的最小路径和</h4><p>1.找第一行，第一列的边界情况——2.双层for循环——3.动态方程</p>
<h5 id="1-最小路径和"><a href="#1-最小路径和" class="headerlink" title="1.最小路径和"></a>1.最小路径和</h5><p><img src="/img/1592196264895.png" alt="Alt text"></p>
<p><img src="/./img/20210310.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//动态规划方程：当前项最小路径和 = 当前项值 + 上项或左项中的最小值</span><br><span class="line">// grid[i][j] += Math.min( grid[i - 1][j], grid[i][j - 1] )</span><br><span class="line">var minPathSum = function (grid) &#123;</span><br><span class="line">    let row = grid.length;  //行数</span><br><span class="line">    let col = grid[0].length;  //列数</span><br><span class="line">    let dp = grid;  //二维数组没办法直接定义</span><br><span class="line">    //grid的第一行与第一列 分别没有上项与左项 故单独处理计算起项最小路径和，第一行：</span><br><span class="line">    for (let j = 1; j &lt; col; j++) &#123;</span><br><span class="line">        dp[0][j] += dp[0][j - 1];</span><br><span class="line">    &#125;</span><br><span class="line">    //第一列：</span><br><span class="line">    for (let i = 1; i &lt; row; i++) &#123;</span><br><span class="line">        dp[i][0] += dp[i - 1][0];</span><br><span class="line">    &#125;</span><br><span class="line">    //二维数组，双循环</span><br><span class="line">    for (let i = 1; i &lt; row; i++) &#123;  //首先行数</span><br><span class="line">        for (let j = 1; j &lt; col; j++) &#123;</span><br><span class="line">            dp[i][j] += Math.min(dp[i - 1][j], dp[i][j - 1]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[row - 1][col - 1];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>方法2:正向递推</p>
<ul>
<li><p>一维dp</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var minPathSum = function (grid) &#123;</span><br><span class="line">    let m = grid.length;</span><br><span class="line">    let n = grid[0].length;</span><br><span class="line">    //只需要用一个一维的数组保存纵向上的结果即可</span><br><span class="line">    let dp = new Array(n).fill(0);</span><br><span class="line"></span><br><span class="line">    for (let i = 0; i &lt; m; i++) &#123;</span><br><span class="line">        for (let j = 0; j &lt; n; j++) &#123;</span><br><span class="line">            if (j === 0) &#123;</span><br><span class="line">                dp[j] = dp[j];</span><br><span class="line">            &#125; else if (i === 0) &#123;</span><br><span class="line">                dp[j] = dp[j - 1];</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                dp[j] = Math.min(dp[j],dp[j - 1]);</span><br><span class="line">            &#125;</span><br><span class="line">            dp[j] += grid[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[n-1];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>也可以选择直接在原数组上修改就不占多余的空间</p>
<h5 id="2-不同路径"><a href="#2-不同路径" class="headerlink" title="2.不同路径"></a>2.不同路径</h5><p><img src="/img/1592829886908.png" alt="Alt text"></p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//第一行和第一列都可以设置为1，此方法从第二行第二列开始逐行向右计算路径。</span><br><span class="line">var uniquePaths = function (m, n) &#123;</span><br><span class="line">    let dp = new Array(n).fill(1);</span><br><span class="line">    for (let i = 1; i &lt; m; i++) &#123;</span><br><span class="line">        for (let j = 1; j &lt; n; j++) &#123;</span><br><span class="line">            dp[j] += dp[j - 1];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[n - 1];</span><br><span class="line">&#125;;  //时间复杂度(m*n)，空间复杂度O(n)</span><br><span class="line"></span><br><span class="line">//和上题思路一样</span><br><span class="line">var uniquePaths = function (m, n) &#123;</span><br><span class="line">    let dp = new Array(m);  //构建二维数组，先构建一维数组，再for循环</span><br><span class="line">    for (let i = 0; i &lt; m; i++) &#123;</span><br><span class="line">        dp[i] = new Array(n);</span><br><span class="line">        dp[i][0] = 1;</span><br><span class="line">    &#125;</span><br><span class="line">    for (let s = 1; s &lt; n; s++) &#123; //从1开始了</span><br><span class="line">        dp[0][s] = 1;</span><br><span class="line">    &#125;</span><br><span class="line">    for (let i = 1; i &lt; m; i++) &#123;</span><br><span class="line">        for (let j = 1; j &lt; n; j++) &#123;</span><br><span class="line">            dp[i][j] = dp[i - 1][j] + dp[i][j - 1];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[m - 1][n - 1];</span><br><span class="line">&#125;;   //时间复杂度(m*n)，空间复杂度O(m*n)</span><br></pre></td></tr></table></figure>

<h5 id="3-有障碍的不同路径"><a href="#3-有障碍的不同路径" class="headerlink" title="3.有障碍的不同路径"></a>3.有障碍的不同路径</h5><p><img src="/img/20210312_1.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var uniquePathsWithObstacles = function (obstacleGrid) &#123;</span><br><span class="line">    let m = obstacleGrid.length;</span><br><span class="line">    let n = obstacleGrid[0].length;</span><br><span class="line">    let dp = obstacleGrid;</span><br><span class="line">    if (dp[0][0] == 1) return 0;   //第一格有障碍情况，特殊处理</span><br><span class="line">    dp[0][0] = 1;  //第一格单独提出赋值</span><br><span class="line">    for (let i = 1; i &lt; m; i++) &#123;  //第二格起遍历该列</span><br><span class="line">        if (dp[i][0] == 0) &#123;</span><br><span class="line">            dp[i][0] = dp[i - 1][0];  //遇到0，把前值赋给它————此处有利于处理一列有多个障碍情况**</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            dp[i][0] = 0;   //遇到1，赋值为0</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (let j = 1; j &lt; n; j++) &#123;  //第一行处理</span><br><span class="line">        if (dp[0][j] == 0) &#123;</span><br><span class="line">            dp[0][j] = dp[0][j - 1];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            dp[0][j] = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (let i = 1; i &lt; m; i++) &#123;  //第二行第二列起逐行遍历</span><br><span class="line">        for (let j = 1; j &lt; n; j++) &#123;</span><br><span class="line">            if (dp[i][j] == 1) &#123;</span><br><span class="line">                dp[i][j] = 0;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i][j] = dp[i - 1][j] + dp[i][j - 1];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[m - 1][n - 1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="数组区间-未看"><a href="#数组区间-未看" class="headerlink" title="数组区间(未看)"></a>数组区间(未看)</h4><h5 id="1-区域和检索-数组不可变"><a href="#1-区域和检索-数组不可变" class="headerlink" title="1.区域和检索 - 数组不可变"></a>1.区域和检索 - 数组不可变</h5><p><img src="/img/1592203481660.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;number[]&#125; nums</span><br><span class="line"> */</span><br><span class="line">var NumArray = function (nums) &#123;</span><br><span class="line">  this.nums = nums;</span><br><span class="line">  this.sum = [nums[0]];</span><br><span class="line">  for (let i = 1; i &lt; nums.length; i++) &#123;</span><br><span class="line">      this.sum[i] = this.sum[i - 1] + nums[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/** </span><br><span class="line">* @param &#123;number&#125; i </span><br><span class="line">* @param &#123;number&#125; j</span><br><span class="line">* @return &#123;number&#125;</span><br><span class="line">*/</span><br><span class="line">NumArray.prototype.sumRange = function (i, j) &#123;</span><br><span class="line">  return this.sum[j] - this.sum[i] + this.nums[i];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Your NumArray object will be instantiated and called as such:</span><br><span class="line"> * var obj = new NumArray(nums)</span><br><span class="line"> * var param_1 = obj.sumRange(i,j)</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>

<p>i - j的区间和等于 0-j的和 减去 0-i的和 + nums[i]</p>
<h5 id="2-等差数列划分"><a href="#2-等差数列划分" class="headerlink" title="2.等差数列划分"></a>2.等差数列划分</h5><p><img src="/img/1592893872163.png" alt="Alt text"><br>方法一：参照求回文字符串的方法，但是这里这种方法很慢是O（n2）级别的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;number[]&#125; A</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> */</span><br><span class="line">var numberOfArithmeticSlices = function (A) &#123;</span><br><span class="line">    let len = A.length;</span><br><span class="line">    let dp = new Array(len).fill(1);</span><br><span class="line">    let ans = 0;</span><br><span class="line"></span><br><span class="line">    for (let l = 3; l &lt;= len; l++) &#123;//l为len</span><br><span class="line">        for (let i = 0; i &lt; len - l + 1; i++) &#123;//起始位置为i</span><br><span class="line">            let gap1 = A[i + l - 1] - A[i + l - 2];</span><br><span class="line">            let gap2 = A[i + 1] - A[i];</span><br><span class="line">            dp[i] = gap1 === gap2 &amp;&amp; dp[i] === 1 ? 1 : 0;</span><br><span class="line">            if (dp[i] === 1) &#123;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>方法二：起始不需要关心起点在哪里，只需要关心终点在哪里就可以了<br>递归式：以i为结束的等差子数组个数:dp[i] = dp[i - 1] + 1如果A[i] - A[i - 1] === A[i - 1] - A[i - 2]，这里的1是指A[i] A[i-1] A[i - 2]<br>否则就为0</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;number[]&#125; A</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> */</span><br><span class="line">var numberOfArithmeticSlices = function (A) &#123;</span><br><span class="line">    let len = A.length;</span><br><span class="line">    let dp = new Array(len).fill(0);</span><br><span class="line">    let ans = 0;</span><br><span class="line"></span><br><span class="line">    for (let i = 2; i &lt; len; i++) &#123;//以i为结尾的字符串</span><br><span class="line">        if (A[i] - A[i - 1] === A[i - 1] - A[i - 2]) &#123;</span><br><span class="line">            dp[i] = dp[i - 1] + 1;</span><br><span class="line">            ans += dp[i];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            dp[i] = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="分割整数"><a href="#分割整数" class="headerlink" title="分割整数"></a>分割整数</h4><p>1.定义数组——2.初始化dp[0]/dp[1]——3.双层for循环——4.动态方程</p>
<h5 id="1-整数拆分x"><a href="#1-整数拆分x" class="headerlink" title="1. 整数拆分x"></a>1. 整数拆分x</h5><p><img src="/img/1592206289590.png" alt="Alt text"></p>
<p>方法1:用数组保存结果，但是过不了时间</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var integerBreak = function (n) &#123;</span><br><span class="line">    let dp = [];</span><br><span class="line">    function helper(n) &#123;</span><br><span class="line">        if (n === 2) return 1;</span><br><span class="line">        if(dp[n] !== undefined)&#123;</span><br><span class="line">            return dp[n];</span><br><span class="line">        &#125;</span><br><span class="line">        let ans = 0;</span><br><span class="line">        for (let i = 1; i &lt; n; i++) &#123;</span><br><span class="line">            ans = Math.max(integerBreak(n - i) * i, (n - i) * i, ans);</span><br><span class="line">        &#125;</span><br><span class="line">        dp[n] = ans;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">    return helper(n);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>方法2:正向递推,从递推边界开始向上走</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//此题公式：dp[i] = Math.max(dp[i],dp[i - j] * j,j * (i - j));  为何j不用拆分，不写成dp[j]的形式，因j是从1开始遍历，拆分j的情况，在遍历j的过程中其实都计算过了。</span><br><span class="line">var integerBreak = function (n) &#123;</span><br><span class="line">    let dp = new Array(n + 1).fill(0);  //后面用dp[i]，此处不能dp=[]，要赋初始值0.</span><br><span class="line">    dp[2] = 1; //dp[0]dp[1]在拆分中是没有意义的，不做定义</span><br><span class="line">    for(let i = 3;i &lt;= n;i++)&#123;  //该遍历用于计算从3到n，每个数的最大乘积</span><br><span class="line">        for(let j = 1;j &lt; i;j++)&#123;  //该遍历用于计算具体某个数的最大乘积</span><br><span class="line">            dp[i] = Math.max(dp[i],dp[i - j] * j,j * (i - j));  //此处用了dp[i]来比，所以要给dp初始值</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[n];</span><br><span class="line">&#125;;O(n^2)和O(n)</span><br></pre></td></tr></table></figure>

<h5 id="2-完全平方数x-1"><a href="#2-完全平方数x-1" class="headerlink" title="2.完全平方数x"></a>2.完全平方数x</h5><p><img src="/img/1592897991837.png" alt="Alt text"><br>方法: 使用dp</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var numSquares = function (n) &#123;</span><br><span class="line">    //首先获得小于等于n的完全平方数</span><br><span class="line">    function generateSquares(n) &#123;</span><br><span class="line">        let squares = [];</span><br><span class="line">        for (let i = 1; i * i &lt;= n; i++) &#123;</span><br><span class="line">            squares.push(i * i);</span><br><span class="line">        &#125;</span><br><span class="line">        return squares;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    let squares = generateSquares(n);</span><br><span class="line">    let dp = new Array(n + 1).fill(9999999);</span><br><span class="line">    dp[0] = 0;</span><br><span class="line">    dp[1] = 1;</span><br><span class="line">    dp[2] = 2;//给一个初始值</span><br><span class="line">    for (let i = 3; i &lt;= n; i++) &#123;//从3开始的每一个数都要求一次</span><br><span class="line">        for (let j = 0; squares[j] &lt;= i; j++) &#123;//遍历所有小于i的完全平方数</span><br><span class="line">            dp[i] = Math.min(dp[i - squares[j]] + 1, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[n];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>方法2:贪心 + DP（以后再看）</p>
<h5 id="3-解码方法"><a href="#3-解码方法" class="headerlink" title="3.解码方法"></a>3.解码方法</h5><p><img src="/img/1592904876630.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;string&#125; s</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> */</span><br><span class="line">var numDecodings = function (s) &#123;</span><br><span class="line"></span><br><span class="line">    if (s[0] === &apos;0&apos;) return 0;</span><br><span class="line">    let len = s.length;</span><br><span class="line">    let dp = new Array(len).fill(0);</span><br><span class="line"></span><br><span class="line">    dp[0] = s[0] === &apos;0&apos; ? 0 : 1;</span><br><span class="line"></span><br><span class="line">    for (let i = 1; i &lt; len; i++) &#123;</span><br><span class="line"></span><br><span class="line">        let temp = parseInt(s[i - 1] + s[i]);</span><br><span class="line"></span><br><span class="line">        if (s[i] === &apos;0&apos;) &#123;</span><br><span class="line">            if (s[i - 1] === &apos;0&apos; || temp &gt; 26) &#123;</span><br><span class="line">                return 0;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i] = dp[i - 2] || 1;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            if(s[i - 1] === &apos;0&apos; || temp &gt; 26)&#123;</span><br><span class="line">                dp[i] = dp[i - 1];</span><br><span class="line">            &#125;else&#123;//注意若没有0且可以组成新数的递归关系，即s[i]都可以加到dp[i-1]中，s[i] + s[i-1]都可以加到dp[i-2]中</span><br><span class="line">                dp[i] = dp[i - 1] + (dp[i - 2]||1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    return dp[len - 1];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h4><h5 id="1-最长上升子序列"><a href="#1-最长上升子序列" class="headerlink" title="1. 最长上升子序列"></a>1. 最长上升子序列</h5><p><img src="/img/1592208337665.png" alt="Alt text"><br>方法1:DP</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;number[]&#125; nums</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> */</span><br><span class="line">var lengthOfLIS = function (nums) &#123;</span><br><span class="line">    if(nums.length === 0) return 0;</span><br><span class="line">    let dp = new Array(nums.length).fill(1);</span><br><span class="line">    dp[0] = 1;</span><br><span class="line">    let ans = 1;</span><br><span class="line">    for (let i = 1; i &lt; nums.length; i++) &#123;</span><br><span class="line">        let temp = 0;</span><br><span class="line">        for(let j = 0;j &lt; i;j++)&#123;</span><br><span class="line">            if(nums[i] &gt; nums[j])&#123;</span><br><span class="line">                temp = Math.max(temp,dp[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i] = temp + 1;</span><br><span class="line">        ans = Math.max(ans,dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>方法2: 二分查找（之后补上）</p>
<h5 id="2-最长数对链"><a href="#2-最长数对链" class="headerlink" title="2. 最长数对链"></a>2. 最长数对链</h5><p><img src="/img/1592998064934.png" alt="Alt text"><br>思路与上一题类似，但是需要先排序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;number[][]&#125; pairs</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> */</span><br><span class="line">var findLongestChain = function (pairs) &#123;</span><br><span class="line"></span><br><span class="line">    let len = pairs.length;</span><br><span class="line">    //首先以每一个pair的第一个元素排序</span><br><span class="line">    pairs.sort(function (x, y) &#123;</span><br><span class="line">        return x[0] - y[0];</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    let dp = new Array(len).fill(1);</span><br><span class="line">    let ans = 1;</span><br><span class="line"></span><br><span class="line">    for (let i = 0; i &lt; len; i++) &#123;</span><br><span class="line">        for (let j = i - 1; j &gt;= 0; j--) &#123;</span><br><span class="line">            if (pairs[i][0] &gt; pairs[j][1]) &#123;</span><br><span class="line">                dp[i] = Math.max(dp[j] + 1, dp[i]);</span><br><span class="line">                ans = Math.max(ans,dp[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="3-摆动序列x"><a href="#3-摆动序列x" class="headerlink" title="3.摆动序列x"></a>3.摆动序列x</h5><p><img src="/img/1592999936167.png" alt="Alt text"><br>方法1:与上一个题思路类似的解法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;number[]&#125; nums</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> */</span><br><span class="line">var wiggleMaxLength = function (nums) &#123;</span><br><span class="line"></span><br><span class="line">    if(nums.length === 0) return 0;</span><br><span class="line"></span><br><span class="line">    let len = nums.length;</span><br><span class="line">    let dp = new Array(len).fill(0);</span><br><span class="line">    dp[0] = 1;</span><br><span class="line">    let ans = 1;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    for (let i = 1; i &lt; len; i++) &#123;</span><br><span class="line">        for (let j = i - 1; j &gt;= 0; j--) &#123;</span><br><span class="line">            let sub1 = nums[i] - nums[j];</span><br><span class="line">            let sub2 = j &lt; 1 ? -sub1 : nums[j] - nums[j - 1];</span><br><span class="line">            if (sub1 * sub2 &lt; 0)&#123;</span><br><span class="line">                dp[i] = Math.max(dp[j] + 1,dp[i]);</span><br><span class="line">                ans = Math.max(ans,dp[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return ans;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>方法2:<br>up[i] 存的是目前为止最长的以第 i 个元素结尾的上升摆动序列的长度(不一定要取i)。<br>down[i] 记录的是目前为止最长的以第 i 个元素结尾的下降摆动序列的长度(不一定要取i)。<br><img src="/img/1593001118680.png" alt="Alt text"><br><img src="/img/1593001272819.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;number[]&#125; nums</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> */</span><br><span class="line">var wiggleMaxLength = function (nums) &#123;</span><br><span class="line"></span><br><span class="line">    if(nums.length === 0) return 0;</span><br><span class="line"></span><br><span class="line">    let up = 1;</span><br><span class="line">    let down = 1;</span><br><span class="line">    let len = nums.length;</span><br><span class="line"></span><br><span class="line">    for(let i = 1;i &lt; len;i++)&#123;</span><br><span class="line">        if(nums[i] &gt; nums[i - 1])&#123;</span><br><span class="line">            up = down + 1;</span><br><span class="line">        &#125;else if(nums[i] &lt; nums[i-1])&#123;</span><br><span class="line">            down = up + 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return Math.max(up,down);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>方法：贪心（之后补充）</p>
<h4 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h4><h5 id="1-最长公共子序列"><a href="#1-最长公共子序列" class="headerlink" title="1.最长公共子序列"></a>1.最长公共子序列</h5><p><img src="/img/1593002957462.png" alt="Alt text"></p>
<p><img src="/img/1593004649328.png" alt="Alt text"></p>
<p>注意这类问题要确定最后一个元素是确定取还是不取</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var longestCommonSubsequence = function (text1, text2) &#123;</span><br><span class="line">    let len1 = text1.length;</span><br><span class="line">    let len2 = text2.length;</span><br><span class="line">    let dp = generateArray(len1 + 1, len2 + 1);</span><br><span class="line"></span><br><span class="line">    for (let i = 0; i &lt; len1; i++) &#123;</span><br><span class="line">        for (let j = 0; j &lt; len2; j++) &#123;</span><br><span class="line">            if (text1[i] === text2[j]) &#123;</span><br><span class="line">                dp[i + 1][j + 1] = dp[i][j] + 1;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                dp[i + 1][j + 1] = Math.max(dp[i][j + 1], dp[i + 1][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[len1][len2];</span><br><span class="line"></span><br><span class="line">    function generateArray(m, n) &#123;</span><br><span class="line">        let res = [];</span><br><span class="line">        for (let i = 0; i &lt; m; i++) &#123;</span><br><span class="line">            res.push(new Array(n).fill(0));</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h4><p>有一个容量为 N 的背包，要用这个背包装下物品的价值最大，这些物品有两个属性：体积 w 和价值 v。</p>
<p>定义一个二维数组 dp 存储最大价值，<strong>其中 dp[i][j] 表示前 i 件物品体积不超过 j 的情况下能达到的最大价值</strong>。设第 i 件物品体积为 w，价值为 v，根据第 i 件物品是否添加到背包中，可以分两种情况讨论：</p>
<p>第 i 件物品没添加到背包，<strong>总体积不超过 j 的前 i 件物品</strong>的最大价值就是总体积不超过 j 的前 i-1 件物品的最大价值，dp[i][j] = dp[i-1][j]。<br>第 i 件物品添加到背包中，dp[i][j] = dp[i-1][j-w] + v。<br>第 i 件物品可添加也可以不添加，取决于哪种情况下最大价值更大。因此，0-1 背包的状态转移方程为：<br><img src="/img/1593411928910.png" alt="Alt text"></p>
<p>1.二维的01背包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//二维01背包问题</span><br><span class="line">// W 为背包总体积</span><br><span class="line">// N 为物品数量</span><br><span class="line">// weights 数组存储 N 个物品的重量</span><br><span class="line">// values 数组存储 N 个物品的价值</span><br><span class="line">function knapsack(W, N, weights, values) &#123;</span><br><span class="line">  let dp = generate2DimentionArray(N,W);</span><br><span class="line">  for (let i = 1; i &lt;= N; i++) &#123;</span><br><span class="line">    let w = weights[i - 1];</span><br><span class="line">    let val = values[i - 1];</span><br><span class="line">    for (let j = 1; j &lt;= W; j++) &#123;</span><br><span class="line">      if (j &gt;= w) &#123;         //不拿        //拿了</span><br><span class="line">        dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - w] + val);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        dp[i][j] = dp[i-1][j];  //不拿该物体</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return dp[N][W];</span><br><span class="line"></span><br><span class="line">  function generate2DimentionArray(N,W) &#123;</span><br><span class="line">    let arr = new Array(N + 1);</span><br><span class="line">    for (let i = 0; i &lt; N + 1; i++) &#123;</span><br><span class="line">      arr[i] = (new Array(W + 1).fill(0));</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(knapsack(10,4,[3,4,10,2],[1,2,100,4]));</span><br></pre></td></tr></table></figure>

<p>2.空间优化（注意对体积要从大到小遍历）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function knapsack(W, N, weights, values) &#123;</span><br><span class="line">    let dp = new Array(W + 1).fill(0);</span><br><span class="line">    for (let i = 1; i &lt;= N; i++) &#123;</span><br><span class="line">        let w = weights[i - 1];</span><br><span class="line">        let v = values[i - 1];</span><br><span class="line">        for (let j = W; j &gt;= 1; j--) &#123;</span><br><span class="line">            if (j &gt;= w) &#123;</span><br><span class="line">                dp[j] = Math.max(dp[j], dp[j - w] + v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[W];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(knapsack(10, 4, [3, 4, 10, 2], [1, 2, 100, 4]));</span><br></pre></td></tr></table></figure>

<h5 id="1-分割等和子集"><a href="#1-分割等和子集" class="headerlink" title="1.分割等和子集"></a>1.分割等和子集</h5><p><img src="/img/1593411854119.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var canPartition = function (nums) &#123;</span><br><span class="line">    let len = nums.length;</span><br><span class="line">    let sum = 0;</span><br><span class="line">    for (let i = 0; i &lt; len; i++) &#123;</span><br><span class="line">        sum += nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    if (sum % 2 === 1) return false;</span><br><span class="line">    let W = sum / 2;</span><br><span class="line"></span><br><span class="line">    let dp = new Array(W + 1).fill(false);//注意是重量</span><br><span class="line">    dp[0] = true;</span><br><span class="line">    //如果使用一维dp数组，物品遍历的for循环放在外层，遍历背包的for循环放在内层，且内层for循环倒叙遍历！</span><br><span class="line">    for (let i = 1; i &lt; len; i++) &#123;</span><br><span class="line">        for (let j = W; j &gt;= nums[i]; j--) &#123;  // 每一个元素一定是不可重复放入，所以从大到小遍历</span><br><span class="line">            dp[j] = Math.max(dp[j], dp[j - nums[i]] + nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (dp[W] == W) return true;</span><br><span class="line">    return false;</span><br><span class="line">&#125;;  //O(n)和O(n)</span><br></pre></td></tr></table></figure>

<h5 id="2-目标和"><a href="#2-目标和" class="headerlink" title="2.目标和"></a>2.目标和</h5><p><img src="/img/1593413079587.png" alt="Alt text"></p>
<p>方法1:DFS</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var findTargetSumWays = function (nums, S) &#123;</span><br><span class="line">    let len = nums.length;</span><br><span class="line">    let ans = 0;</span><br><span class="line">    dfs(0,0);</span><br><span class="line"></span><br><span class="line">    function dfs(i, sum) &#123;</span><br><span class="line">        if (i === len) &#123;</span><br><span class="line">            if (sum === S) &#123;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        sum += nums[i];</span><br><span class="line">        dfs(i + 1, sum);</span><br><span class="line">        sum = sum - nums[i] * 2;</span><br><span class="line">        dfs(i + 1, sum);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>方法2:动态规划<br>该问题可以转换为 Subset Sum 问题，从而使用 0-1 背包的方法来求解。</p>
<p>可以将这组数看成两部分，P 和 N，其中 P 使用正号，N 使用负号，有以下推导：</p>
<blockquote>
<p>sum(P) - sum(N) = target<br>sum(P) + sum(N) + sum(P) - sum(N) = target + sum(P) + sum(N)<br>                     2 * sum(P) = target + sum(nums)</p>
</blockquote>
<p>因此只要找到一个子集，令它们都取正号，并且和等于 (target + sum(nums))/2，就证明存在解。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var findTargetSumWays = function (nums, S) &#123;</span><br><span class="line">    let len = nums.length;</span><br><span class="line">    let sum = 0;</span><br><span class="line">    for (let i = 0; i &lt; len; i++) &#123;</span><br><span class="line">        sum += nums[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (sum &lt; S || (sum + S) % 2 === 1) return 0;//如果sum &lt; S也不可能达成目标并且避免了数组开的过大</span><br><span class="line"></span><br><span class="line">    let W = (sum + S) / 2;</span><br><span class="line">    let dp = new Array(W + 1).fill(0);</span><br><span class="line">    dp[0] = 1;//这里是数个数所以是从1开始</span><br><span class="line"></span><br><span class="line">    for (let i = 0; i &lt; len; i++) &#123;</span><br><span class="line">        for (let j = W; j &gt;= nums[i]; j--) &#123;</span><br><span class="line">            dp[j] = dp[j] + dp[j - nums[i]];//注意递归式，不选的个数加上选的个数</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return dp[W];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="3-一和零"><a href="#3-一和零" class="headerlink" title="3.一和零"></a>3.一和零</h5><p><img src="/img/1593416889214.png" alt="Alt text"><br>资源为多维的01背包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;string[]&#125; strs</span><br><span class="line"> * @param &#123;number&#125; m</span><br><span class="line"> * @param &#123;number&#125; n</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> */</span><br><span class="line">var findMaxForm = function (strs, m, n) &#123;</span><br><span class="line"></span><br><span class="line">    function generateArray(m, n) &#123;</span><br><span class="line">        let res = [];</span><br><span class="line">        for (let i = 0; i &lt; m; i++) &#123;</span><br><span class="line">            res.push(new Array(n).fill(0));</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    let len = strs.length;</span><br><span class="line">    let dp = generateArray(m + 1, n + 1);</span><br><span class="line">    </span><br><span class="line">    for (let i = 0; i &lt; len; i++) &#123;</span><br><span class="line">        //数str中的01个数</span><br><span class="line">        let ones = 0;</span><br><span class="line">        let zeros = 0;</span><br><span class="line"></span><br><span class="line">        for (let item of strs[i]) &#123;</span><br><span class="line">            if (item === &apos;0&apos;) zeros++;</span><br><span class="line">            else ones++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (let j = m; j &gt;= zeros; j--) &#123;//多维也要从后往前遍历</span><br><span class="line">            for (let k = n; k &gt;= ones; k--) &#123;</span><br><span class="line">                dp[j][k] = Math.max(dp[j][k], dp[j - zeros][k - ones] + 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return dp[m][n];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="4-零钱兑换"><a href="#4-零钱兑换" class="headerlink" title="4.零钱兑换"></a>4.零钱兑换</h5><p><img src="/img/1593686310743.png" alt="Alt text"><br>完全背包问题:背包容量无限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;number[]&#125; coins</span><br><span class="line"> * @param &#123;number&#125; amount</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> */</span><br><span class="line">var coinChange = function (coins, amount) &#123;</span><br><span class="line">    if(amount === 0) return 0;</span><br><span class="line">    let dp = new Array(amount + 1).fill(0);</span><br><span class="line">    for(let coin of coins)&#123;</span><br><span class="line">        for(let i = coin;i &lt;= amount;i++)&#123;</span><br><span class="line">            if(i === coin)&#123;</span><br><span class="line">                dp[i] = 1;</span><br><span class="line">            &#125;else if(dp[i] === 0 &amp;&amp; dp[i - coin] !== 0)&#123;</span><br><span class="line">                dp[i] = dp[i - coin] + 1;</span><br><span class="line">            &#125;else if(dp[i] !== 0 &amp;&amp; dp[i - coin] !== 0)&#123;</span><br><span class="line">                dp[i] = Math.min(dp[i],dp[i - coin] + 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[amount] == 0 ? -1 : dp[amount];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>递推式：dp[coin][i] = Math.min(dp[coin - 1][i],dp[coin][i-coins[amount]] + 1)</p>
<h5 id="5-零钱兑换-II"><a href="#5-零钱兑换-II" class="headerlink" title="5.零钱兑换 II"></a>5.零钱兑换 II</h5><p><img src="/img/1593690862330.png" alt="Alt text"><br>/**</p>
<ul>
<li><p>@param {number} amount</p>
</li>
<li><p>@param {number[]} coins</p>
</li>
<li><p>@return {number}</p>
</li>
<li><p>/<br>var change = function (amount, coins) {</p>
<p>  let dp = new Array(amount + 1).fill(0);<br>  dp[0] = 1;<br>  for (let coin of coins) {</p>
<pre><code>for (let i = coin; i &lt;= amount; i++) {
    dp[i] += dp[i - coin];
}</code></pre><p>  }</p>
<p>  return dp[amount];</p>
</li>
</ul>
<p>};</p>
<h5 id="6-单词拆分"><a href="#6-单词拆分" class="headerlink" title="6.单词拆分"></a>6.单词拆分</h5><p><img src="/img/1593951712142.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;string&#125; s</span><br><span class="line"> * @param &#123;string[]&#125; wordDict</span><br><span class="line"> * @return &#123;boolean&#125;</span><br><span class="line"> */</span><br><span class="line">var wordBreak = function(s, wordDict) &#123;</span><br><span class="line">    let len = s.length;</span><br><span class="line">    let dp = new Array(len + 1).fill(false);</span><br><span class="line">    dp[0] = true;</span><br><span class="line">    for(let i = 1;i &lt;= len;i++)&#123;//要从包的容量遍历起，这样才能考虑顺序</span><br><span class="line">        for(let word of wordDict)&#123;</span><br><span class="line">            if(i &gt;= word.length &amp;&amp; s.slice(i - word.length, i) === word)&#123;</span><br><span class="line">                dp[i] = dp[i] || dp[i - word.length];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[len];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="7-组合总和-Ⅳ"><a href="#7-组合总和-Ⅳ" class="headerlink" title="7.组合总和 Ⅳ"></a>7.组合总和 Ⅳ</h5><p><img src="/img/1593955637756.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;number[]&#125; nums</span><br><span class="line"> * @param &#123;number&#125; target</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> */</span><br><span class="line">var combinationSum4 = function(nums, target) &#123;</span><br><span class="line">    let dp = new Array(target + 1).fill(0);</span><br><span class="line">    dp[0] = 1;</span><br><span class="line">    for(let i = 1;i &lt;= target;i++)&#123;</span><br><span class="line">        for(let num of nums)&#123;</span><br><span class="line">            if(num &lt;= i)&#123;</span><br><span class="line">                dp[i] += dp[i - num];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[target];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="股票问题"><a href="#股票问题" class="headerlink" title="股票问题"></a>股票问题</h4><p>base case：<br>dp[-1][k][0] = dp[i][0][0] = 0<br>dp[-1][k][1] = dp[i][0][1] = -infinity</p>
<p>状态转移方程：<br>dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])<br>dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])</p>
<h5 id="k-1-也可以用贪心来解决"><a href="#k-1-也可以用贪心来解决" class="headerlink" title="k=1(也可以用贪心来解决)"></a>k=1(也可以用贪心来解决)</h5><p>dp[i][1][0] = max(dp[i-1][1][0], dp[i-1][1][1] + prices[i])<br>dp[i][1][1] = max(dp[i-1][1][1], dp[i-1][0][0] - prices[i])<br>            = max(dp[i-1][1][1], -prices[i])<br>解释：k = 0 的 base case，所以 dp[i-1][0][0] = 0。</p>
<p>现在发现 k 都是 1，不会改变，即 k 对状态转移已经没有影响了。<br>可以进行进一步化简去掉所有 k：<br>dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])<br>dp[i][1] = max(dp[i-1][1], -prices[i])<br><img src="/img/1599836541938.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;number[]&#125; prices</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> */</span><br><span class="line">var maxProfit = function (prices) &#123;</span><br><span class="line">    let dp_0 = 0;</span><br><span class="line">    let dp_1 = Number.MIN_SAFE_INTEGER;//因为第0天还没有开始交易又持有的情况不可能发生</span><br><span class="line">    prices.forEach(function (price) &#123;</span><br><span class="line">        dp_0 = Math.max(dp_0, dp_1 + price);</span><br><span class="line">        dp_1 = Math.max(dp_1, -price);</span><br><span class="line">    &#125;)</span><br><span class="line">    return dp_0;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="k-无穷-也可以用贪心来解决"><a href="#k-无穷-也可以用贪心来解决" class="headerlink" title="k=无穷(也可以用贪心来解决)"></a>k=无穷(也可以用贪心来解决)</h5><p><img src="/img/1599838053937.png" alt="Alt text"><br>dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])<br>dp[i][1] = max(dp[i-1][1], dp[i-1][0]-prices[i])</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;number[]&#125; prices</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> */</span><br><span class="line">var maxProfit = function(prices) &#123;</span><br><span class="line">    let dp_0 = 0;</span><br><span class="line">    let dp_1 = Number.MIN_SAFE_INTEGER;</span><br><span class="line">    prices.forEach((price)=&gt;&#123;</span><br><span class="line">        let temp = dp_0;</span><br><span class="line">        dp_0 = Math.max(dp_0,dp_1 + price);</span><br><span class="line">        dp_1 = Math.max(dp_1,temp - price);</span><br><span class="line">    &#125;)</span><br><span class="line">    return dp_0;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="k-infinity-with-cooldown"><a href="#k-infinity-with-cooldown" class="headerlink" title="k = +infinity with cooldown"></a>k = +infinity with cooldown</h5><p>dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])<br>dp[i][1] = max(dp[i-1][1], dp[i-2][0]-prices[i])<br><img src="/img/1599838792899.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;number[]&#125; prices</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> */</span><br><span class="line">var maxProfit = function(prices) &#123;</span><br><span class="line">    let dp_0 = 0;</span><br><span class="line">    let dp_1 = Number.MIN_SAFE_INTEGER;</span><br><span class="line">    let dp_pre_0 = 0;</span><br><span class="line">    prices.forEach((price)=&gt;&#123;</span><br><span class="line">        let temp = dp_0;</span><br><span class="line">        dp_0 = Math.max(dp_0,dp_1+price);</span><br><span class="line">        dp_1 = Math.max(dp_1,dp_pre_0-price);</span><br><span class="line">        dp_pre_0 = temp;</span><br><span class="line">    &#125;)</span><br><span class="line">    return dp_0;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="k-infinity-with-fee"><a href="#k-infinity-with-fee" class="headerlink" title="k = +infinity with fee"></a>k = +infinity with fee</h5><p><img src="/img/1599838895836.png" alt="Alt text"><br>dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i] - fee)<br>dp[i][1] = max(dp[i-1][1], dp[i-1][0]-prices[i])</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;number[]&#125; prices</span><br><span class="line"> * @param &#123;number&#125; fee</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> */</span><br><span class="line">var maxProfit = function(prices, fee) &#123;</span><br><span class="line">    let dp_0 = 0;</span><br><span class="line">    let dp_1 = Number.MIN_SAFE_INTEGER;</span><br><span class="line">    prices.forEach(function(price)&#123;</span><br><span class="line">        let temp = dp_0;</span><br><span class="line">        dp_0 = Math.max(dp_0,dp_1 + price - fee);</span><br><span class="line">        dp_1 = Math.max(dp_1,temp - price);</span><br><span class="line">    &#125;)</span><br><span class="line">    return dp_0;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="k-2"><a href="#k-2" class="headerlink" title="k=2"></a>k=2</h5><p><img src="/img/1600005605406.png" alt="Alt text"><br>dp[i][2][0] = max(dp[i-1][2][0], dp[i-1][2][1] + prices[i])<br>dp[i][2][1] = max(dp[i-1][2][1], dp[i-1][1][0] - prices[i])<br>dp[i][1][0] = max(dp[i-1][1][0], dp[i-1][1][1] + prices[i])<br>dp[i][1][1] = max(dp[i-1][1][1], - prices[i])<br>根据公示只需要4个变量就可以，并且先算k=2，再算k=1会有更好的效果，不用一个临时变量来进行存储</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;number[]&#125; prices</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> */</span><br><span class="line">var maxProfit = function (prices) &#123;</span><br><span class="line">    let dp_2_0 = 0;</span><br><span class="line">    let dp_2_1 = Number.MIN_SAFE_INTEGER;</span><br><span class="line">    let dp_1_0 = 0;</span><br><span class="line">    let dp_1_1 = Number.MIN_SAFE_INTEGER;</span><br><span class="line">    prices.forEach(function (price) &#123;</span><br><span class="line">        dp_2_0 = Math.max(dp_2_0, dp_2_1 + price);</span><br><span class="line">        dp_2_1 = Math.max(dp_2_1, dp_1_0 - price);</span><br><span class="line">        dp_1_0 = Math.max(dp_1_0, dp_1_1 + price);</span><br><span class="line">        dp_1_1 = Math.max(dp_1_1, -price);</span><br><span class="line">    &#125;)</span><br><span class="line">    return dp_2_0;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="k-任意值"><a href="#k-任意值" class="headerlink" title="k=任意值"></a>k=任意值</h5><p><img src="/img/1600005907860.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;number&#125; k</span><br><span class="line"> * @param &#123;number[]&#125; prices</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> */</span><br><span class="line">var maxProfit = function (k, prices) &#123;</span><br><span class="line">    let temp = prices.length / 2;</span><br><span class="line">    if (k &gt;= temp) &#123;//如果k值大于prices的长度除2，问题退化为k为无限</span><br><span class="line"></span><br><span class="line">        let dp_0 = 0;</span><br><span class="line">        let dp_1 = Number.MIN_SAFE_INTEGER;</span><br><span class="line"></span><br><span class="line">        prices.forEach(function (price) &#123;</span><br><span class="line">            let temp = dp_0;</span><br><span class="line">            dp_0 = Math.max(dp_0, dp_1 + price);</span><br><span class="line">            dp_1 = Math.max(dp_1, temp - price);</span><br><span class="line">        &#125;)</span><br><span class="line">        return dp_0;</span><br><span class="line"></span><br><span class="line">    &#125; else &#123;</span><br><span class="line"></span><br><span class="line">        let len = prices.length;</span><br><span class="line">        let dp = createArray(len + 1, k + 1);</span><br><span class="line">        //初始化dp[0][k][1] = -infinity,dp[i][0][1] = -infinity</span><br><span class="line">        for (let i = 0; i &lt;= k; i++) &#123;</span><br><span class="line">            dp[0][i][1] = Number.MIN_SAFE_INTEGER;</span><br><span class="line">        &#125;</span><br><span class="line">        for (let i = 0; i &lt;= len; i++) &#123;</span><br><span class="line">            dp[i][0][1] = Number.MIN_SAFE_INTEGER;</span><br><span class="line">        &#125;</span><br><span class="line">        //再计算最优解</span><br><span class="line">        for (let i = 1; i &lt;= len; i++) &#123;</span><br><span class="line">            for (let j = k; j &gt;= 1; j--) &#123;//从大到小从小到大都可以</span><br><span class="line">                dp[i][j][1] = Math.max(dp[i - 1][j][1], dp[i - 1][j - 1][0] - prices[i - 1]);</span><br><span class="line">                dp[i][j][0] = Math.max(dp[i - 1][j][0], dp[i - 1][j][1] + prices[i - 1]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //返回结果</span><br><span class="line">        return dp[len][k][0];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function createArray(m, n) &#123;</span><br><span class="line">        return (new Array(m).fill(0)).map(() =&gt; &#123;</span><br><span class="line">            return (new Array(n).fill(0)).map(() =&gt; &#123;</span><br><span class="line">                return (new Array(2).fill(0));</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="字符串编辑"><a href="#字符串编辑" class="headerlink" title="字符串编辑"></a>字符串编辑</h4><p><img src="/img/1600010721610.png" alt="Alt text"></p>
<h5 id="两个字符串的删除操作"><a href="#两个字符串的删除操作" class="headerlink" title="两个字符串的删除操作"></a>两个字符串的删除操作</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;string&#125; word1</span><br><span class="line"> * @param &#123;string&#125; word2</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> */</span><br><span class="line">var minDistance = function(word1, word2) &#123;</span><br><span class="line">    let len1 = word1.length;</span><br><span class="line">    let len2 = word2.length;</span><br><span class="line">    let dp = createArray(len1+1,len2+1);</span><br><span class="line"></span><br><span class="line">	//求解最大公共子串</span><br><span class="line">    for(let i = 1;i &lt;= len1;i++)&#123;</span><br><span class="line">        for(let j = 1;j &lt;= len2;j++)&#123;</span><br><span class="line">            if(word1[i-1] === word2[j-1])&#123;</span><br><span class="line">                dp[i][j] = Math.max(dp[i-1][j-1] + 1,dp[i-1][j]);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return len1 + len2 - 2 * dp[len1][len2];//最小删除数是总长度-2*最大公共子串</span><br><span class="line"></span><br><span class="line">    function createArray(m,n)&#123;</span><br><span class="line">        return (new Array(m).fill(0)).map(function()&#123;</span><br><span class="line">            return new Array(n).fill(0);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a>编辑距离</h5><p><img src="/img/1600012688212.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;string&#125; word1</span><br><span class="line"> * @param &#123;string&#125; word2</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> */</span><br><span class="line">var minDistance = function (word1, word2) &#123;</span><br><span class="line">    let len1 = word1.length;</span><br><span class="line">    let len2 = word2.length;</span><br><span class="line">    let dp = createArray(len1 + 1, len2 + 1);</span><br><span class="line">    //初始化dp[0][i] = i, dp[i][0] = i</span><br><span class="line">    for (let i = 0; i &lt;= len1; i++) &#123;</span><br><span class="line">        dp[i][0] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    for (let i = 0; i &lt;= len2; i++) &#123;</span><br><span class="line">        dp[0][i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    for (let i = 1; i &lt;= len1; i++) &#123;</span><br><span class="line">        for (let j = 1; j &lt;= len2; j++) &#123;</span><br><span class="line">            if(word1[i - 1] === word2[j - 1])&#123;</span><br><span class="line">                dp[i][j] = Math.min(dp[i-1][j-1],dp[i-1][j] + 1,dp[i][j-1]+1);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                dp[i][j] = Math.min(dp[i-1][j-1]+1,dp[i-1][j] + 1,dp[i][j-1]+1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[len1][len2];</span><br><span class="line"></span><br><span class="line">    function createArray(m, n) &#123;</span><br><span class="line">        return (new Array(m).fill(0)).map(function () &#123;</span><br><span class="line">            return new Array(n).fill(0);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="只有两个键的键盘"><a href="#只有两个键的键盘" class="headerlink" title="只有两个键的键盘"></a>只有两个键的键盘</h5><p><img src="/img/1600157565091.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var minSteps = function(n) &#123;</span><br><span class="line">    //递归边界</span><br><span class="line">    if(n === 1) return 0;</span><br><span class="line">    //先找到n的最大因子</span><br><span class="line">    let mid = Math.ceil(Math.sqrt(n));</span><br><span class="line">    let factor1 = 1;</span><br><span class="line">    let factor2 = n;</span><br><span class="line">    for(let i = n - 1;i &gt;= mid;i--)&#123;</span><br><span class="line">        if(n % i === 0)&#123;</span><br><span class="line">            factor2 = i;</span><br><span class="line">            factor1 = n / i;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //若该因子为n即该数为素数，则直接返回n</span><br><span class="line">    if(factor2 === n)&#123;</span><br><span class="line">        return n;</span><br><span class="line">    &#125;else&#123;//如果不为素数，则递归</span><br><span class="line">        return factor1 + minSteps(factor2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>markdown语法</title>
    <url>/2021/04/12/markdown%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h1 id="Markdown语法总结"><a href="#Markdown语法总结" class="headerlink" title="Markdown语法总结"></a>Markdown语法总结</h1><h2 id="笔记神器"><a href="#笔记神器" class="headerlink" title="笔记神器"></a>笔记神器</h2><a id="more"></a>

<h2 id="1、标题"><a href="#1、标题" class="headerlink" title="1、标题"></a>1、标题</h2><p>一个#是一级标题，二个#是二级标题，以此类推。支持六级标题。</p>
<p>注：标准语法一般在#后跟个空格再写文字，貌似简书不加空格也行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 这是一级标题</span><br><span class="line">## 这是二级标题</span><br><span class="line">### 这是三级标题</span><br><span class="line">#### 这是四级标题</span><br><span class="line">##### 这是五级标题</span><br><span class="line">###### 这是六级标题</span><br></pre></td></tr></table></figure>

<h2 id="2、字体"><a href="#2、字体" class="headerlink" title="2、字体"></a>2、字体</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">**这是加粗的文字**</span><br><span class="line">*这是倾斜的文字*`</span><br><span class="line">***这是斜体加粗的文字***</span><br><span class="line">~~这是加删除线的文字~~</span><br></pre></td></tr></table></figure>

<h2 id="3、引用"><a href="#3、引用" class="headerlink" title="3、引用"></a>3、引用</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;这是引用的内容</span><br><span class="line">&gt;&gt;这是引用的内容</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容</span><br></pre></td></tr></table></figure>

<p>效果图：</p>
<blockquote>
<p>这是引用的内容</p>
<blockquote>
<p>这是引用的内容</p>
</blockquote>
</blockquote>
<h2 id="4、分割线"><a href="#4、分割线" class="headerlink" title="4、分割线"></a>4、分割线</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">----</span><br><span class="line">***</span><br><span class="line">*****</span><br></pre></td></tr></table></figure>

<h2 id="5、图片"><a href="#5、图片" class="headerlink" title="5、图片"></a>5、图片</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![图片alt](图片地址 &apos;&apos;图片title&apos;&apos;)</span><br><span class="line"></span><br><span class="line">图片alt就是显示在图片下面的文字，相当于对图片内容的解释。</span><br><span class="line">图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加</span><br></pre></td></tr></table></figure>

<h2 id="6、超链接"><a href="#6、超链接" class="headerlink" title="6、超链接"></a>6、超链接</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[超链接名](超链接地址 &quot;超链接title&quot;)</span><br><span class="line">title可加可不加</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[简书](http://jianshu.com)</span><br><span class="line">[百度](http://baidu.com)</span><br></pre></td></tr></table></figure>

<p>如果想在新页面打开：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;a href=&quot;超链接地址&quot; target=&quot;_blank&quot;&gt;超链接名&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">示例</span><br><span class="line">&lt;a href=&quot;https://www.jianshu.com/u/1f5ac0cf6a8b&quot; target=&quot;_blank&quot;&gt;简书&lt;/a&gt;</span><br></pre></td></tr></table></figure>

<h2 id="7、列表"><a href="#7、列表" class="headerlink" title="7、列表"></a>7、列表</h2><h3 id="7-1、有序列表"><a href="#7-1、有序列表" class="headerlink" title="7.1、有序列表"></a>7.1、有序列表</h3><p>数字加点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 列表内容</span><br><span class="line">2. 列表内容</span><br><span class="line">3. 列表内容</span><br><span class="line"></span><br><span class="line">注意：序号跟内容之间要有空格</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<ol>
<li>列表内容</li>
<li>列表内容</li>
<li>列表内容</li>
</ol>
<h3 id="7-2、无序列表"><a href="#7-2、无序列表" class="headerlink" title="7.2、无序列表"></a>7.2、无序列表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- 列表内容</span><br><span class="line">+ 列表内容</span><br><span class="line">* 列表内容</span><br><span class="line"></span><br><span class="line">注意：- + * 跟内容之间都要有一个空格</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<ul>
<li>列表内容</li>
<li>列表内容</li>
<li>列表内容</li>
</ul>
<h2 id="8、表格"><a href="#8、表格" class="headerlink" title="8、表格"></a>8、表格</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">表头|表头|表头</span><br><span class="line">---|:--:|---:</span><br><span class="line">内容|内容|内容</span><br><span class="line">内容|内容|内容</span><br><span class="line"></span><br><span class="line">第二行分割表头和内容。</span><br><span class="line">- 有一个就行，为了对齐，多加了几个</span><br><span class="line">文字默认居左</span><br><span class="line">-两边加：表示文字居中</span><br><span class="line">-右边加：表示文字居右</span><br><span class="line">注：原生的语法两边都要用 | 包起来。此处省略</span><br></pre></td></tr></table></figure>

<h2 id="9、代码"><a href="#9、代码" class="headerlink" title="9、代码"></a>9、代码</h2><p>单行代码：代码之间分别用一个反引号包起来</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">`代码内容`</span><br></pre></td></tr></table></figure>

<p>代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">​</span><br></pre></td></tr></table></figure>

<p>  代码…<br>  代码…<br>  代码…<br>​<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">## 10、一些特殊语法</span><br><span class="line"></span><br><span class="line">空格符：</span><br></pre></td></tr></table></figure></p>
<p>从小到大：<br>小：&amp;nbsp  中：ensp  大：emsp</p>
<center>居中的内容</center>

<p>就像使用html一样，使用<br>标签或者在末尾敲击两个空格，然后回车</p>
<p><font face="黑体">我是黑体字</font><br><font color="red">我是红色</font><br><font size="5">我是5号大小</font><br><font face="黑体" color="green" size="5">我是黑体，绿色，尺寸为5</font></p>
<pre><code>
---

### 以上就是比较常用的Markdown语法，日常生活一定够用了，特殊情况请找无所不知的百度大明白！
</code></pre>]]></content>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>Canvas绘图及描框</title>
    <url>/2021/03/22/Canvas%E7%BB%98%E5%9B%BE%E5%8F%8A%E6%8F%8F%E6%A1%86/</url>
    <content><![CDATA[<h1 id="canvas绘制图片和画识别框问题"><a href="#canvas绘制图片和画识别框问题" class="headerlink" title="canvas绘制图片和画识别框问题"></a>canvas绘制图片和画识别框问题</h1><h2 id="canvas知识"><a href="#canvas知识" class="headerlink" title="canvas知识"></a>canvas知识</h2><a id="more"></a>

<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>先说一下业务需求，此处的功能是用于微信OCR文字识别的PC端和小程序端应用。要求上传本地图片后，图片以及识别结果能够展示，为便于测试要求在识别图片上对识别的文字用矩形框及序号框出，与结果一一对应。</p>
<p><font color="orange">记录下此处的实现方法及难点：</font></p>
<p>1、首先图片显示不要使用img标签，使用canvas来描绘，我们需要得到的是img的宽高属性。小程序使用：wx.getImageInfo，vue中直接new Image()</p>
<p>2、我们要知道两个比例：（1）图片与画布的比例，用于图片自适应画布大小。（2）图片自身缩放比例，<br>用于识别框同比例缩放。</p>
<p>3、计算居中显示的偏移量：（画布-图片）/2；调用canvas的api接口绘图ctx.drawImage</p>
<p>4、根据后台返回的坐标点（原图）进行描框和缩放ctx.strokeRect，对序号框字体进行优化，自适应框的大小，此处小程序和pc不同。</p>
<h3 id="分别附带小程序及vue的完整代码"><a href="#分别附带小程序及vue的完整代码" class="headerlink" title="分别附带小程序及vue的完整代码"></a>分别附带小程序及vue的完整代码</h3><h4 id="小程序："><a href="#小程序：" class="headerlink" title="小程序："></a>小程序：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">canvasToFile(ctx) &#123;</span><br><span class="line">    const cWidth = 640,</span><br><span class="line">      cHeight = 480;</span><br><span class="line">    console.log(&apos;画布宽：&apos; + cWidth)</span><br><span class="line">    console.log(&apos;画布高：&apos; + cHeight)</span><br><span class="line"></span><br><span class="line">    wx.getImageInfo(&#123;</span><br><span class="line">      src: SRC,</span><br><span class="line">      success: res =&gt; &#123;</span><br><span class="line">        console.log(res)</span><br><span class="line">        // 原始图大小</span><br><span class="line">        let imgWidth = res.width,</span><br><span class="line">          imgHeight = res.height;</span><br><span class="line">        // 相对画布等比例缩放</span><br><span class="line">        let n = 1;</span><br><span class="line">        if (imgWidth &gt; imgHeight) &#123;</span><br><span class="line">          n = imgWidth / cWidth;</span><br><span class="line">          imgWidth = cWidth;</span><br><span class="line">          imgHeight = imgHeight / n;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          n = imgHeight / cHeight;</span><br><span class="line">          imgHeight = cHeight;</span><br><span class="line">          imgWidth = imgWidth / n;</span><br><span class="line">        &#125;</span><br><span class="line">        // 图片自身缩放比例</span><br><span class="line">        let widthScal = imgWidth / res.width</span><br><span class="line">        console.log(widthScal)</span><br><span class="line">        console.log(&apos;imgWidth:&apos; + imgWidth)</span><br><span class="line">        console.log(&apos;imgHeight:&apos; + imgHeight)</span><br><span class="line">        console.log(cWidth)</span><br><span class="line">        console.log(cHeight)</span><br><span class="line">        let zoom = &#123;</span><br><span class="line">          width: widthScal,</span><br><span class="line">          height: widthScal</span><br><span class="line">        &#125;</span><br><span class="line">        // 偏移x,y位移量</span><br><span class="line">        let right_move = (cWidth - imgWidth) / 2;</span><br><span class="line">        let bottom_move = (cHeight - imgHeight) / 2;</span><br><span class="line">        console.log(&apos;right_move:&apos; + right_move)</span><br><span class="line">        console.log(&apos;bottom_move:&apos; + bottom_move)</span><br><span class="line">        // 获取预览画布上下文</span><br><span class="line">        const c_t_x = wx.createCanvasContext(&apos;canvas_pre&apos;)</span><br><span class="line">        // 缩放展示画布图片</span><br><span class="line">        ctx.scale(0.5, 0.5)</span><br><span class="line">        ctx.drawImage(SRC, right_move, bottom_move, imgWidth, imgHeight)</span><br><span class="line">        c_t_x.drawImage(SRC, right_move, bottom_move, imgWidth, imgHeight)</span><br><span class="line">        ctx.draw()</span><br><span class="line">        c_t_x.draw()</span><br><span class="line">        // 画矩形识别框</span><br><span class="line">        setTimeout(function() &#123;</span><br><span class="line">          let value = wx.getStorageSync(&apos;ocr&apos;)</span><br><span class="line">          if (value.hasOwnProperty(&apos;items&apos;)) &#123;</span><br><span class="line">            console.log(value)</span><br><span class="line">            let length = value.items.length</span><br><span class="line">            let item = value.items</span><br><span class="line">            for (let i = 0; i &lt; length; i++) &#123;</span><br><span class="line">              let show = item[i]</span><br><span class="line">              // 原图坐标</span><br><span class="line">              let X1 = show.pos.left_top.x</span><br><span class="line">              let Y1 = show.pos.left_top.y</span><br><span class="line">              let X2 = show.pos.right_bottom.x</span><br><span class="line">              let Y2 = show.pos.right_bottom.y</span><br><span class="line">              let startPoint = [X1, Y1],</span><br><span class="line">                endPoint = [X2, Y2];</span><br><span class="line">              // console.log(startPoint)</span><br><span class="line">              // console.log(endPoint)</span><br><span class="line">              // 等比例缩放坐标</span><br><span class="line">              let Num_x = startPoint[0] * zoom.width + right_move</span><br><span class="line">              let Num_y = startPoint[1] * zoom.height + bottom_move</span><br><span class="line">              let Num_width = (endPoint[0] - startPoint[0]) * zoom.width</span><br><span class="line">              let Num_height = (endPoint[1] - startPoint[1]) * zoom.height</span><br><span class="line">              ctx.setStrokeStyle(&apos;blue&apos;)</span><br><span class="line">              c_t_x.setStrokeStyle(&apos;blue&apos;)</span><br><span class="line">              // 分别画两个画布的矩形框</span><br><span class="line">              c_t_x.strokeRect(Num_x, Num_y, Num_width, Num_height)</span><br><span class="line">              ctx.strokeRect(Num_x, Num_y, Num_width, Num_height);</span><br><span class="line">              // 区分文字横向，竖向展示时，数字框位置</span><br><span class="line">              if (Num_width &lt; Num_height) &#123;</span><br><span class="line">                let top_x = Num_x</span><br><span class="line">                let top_y = (startPoint[1] - (endPoint[0] - startPoint[0])) * zoom.height + bottom_move</span><br><span class="line">                let w_h = Num_width</span><br><span class="line">                ctx.setFontSize(w_h)</span><br><span class="line">                c_t_x.setFontSize(w_h)</span><br><span class="line">                ctx.setStrokeStyle(&apos;#006bff&apos;)</span><br><span class="line">                c_t_x.setStrokeStyle(&apos;#006bff&apos;)</span><br><span class="line">                ctx.setFillStyle(&apos;#006bff&apos;)</span><br><span class="line">                c_t_x.setFillStyle(&apos;#006bff&apos;)</span><br><span class="line">                ctx.fillText(i + 1, Num_x + (w_h / 2), Num_y, w_h)</span><br><span class="line">                c_t_x.fillText(i + 1, Num_x + (w_h / 2), Num_y, w_h)</span><br><span class="line">                ctx.strokeRect(top_x, top_y, w_h, w_h)</span><br><span class="line">                c_t_x.strokeRect(top_x, top_y, w_h, w_h)</span><br><span class="line">                ctx.setTextAlign(&apos;center&apos;)</span><br><span class="line">                c_t_x.setTextAlign(&apos;center&apos;)</span><br><span class="line">              &#125; else &#123;</span><br><span class="line">                let left_X = (startPoint[0] - (endPoint[1] - startPoint[1])) * zoom.width + right_move</span><br><span class="line">                let left_Y = Num_y</span><br><span class="line">                let W_H = Num_height</span><br><span class="line">                ctx.setFontSize(W_H)</span><br><span class="line">                ctx.setStrokeStyle(&apos;#006bff&apos;)</span><br><span class="line">                ctx.setFillStyle(&apos;#006bff&apos;)</span><br><span class="line">                ctx.fillText(i + 1, left_X + W_H / 2, left_Y + W_H, W_H)</span><br><span class="line">                ctx.strokeRect(left_X, left_Y, W_H, W_H)</span><br><span class="line">                ctx.setTextAlign(&apos;center&apos;)</span><br><span class="line">                c_t_x.setFontSize(W_H)</span><br><span class="line">                c_t_x.setStrokeStyle(&apos;#006bff&apos;)</span><br><span class="line">                c_t_x.setFillStyle(&apos;#006bff&apos;)</span><br><span class="line">                c_t_x.fillText(i + 1, left_X + W_H / 2, left_Y + W_H, W_H)</span><br><span class="line">                c_t_x.strokeRect(left_X, left_Y, W_H, W_H)</span><br><span class="line">                c_t_x.setTextAlign(&apos;center&apos;)</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ctx.draw(true)</span><br><span class="line">            // 导出图片到url数组中，注意像素值</span><br><span class="line">            c_t_x.draw(true, setTimeout(function() &#123;</span><br><span class="line">              let dpr = wx.getSystemInfoSync().pixelRatio</span><br><span class="line">              console.log(dpr)</span><br><span class="line">              wx.canvasToTempFilePath(&#123;</span><br><span class="line">                x: right_move,</span><br><span class="line">                y: bottom_move,</span><br><span class="line">                width: imgWidth,</span><br><span class="line">                height: imgHeight,</span><br><span class="line">                destWidth: imgWidth * dpr,</span><br><span class="line">                destHeight: imgHeight * dpr,</span><br><span class="line">                canvasId: &apos;canvas_pre&apos;,</span><br><span class="line">                success(res) &#123;</span><br><span class="line">                  console.log(res)</span><br><span class="line">                  url.push(res.tempFilePath)</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;)</span><br><span class="line">            &#125;, 100));</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, 1200)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>

<p>这里有两个canvas，是因为公司新加的一个需求：点击图片放大预览，同时识别框也要放大。但是在同一画布内使用wx.canvasToTempFilePath导成图片后，预览的图片很模糊，网上也有些方法，但并不起作用。所以我使用两个画布，一个画布展示图片和识别框，另一个定位在屏幕外用于预览图片，预览画布宽高是展示画布的2倍。即可解决模糊问题。</p>
<p>在onload调用该方法并初始化：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const ctx = wx.createCanvasContext(&apos;canvas&apos;)</span><br><span class="line">ctx.clearRect(0, 0, 320, 240)</span><br><span class="line">ctx.draw()</span><br><span class="line">this.canvasToFile(ctx)</span><br></pre></td></tr></table></figure>

<h3 id="vue中实现："><a href="#vue中实现：" class="headerlink" title="vue中实现："></a>vue中实现：</h3><p>调canvas组件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;Canvas @upload=&quot;upload&quot; :result_show=&quot;result_title&quot;</span><br><span class="line">          :list=&quot;ocr_comm&quot; :show=&quot;loading&quot; :err=&quot;err&quot;&gt;&lt;/Canvas&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import Canvas from &apos;components/HomeChildren/Canvas/Canvas&apos;</span><br><span class="line"></span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &quot;ocr_comm&quot;,</span><br><span class="line">    components: &#123;</span><br><span class="line">      Canvas</span><br><span class="line">    &#125;,</span><br><span class="line">    data() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        CW: &apos;400px&apos;,</span><br><span class="line">        CH: &apos;400px&apos;,</span><br><span class="line">        result_title: &apos;通用OCR识别结果&apos;,</span><br><span class="line">        ocr_comm: [],</span><br><span class="line">        loading: false,</span><br><span class="line">        err: false</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>

<p>图片自适应及绘图，使用async解决异步影响：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">async upload(file, canvas) &#123;</span><br><span class="line">        // console.log(file)</span><br><span class="line">        if (!file) return;</span><br><span class="line">        // 加载图标显示</span><br><span class="line">        this.loading = true</span><br><span class="line">        // 图片缩放比例</span><br><span class="line">        let widthScal = 0</span><br><span class="line">        // 先基于FileReader进行文件的读取</span><br><span class="line">        let fileExample = new FileReader();</span><br><span class="line">        // console.dir(fileExample)</span><br><span class="line">        fileExample.readAsDataURL(file);</span><br><span class="line">        fileExample.onload = ev =&gt; &#123;</span><br><span class="line">          // 创建新图片</span><br><span class="line">          // console.dir(ev)</span><br><span class="line">          this.IMAGE = new Image();</span><br><span class="line">          this.IMAGE.src = ev.target.result;</span><br><span class="line">          this.IMAGE.onload = () =&gt; &#123;</span><br><span class="line">            this.IW = this.IMAGE.width;</span><br><span class="line">            this.IH = this.IMAGE.height;</span><br><span class="line">            const NCW = parseInt(this.CW);</span><br><span class="line">            const NCH = parseInt(this.CW);</span><br><span class="line">            // 重新按照比例计算宽高</span><br><span class="line">            let n = 1;</span><br><span class="line">            if (this.IW &gt; this.IH) &#123;</span><br><span class="line">              n = this.IW / NCW;</span><br><span class="line">              this.IW = NCW;</span><br><span class="line">              this.IH = this.IH / n;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">              n = this.IH / NCH;</span><br><span class="line">              this.IH = NCH;</span><br><span class="line">              this.IW = this.IW / n;</span><br><span class="line">            &#125;</span><br><span class="line">            this.IL = (NCW - this.IW) / 2;</span><br><span class="line">            this.IT = (NCH - this.IH) / 2;</span><br><span class="line">            widthScal = this.IW / this.IMAGE.width;</span><br><span class="line">            // console.log(zoom.width)</span><br><span class="line">            // 绘制图片</span><br><span class="line">            this.CTX = canvas.getContext(&quot;2d&quot;);</span><br><span class="line">            // 清空画布</span><br><span class="line">            this.CTX.clearRect(0, 0, parseInt(this.CW), parseInt(this.CH));</span><br><span class="line">            // 绘制图片</span><br><span class="line">            this.CTX.drawImage(this.IMAGE, this.IL, this.IT, this.IW, this.IH);</span><br><span class="line">          &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        //上传文件</span><br><span class="line">        await this.uploadImg(file)</span><br><span class="line">        this.strokeRect(widthScal)</span><br><span class="line">      &#125;,</span><br></pre></td></tr></table></figure>

<p>描框代码，这里的序号字体自适应使用字符串拼接形式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">strokeRect(widthScal) &#123;</span><br><span class="line">        if (this.ocr_comm.length !== 0) &#123;</span><br><span class="line">          for (let i = 0; i &lt; this.ocr_comm.length; i++) &#123;</span><br><span class="line">            // console.log(this.ocr_comm)</span><br><span class="line">            let show = this.ocr_comm[i]</span><br><span class="line">            // 原图坐标</span><br><span class="line">            // console.log(show)</span><br><span class="line">            let X1 = show.pos.left_top.x</span><br><span class="line">            let Y1 = show.pos.left_top.y</span><br><span class="line">            let X2 = show.pos.right_bottom.x</span><br><span class="line">            let Y2 = show.pos.right_bottom.y</span><br><span class="line">            let startPoint = [X1, Y1],</span><br><span class="line">              endPoint = [X2, Y2];</span><br><span class="line">            let Num_x = startPoint[0] * widthScal + this.IL</span><br><span class="line">            let Num_y = startPoint[1] * widthScal + this.IT</span><br><span class="line">            let Num_width = (endPoint[0] - startPoint[0]) * widthScal</span><br><span class="line">            let Num_height = (endPoint[1] - startPoint[1]) * widthScal</span><br><span class="line">            this.CTX.strokeStyle = &apos;blue&apos;;</span><br><span class="line">            this.CTX.strokeRect(Num_x, Num_y, Num_width, Num_height);</span><br><span class="line">            if (Num_width &lt; Num_height) &#123;</span><br><span class="line">              let top_x = Num_x</span><br><span class="line">              let top_y = (startPoint[1] - (endPoint[0] - startPoint[0])) * widthScal + this.IT</span><br><span class="line">              let w_h = Num_width</span><br><span class="line">              // console.log(w_h)</span><br><span class="line">              let fontsize=w_h+&apos;px&apos;</span><br><span class="line">              let fontFamily=&quot;宋体&quot;</span><br><span class="line">              let Num_font=fontsize+&apos; &apos;+fontFamily</span><br><span class="line">              this.CTX.font=Num_font</span><br><span class="line">              this.CTX.strokeStyle = &apos;#006bff&apos;</span><br><span class="line">              this.CTX.fillStyle = &apos;#006bff&apos;</span><br><span class="line">              this.CTX.fillText(i + 1, Num_x + (w_h / 2), Num_y, w_h)</span><br><span class="line">              this.CTX.strokeRect(top_x, top_y, w_h, w_h)</span><br><span class="line">              this.CTX.textAlign = &apos;center&apos;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">              let left_X = (startPoint[0] - (endPoint[1] - startPoint[1])) * widthScal + this.IL</span><br><span class="line">              let left_Y = Num_y</span><br><span class="line">              let W_H = Num_height</span><br><span class="line">              let fontsize=W_H+&apos;px&apos;</span><br><span class="line">              let fontFamily=&quot;宋体&quot;</span><br><span class="line">              let Num_font=fontsize+&apos; &apos;+fontFamily</span><br><span class="line">              this.CTX.font=Num_font</span><br><span class="line">              this.CTX.strokeStyle = &apos;#006bff&apos;</span><br><span class="line">              this.CTX.fillStyle = &apos;#006bff&apos;</span><br><span class="line">              this.CTX.fillText(i + 1, left_X + W_H / 2, left_Y + W_H, W_H)</span><br><span class="line">              this.CTX.strokeRect(left_X, left_Y, W_H, W_H)</span><br><span class="line">              this.CTX.textAlign = &apos;center&apos;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          console.log(&quot;数据未取到&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br></pre></td></tr></table></figure>

<p>上传代码到后台服务器，前端使用api代理解决跨域问题：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">async uploadImg(file) &#123;</span><br><span class="line">        var forms = new FormData();</span><br><span class="line">        forms.append(&apos;file&apos;, file)</span><br><span class="line">        let config = &#123;</span><br><span class="line">          headers: &#123;&apos;Content-Type&apos;: &apos;multipart/form-data&apos;&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        await this.$axios.post(&apos;/apidebug_imagequery?action=ocr_comm&apos;, forms, config)</span><br><span class="line">          .then(res =&gt; &#123;</span><br><span class="line">            console.log(res);</span><br><span class="line">            this.loading = false</span><br><span class="line">            if (res.data.ocrcomm_res.items.length !== 0) &#123;</span><br><span class="line">              this.ocr_comm = res.data.ocrcomm_res.items</span><br><span class="line">              console.log(this.ocr_comm)</span><br><span class="line">              this.err = false</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">              this.ocr_comm = []</span><br><span class="line">              this.err = true</span><br><span class="line">            &#125;</span><br><span class="line">            // resolve(this.ocr_comm)</span><br><span class="line">          &#125;).catch(err =&gt; &#123;</span><br><span class="line">            //补充异常处理代码</span><br><span class="line">            console.log(err)</span><br><span class="line">          &#125;)</span><br><span class="line">      &#125;,</span><br></pre></td></tr></table></figure>

<p>至此！canvas的相关实现就是这些，图片预览仅用于小程序中，解决模糊问题是难点。canvas远比自己想的强大，现在所知也是九牛一毛，以后再会~！</p>
]]></content>
      <tags>
        <tag>html5</tag>
        <tag>canvas</tag>
      </tags>
  </entry>
  <entry>
    <title>节流和防抖</title>
    <url>/2020/12/01/%E8%8A%82%E6%B5%81%E5%92%8C%E9%98%B2%E6%8A%96/</url>
    <content><![CDATA[<h1 id="性能优化问题"><a href="#性能优化问题" class="headerlink" title="性能优化问题"></a>性能优化问题</h1><h2 id="Js知识"><a href="#Js知识" class="headerlink" title="Js知识"></a>Js知识</h2><a id="more"></a>

<h3 id="防抖与节流"><a href="#防抖与节流" class="headerlink" title="防抖与节流"></a>防抖与节流</h3><p>防抖与节流是前端最基本的优化技巧，实现很简单，为了记录下，可供学习参考。</p>
<h4 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h4><h5 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h5><p>防抖就是在持续触发事件的时候，只有当不触发事件一段时间后才会执行处理的函数，当触发一次事件后，在规定事件内再次触发， 就会清除上次的定时任务，重新创建定时任务。</p>
<ul>
<li>实现方式：每次触发事件时设置一个延迟调用方法，并且取消之前的延时调用方法</li>
<li>缺点：如果事件在规定的时间间隔内被不断的触发，则调用方法会被不断的延迟</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//防抖debounce代码：</span><br><span class="line">function debounce(fn,delay) &#123;</span><br><span class="line">    var timeout = null; // 创建一个标记用来存放定时器的返回值</span><br><span class="line">    return function (e) &#123;</span><br><span class="line">        // 每当用户输入的时候把前一个 setTimeout clear 掉</span><br><span class="line">        clearTimeout(timeout); </span><br><span class="line">        // 然后又创建一个新的 setTimeout, 这样就能保证interval 间隔内如果时间持续触发，就不会执行 fn 函数</span><br><span class="line">        timeout = setTimeout(() =&gt; &#123;</span><br><span class="line">            fn.apply(this, arguments);</span><br><span class="line">        &#125;, delay);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">// 处理函数</span><br><span class="line">function handle() &#123;</span><br><span class="line">    console.log(&apos;防抖：&apos;, Math.random());</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">//滚动事件</span><br><span class="line">window.addEventListener(&apos;scroll&apos;, debounce(handle,500));</span><br></pre></td></tr></table></figure>

<h4 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h4><h5 id="概念：-1"><a href="#概念：-1" class="headerlink" title="概念："></a>概念：</h5><p>节流就是在持续触发事件的时候，利用标志位进行控制处理函数是否执行，比如为 true 执行，为 false 不执行<br>通过指定间隔时间修改标志位的值即可实现在指定时间内只触发一次处理函数</p>
<ul>
<li>实现方式：每次触发事件时，如果当前有等待执行的延时函数，则直接return<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//节流throttle代码：</span><br><span class="line">function throttle(fn,delay) &#123;</span><br><span class="line">    let canRun = true; // 通过闭包保存一个标记</span><br><span class="line">    return function () &#123;</span><br><span class="line">         // 在函数开头判断标记是否为true，不为true则return</span><br><span class="line">        if (!canRun) return;</span><br><span class="line">         // 立即设置为false</span><br><span class="line">        canRun = false;</span><br><span class="line">        // 将外部传入的函数的执行放在setTimeout中</span><br><span class="line">        setTimeout(() =&gt; &#123; </span><br><span class="line">        // 最后在setTimeout执行完毕后再把标记设置为true(关键)表示可以执行下一次循环了。</span><br><span class="line">        // 当定时器没有执行的时候标记永远是false，在开头被return掉</span><br><span class="line">            fn.apply(this, arguments);</span><br><span class="line">            canRun = true;</span><br><span class="line">        &#125;, delay);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">function sayHi(e) &#123;</span><br><span class="line">    console.log(&apos;节流：&apos;, e.target.innerWidth, e.target.innerHeight);</span><br><span class="line">&#125;</span><br><span class="line">window.addEventListener(&apos;resize&apos;, throttle(sayHi,500));</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><strong>函数防抖</strong>：将多次操作合并为一次操作进行。原理是维护一个计时器，规定在delay时间后触发函数，但是在delay时间内再次触发的话，就会取消之前的计时器而重新设置。这样一来，只有最后一次操作能被触发。<br><strong>函数节流</strong>：使得一定时间内只触发一次函数。原理是通过判断是否有延迟调用函数未执行。<br><strong>区别</strong>： 函数节流不管事件触发有多频繁，都会保证在规定时间内一定会执行一次真正的事件处理函数，而函数防抖只是在最后一次事件后才触发一次函数。 比如在页面的无限加载场景下，我们需要用户在滚动页面时，<br>每隔一段时间发一次 Ajax 请求，而不是在用户停下滚动页面操作时才去请求数据。这样的场景，就适合用节流技术来实现。</p>
]]></content>
      <tags>
        <tag>Js</tag>
        <tag>Js封装</tag>
      </tags>
  </entry>
  <entry>
    <title>Js同步与异步</title>
    <url>/2020/11/05/JS%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5/</url>
    <content><![CDATA[<h1 id="Js的同步与异步问题"><a href="#Js的同步与异步问题" class="headerlink" title="Js的同步与异步问题"></a>Js的同步与异步问题</h1><h2 id="Js知识"><a href="#Js知识" class="headerlink" title="Js知识"></a>Js知识</h2><a id="more"></a>

<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>如果有人问你Js的同步异步问题，你该怎么回答？理解一个问题无非是what-why-how，js同步和异步问题是什么–&gt;为什么会产生异步问题–&gt;如何解决。</p>
<blockquote>
<p>首先，我们要知道Js是单线程的，同一时间只处理一个任务，这已经成这门语言的核心特征。</p>
</blockquote>
<h3 id="同步与异步（重点）"><a href="#同步与异步（重点）" class="headerlink" title="同步与异步（重点）"></a>同步与异步（重点）</h3><p><font color="orange">同步</font>就是任务放入到队列中后按照顺序执行；<br><font color="orange">异步</font>就是同时进行多个任务。<br>举个例子：比方说你要烧水做菜，如果你先烧水，等着水烧开，再去做菜，这就是同步操作；但如果你边烧着水，同时准备做菜材料，同时进行，这就是异步操作；<br>&nbsp;<br>js单线程是执行同步操作的，但有时也需要异步操作，防止某一块解析时间过长，造成“卡死”情况。<br>那么，js单线程又是如何实现异步的呢? ——<strong>是通过事件循环实现“异步”</strong><br>js中，最基础的异步是setTimeout和setInterval函数，还有onclick, ajax等异步操作。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> console.log(&apos;1&apos;)</span><br><span class="line">setTimeout(function()&#123;</span><br><span class="line"> console.log(&apos;2&apos;)</span><br><span class="line">&#125;,0)</span><br><span class="line">console.log(&apos;3&apos;)  </span><br><span class="line">//输出       1，3，2</span><br></pre></td></tr></table></figure>

<h3 id="promise解决异步问题"><a href="#promise解决异步问题" class="headerlink" title="promise解决异步问题"></a>promise解决异步问题</h3><p>promise解决嵌套回调的问题，将嵌套的回调函数改成.then()的连缀使用。<br>Promise有这些特征：只能决议一次，决议值只能有一个，决议之后无法改变。任何then中的回调也只会被调用一次。Promise的特征保证了Promise可以解决信任问题。</p>
<h4 id="promise-的使用"><a href="#promise-的使用" class="headerlink" title="promise 的使用"></a>promise 的使用</h4><blockquote>
<p>首先通过new Promise（function）创建一个promise对象，接收一个函数参数，并且在函数中传入resolve以及reject两个参数；</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var p = new Promise(function(resolve, reject)&#123;      </span><br><span class="line">            //做一些异步操作</span><br><span class="line">            setTimeout(function()&#123;</span><br><span class="line">                console.log(&apos;这是一个异步操作&apos;);</span><br><span class="line">                resolve(&apos;异步操作成功并且结束&apos;);</span><br><span class="line">            &#125;, 1000);</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>then() 接收两个函数，分别是对promise的resolve及reject状态处理的函数，并且处理结束之后返回promise对象</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function fn1() &#123;</span><br><span class="line">       console.log(&quot;第一个函数开始执行&quot;);</span><br><span class="line">       var p = new Promise(function (resolve, reject) &#123;</span><br><span class="line">           setTimeout(function () &#123;</span><br><span class="line">               console.log(&apos;第一个函数执行完毕&apos;);</span><br><span class="line">               resolve(&apos;接下来进入第二个函数&apos;);</span><br><span class="line">           &#125;, 1000);</span><br><span class="line">       &#125;);</span><br><span class="line">       return p;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   function fn2(data) &#123;</span><br><span class="line">       console.log(data);</span><br><span class="line">       console.log(&apos;第二个函数开始执行&apos;);</span><br><span class="line">       var p = new Promise(function (resolve, reject) &#123;</span><br><span class="line">           setTimeout(function () &#123;</span><br><span class="line">               var num = Math.ceil(Math.random() * 10); // 生成随机数</span><br><span class="line">              console.log(num);</span><br><span class="line">               //num = 0；设置num=0</span><br><span class="line">               if (num === 0) &#123;</span><br><span class="line">                   console.log(&apos;第二个函数执行完毕&apos;);</span><br><span class="line">                   resolve(&apos;所有函数执行完毕&apos;);</span><br><span class="line">               &#125;</span><br><span class="line">               else&#123;</span><br><span class="line">                   reject(&quot;执行函数2失败&quot;);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;, 2000);</span><br><span class="line">       &#125;);</span><br><span class="line">       return p;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   fn1()</span><br><span class="line">       .then(function (data) &#123;</span><br><span class="line">           return fn2(data);</span><br><span class="line">       &#125;)</span><br><span class="line">       .then(function (data) &#123;</span><br><span class="line">           console.log(data);</span><br><span class="line">       &#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li><em>第一个函数开始执行</em></li>
<li><em>第一个函数执行完毕</em></li>
<li><em>接下来进入第二个函数</em></li>
<li><em>第二个函数开始执行</em></li>
<li><em>第二个函数执行完毕</em></li>
<li><em>所有函数执行完毕</em><br>&emsp;&emsp;<font size="2">调用reslove</font></li>
</ul>
<p>.all() 接收一个函数数组，进行并发操作，并将每个函数的结果以数组的形式返回。<br>.race()接收函数数组，函数先执行完成之后先进入下一个回调函数中。<br>.catch() 当then中出现错误时不会中止整个函数，catch能够获取到错误并进行提示。   </p>
<h2 id="这几种方法不做详述啦！会用即可，好了！今天先到这里，我们下期见"><a href="#这几种方法不做详述啦！会用即可，好了！今天先到这里，我们下期见" class="headerlink" title="这几种方法不做详述啦！会用即可，好了！今天先到这里，我们下期见!"></a>这几种方法不做详述啦！会用即可，好了！今天先到这里，我们下期见!</h2>]]></content>
      <tags>
        <tag>Js</tag>
        <tag>解决异步</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue双向绑定原理</title>
    <url>/2020/10/23/Vue%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="详述Vue的数据双向绑定原理"><a href="#详述Vue的数据双向绑定原理" class="headerlink" title="详述Vue的数据双向绑定原理"></a>详述Vue的数据双向绑定原理</h1><h2 id="前端知识"><a href="#前端知识" class="headerlink" title="前端知识"></a>前端知识</h2><a id="more"></a>

<blockquote>
<p>Vue实现双向数据绑定的原理就是利用了 Object.defineProperty() 这个方法重新定义了对象获取属性值(get)和设置属性值(set)的操作来实现的。</p>
</blockquote>
<p>另一种说法：vue的双向绑定是由数据劫持结合发布者－订阅者模式实现的。（这里不懂没关系，接着往下看…）<br>首先，我们我们需要一个监听器Observer来给所有的属性设置set函数。如果属性发生了变化，就要通知所有的订阅者Watcher。而这些Watcher统一存放在消息订阅器Dep中，这样比较方便统一管理。Watcher接受到来自Dep的通知后就执行相应的操作去更新视图。<br>&nbsp;</p>
<h3 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h3><blockquote>
<p>监听器的核心代码如下：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function observe(data) &#123;</span><br><span class="line">  if (!data || typeof data !== &apos;object&apos;) &#123;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  Object.keys(data).forEach(function(key) &#123;  // 遍历属性，递归设置set函数</span><br><span class="line">    defineReactive(data, key, data[key]);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">function defineReactive(data, key, val) &#123;</span><br><span class="line">  observe(val)</span><br><span class="line">  var dep = new Dep()</span><br><span class="line">  Object.defineProperty(data, key, &#123;</span><br><span class="line">    enumerable: true,</span><br><span class="line">    configurable: true,</span><br><span class="line">    get: function() &#123;</span><br><span class="line">      if (Dep.target) &#123;</span><br><span class="line">        dep.addSub(Dep.target)  // 添加watcher</span><br><span class="line">      &#125;</span><br><span class="line">      return val</span><br><span class="line">    &#125;,</span><br><span class="line">    set: function(newVal) &#123;</span><br><span class="line">      if (val === newVal) &#123;</span><br><span class="line">        return;</span><br><span class="line">      &#125;</span><br><span class="line">      val = newVal;</span><br><span class="line">      dep.notify()  // 通知dep</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过调用observe（）函数来递归地给data对象设置set和get函数，在data的属性被get时添加watcher，被set时通知dep，dep的notify会接着通知所有的watcher去执行更新操作。<br>&nbsp;<br>这里需要对defineProperty做一个补充，上述的observe递归过程，在value值为对象时会继续递归，只有当value值是非对象时才return，然后调用definePropery。所以对于data里面的数组arr，vue实际监听的是arr[0]、arr[1]…arr[n]，而不是arr本身。所以对于改变arr的操作，arr[0] = 9这样是可以被监听到的，而arr.push(‘123’)这样是不行的，因为push方法本质上只是改变了arr[n+1]的值，而这个值本身是没有被监听的，即没有设置set函数。<br>vue为了方便我们对数组的操作，对数组的一些常用方法进行额外的封装，即对vue的data的属性的原型赋值为封装层，当我们使用this.arr.push时，根据原型链向上找会先找到封装层的push，而不会使用原生的push。封装层的push做的事情是先触发原生push方法，然后再监听新push的项，再触发消息订阅器dep的notify方法，从而提醒watcher去更新视图。<br>&nbsp;</p>
<h3 id="Dep"><a href="#Dep" class="headerlink" title="Dep"></a>Dep</h3><blockquote>
<p>消息订阅器的核心代码如下：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Dep() &#123;</span><br><span class="line">  this.subs = []  // 订阅者数组</span><br><span class="line">&#125;</span><br><span class="line">Dep.prototype = &#123;</span><br><span class="line">  addSub: function(sub) &#123;</span><br><span class="line">    this.subs.push(sub)</span><br><span class="line">  &#125;,</span><br><span class="line">  notify: function() &#123;</span><br><span class="line">    this.subs.forEach(function(sub) &#123;</span><br><span class="line">      sub.update()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Dep.target = null</span><br></pre></td></tr></table></figure>

<p>消息订阅器比较简单，就是维护一个subs数组。当监听新属性时把它push进subs数组中，然后dep被通知时触发notify函数，从而触发subs数组中每个watcher的update操作。<br>&nbsp;</p>
<h3 id="Watcher"><a href="#Watcher" class="headerlink" title="Watcher"></a>Watcher</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Watcher(vm, exp, cb) &#123;</span><br><span class="line">  this.cb = cb</span><br><span class="line">  this.vm = vm</span><br><span class="line">  this.exp = exp</span><br><span class="line">  this.value = this.get()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Watcher.prototype = &#123;</span><br><span class="line">  update: function() &#123;</span><br><span class="line">    this.run()</span><br><span class="line">  &#125;,</span><br><span class="line">  run: function() &#123;</span><br><span class="line">    var value = this.vm.data[this.exp]</span><br><span class="line">    var oldVal = this.value</span><br><span class="line">    if (value !== oldVal) &#123;</span><br><span class="line">      this.value = value</span><br><span class="line">      this.cb.call(this.vm, value, oldVal)  // 执行更新时的回调函数</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  get: function() &#123;</span><br><span class="line">    Dep.target = this</span><br><span class="line">    var value = this.vm.data[this.exp]  // 读取data的属性，从而执行属性的get函数</span><br><span class="line">    Dep.target = null</span><br><span class="line">    return value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Watcher的主要功能是去触发属性的get函数，从而添加watcher到Dep的subs数组中。另外就是在update()中更新属性的值并触发更新回调函数。<br>使用Watcher的方法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var el = document.getElementById(&apos;XXX&apos;)</span><br><span class="line">observe(data)</span><br><span class="line">new Watcher(vm, exp, function(value) &#123;  // vm表示某个实例,exp表示属性名</span><br><span class="line">  el.innerHTML = value</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>为了使用时的整洁，我们需要把代码稍微包装下。</p>
<h3 id="SimpleVue"><a href="#SimpleVue" class="headerlink" title="SimpleVue"></a>SimpleVue</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function SimpleVue (data, el, exp) &#123;</span><br><span class="line">  var self = this</span><br><span class="line">  this.data = data</span><br><span class="line">  Object.keys(data).forEach(function(key) &#123;</span><br><span class="line">    self.proxyKeys(key)</span><br><span class="line">  &#125;)</span><br><span class="line">  observe(data)</span><br><span class="line">  el.innerHTML = this.data[exp]</span><br><span class="line">  new Watcher(this, exp, function(value) &#123;</span><br><span class="line">    el.innerHTML = value</span><br><span class="line">  &#125;)</span><br><span class="line">  return this</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SimpleVue.prototype = &#123;</span><br><span class="line">  proxyKeys: function(key) &#123;</span><br><span class="line">    var self = this</span><br><span class="line">    Object.defineProperty(this, key, &#123;</span><br><span class="line">      enumerable: false,</span><br><span class="line">      configurable: true,</span><br><span class="line">      get: function() &#123;</span><br><span class="line">        return self.data[key]</span><br><span class="line">      &#125;,</span><br><span class="line">      set: function(newVal) &#123;</span><br><span class="line">        self.data[key] = newVal</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SimpleVue做的事情就是使用observe递归地给data的每个属性都加上get和set，然后对于要监听的属性exp新建一个Watcher对象去监听。（Watcher对象触发属性exp的get函数从而添加订阅事件到Dep，而且会在属性的update方法里面触发监听回调函数）<br>使用如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// html</span><br><span class="line">&lt;h1 id=&quot;name&quot;&gt;&#123;&#123;name&#125;&#125;&lt;/h1&gt;  //这个&#123;&#123;name&#125;&#125;暂时没用</span><br><span class="line"></span><br><span class="line">// js</span><br><span class="line">var el = document.querySelector(&apos;#name&apos;)</span><br><span class="line">var selfVue = new SimpleVue(&#123; name: &apos;hello&apos;&#125;, el, &apos;name&apos;)</span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">  selfVue.name = &apos;123&apos;</span><br><span class="line">&#125;, 2000)</span><br></pre></td></tr></table></figure>

<p>需要注意的是SimpleVue原型的proxyKeys是为了将selfVue.data.name这种操作代理为selfVue.name。这下我们就可以直接通过selfVue.name = “XXX”来改变数据了，并且视图也会相应变化。</p>
<h3 id="Compile"><a href="#Compile" class="headerlink" title="Compile"></a>Compile</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nodeToFragement: function(el) &#123;</span><br><span class="line">    var fragment = document.createDocumentFragment()</span><br><span class="line">    var child = el.firstChild</span><br><span class="line">    // 将dom节点移到fragment</span><br><span class="line">    while(child) &#123;</span><br><span class="line">      fragment.appendChild(child)</span><br><span class="line">      child = el.firstChild</span><br><span class="line">    &#125;</span><br><span class="line">    return fragment</span><br><span class="line">  &#125;,</span><br><span class="line">  compileElement: function(el) &#123;</span><br><span class="line">    var childNodes = el.childNodes</span><br><span class="line">    var self = this;</span><br><span class="line">    [].slice.call(childNodes).forEach(function(node) &#123;</span><br><span class="line">      var reg = /\&#123;\&#123;(.*)\&#125;\&#125;/</span><br><span class="line">      var text = node.textContent</span><br><span class="line">      if (self.isTextNode(node) &amp;&amp; reg.test(text)) &#123;</span><br><span class="line">        self.compileText(node, reg.exec(text)[1])</span><br><span class="line">      &#125;</span><br><span class="line">      if (node.childNodes &amp;&amp; node.childNodes.length) &#123;</span><br><span class="line">        self.compileElement(node)  // 递归遍历子节点</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">  compileText: function(node, exp) &#123;</span><br><span class="line">    var self = this</span><br><span class="line">    var initText = this.vm[exp]</span><br><span class="line">    this.updateText(node, initText)</span><br><span class="line">    new Watcher(this.vm, exp, function(value) &#123;</span><br><span class="line">      self.updateText(node, value)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>

<p>compile将dom节点移入DocumentFragment中去，并递归调用compileElement函数来遍历所有子节点，compileText函数创建新的watcher。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function SimpleVue (options) &#123;</span><br><span class="line">  var self = this</span><br><span class="line">  this.vm = this</span><br><span class="line">  this.data = options.data</span><br><span class="line">  Object.keys(this.data).forEach(function(key) &#123;</span><br><span class="line">    self.proxyKeys(key)</span><br><span class="line">  &#125;)</span><br><span class="line">  observe(this.data)</span><br><span class="line">  new Compile(options.el, this.vm)</span><br><span class="line">  return this</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&nbsp;</p>
<hr>
<h2 id="好了！以上就是全部内容啦-希望可以帮到你！！！"><a href="#好了！以上就是全部内容啦-希望可以帮到你！！！" class="headerlink" title="好了！以上就是全部内容啦~~希望可以帮到你！！！"></a>好了！以上就是全部内容啦~~希望可以帮到你！！！</h2>]]></content>
      <tags>
        <tag>Vue</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>小程序开发和Vue组件化开发的使用区别</title>
    <url>/2020/09/21/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%8EVue%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h1 id="总结一下二者的共同点和区别"><a href="#总结一下二者的共同点和区别" class="headerlink" title="总结一下二者的共同点和区别"></a>总结一下二者的共同点和区别</h1><h2 id="前端知识"><a href="#前端知识" class="headerlink" title="前端知识"></a>前端知识</h2><a id="more"></a>
<p>写了vue项目和小程序，发现二者有许多相同之处，在此想总结一下二者的共同点和区别。</p>
<h3 id="1-生命周期"><a href="#1-生命周期" class="headerlink" title="1.生命周期"></a>1.生命周期</h3><blockquote>
<p>vue生命周期：</p>
</blockquote>
<p><img src="https://segmentfault.com/img/bVVORa?w=1200&h=3039/view" alt></p>
<blockquote>
<p>小程序生命周期:</p>
</blockquote>
<p><img src="https://segmentfault.com/img/bVbcfCK?w=662&h=1014" alt><br>相比之下，小程序的钩子函数要简单得多。<br>vue的钩子函数在跳转新页面时，钩子函数都会触发，但是小程序的钩子函数，页面不同的跳转方式，触发的钩子并不一样。</p>
<p>onLoad: 页面加载<br>一个页面只会调用一次，可以在 onLoad 中获取打开当前页面所调用的 query 参数。</p>
<p>onShow: 页面显示<br>每次打开页面都会调用一次。</p>
<p>onReady: 页面初次渲染完成<br>一个页面只会调用一次，代表页面已经准备妥当，可以和视图层进行交互。</p>
<p>对界面的设置如wx.setNavigationBarTitle请在onReady之后设置。详见生命周期</p>
<p>onHide: 页面隐藏<br>当navigateTo或底部tab切换时调用。</p>
<p>onUnload: 页面卸载<br>当redirectTo或navigateBack的时候调用。</p>
<p>数据请求:</p>
<p>在页面加载请求数据时，两者钩子的使用有些类似，vue一般会在created或者mounted中请求数据，而在小程序，会在onLoad或者onShow中请求数据。</p>
<h3 id="2-数据绑定"><a href="#2-数据绑定" class="headerlink" title="2.数据绑定"></a>2.数据绑定</h3><p>VUE:vue动态绑定一个变量的值为元素的某个属性的时候，会在变量前面加上冒号：，例：<br><code>1.  &lt;img :src=&quot;imgSrc&quot;/&gt;</code><br>小程序：绑定某个变量的值为元素属性时，会用两个大括号括起来，如果不加括号，为被认为是字符串。例：<br><code>1.  &lt;image src=&quot;&quot;&gt;&lt;/image&gt;</code></p>
<h3 id="3-列表渲染"><a href="#3-列表渲染" class="headerlink" title="3.列表渲染"></a>3.列表渲染</h3><p>两者还是有些相似</p>
<blockquote>
<p>vue：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">1.  &lt;ul id=&quot;example-1&quot;&gt;  </span><br><span class="line">2.  &lt;li v-for=&quot;item in items&quot;&gt;  </span><br><span class="line">3.  &#123;&#123; item.message &#125;&#125;  </span><br><span class="line">4.  &lt;/li&gt;  </span><br><span class="line">5\.  &lt;/ul&gt;  </span><br><span class="line"></span><br><span class="line">7.  var example1 = new Vue(&#123;  </span><br><span class="line">8.  el: &apos;#example-1&apos;,  </span><br><span class="line">9.  data: &#123;  </span><br><span class="line">10.  items: [  </span><br><span class="line">11.  &#123; message: &apos;苹果&apos; &#125;,  </span><br><span class="line">12.  &#123; message: &apos;橘子&apos; &#125;  </span><br><span class="line">13.  ] </span><br><span class="line">14.  &#125;  </span><br><span class="line">15.  &#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>小程序:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.  Page(&#123;  </span><br><span class="line">2.  data: &#123;  </span><br><span class="line">3.  items: [  </span><br><span class="line">4.  &#123; message: &apos;苹果&apos; &#125;,  </span><br><span class="line">5.  &#123; message: &apos;橘子&apos; &#125;  </span><br><span class="line">6.  ]  </span><br><span class="line">7.  &#125;  </span><br><span class="line">8.  &#125;)  </span><br><span class="line"></span><br><span class="line">10.  &lt;text wx:for=&quot;&#123;&#123;items&#125;&#125;&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/text&gt;</span><br></pre></td></tr></table></figure>

<h3 id="4-显示与隐藏元素"><a href="#4-显示与隐藏元素" class="headerlink" title="4.显示与隐藏元素"></a>4.显示与隐藏元素</h3><p>vue中，使用v-if 和v-show控制元素的显示和隐藏</p>
<p>小程序中，使用wx-if和hidden控制元素的显示和隐藏</p>
<h3 id="5-事件处理"><a href="#5-事件处理" class="headerlink" title="5.事件处理"></a>5.事件处理</h3><p>vue：使用v-on:event绑定事件，或者使用@event绑定事件,例如:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.  &lt;button v-on:click=&quot;counter += 1&quot;&gt;Add 1&lt;/button&gt;  </span><br><span class="line">2\.  &lt;button v-on:click.stop=&quot;counter+=1&quot;&gt;Add1&lt;/button&gt;  //阻止事件冒泡</span><br></pre></td></tr></table></figure>

<p>小程序中，全用bindtap(bind+event)，或者catchtap(catch+event)绑定事件,例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.  &lt;button bindtap=&quot;noWork&quot;&gt;明天不上班&lt;/button&gt;  </span><br><span class="line">2.  &lt;button catchtap=&quot;noWork&quot;&gt;明天不上班&lt;/button&gt;  //阻止事件冒泡</span><br></pre></td></tr></table></figure>

<h3 id="6-数据双向绑定"><a href="#6-数据双向绑定" class="headerlink" title="6.数据双向绑定"></a>6.数据双向绑定</h3><p><strong>1.设置值</strong></p>
<p>在vue中,只需要再表单元素上加上v-model,然后再绑定data中对应的一个值，当表单元素内容发生变化时，data中对应的值也会相应改变，这是vue非常nice的一点。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">1.  &lt;div id=&quot;app&quot;&gt;  </span><br><span class="line">2.  &lt;input v-model=&quot;reason&quot; placeholder=&quot;填写理由&quot; class=&apos;reason&apos;/&gt;  </span><br><span class="line">3.  &lt;/div&gt;  </span><br><span class="line"></span><br><span class="line">5.  new Vue(&#123;  </span><br><span class="line">6.  el: &apos;#app&apos;,  </span><br><span class="line">7.  data: &#123;  </span><br><span class="line">8.  reason:&apos;&apos;  </span><br><span class="line">9.  &#125;  </span><br><span class="line">10.  &#125;)</span><br></pre></td></tr></table></figure>

<p>但是在小程序中，却没有这个功能。那怎么办呢？</p>
<p>当表单内容发生变化时，会触发表单元素上绑定的方法，然后在该方法中，通过this.setData({key:value})来将表单上的值赋值给data中的对应值。</p>
<p>下面是代码，可以感受一下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.  &lt;input bindinput=&quot;bindReason&quot; placeholder=&quot;填写理由&quot; class=&apos;reason&apos; value=&apos;&#123;&#123;reason&#125;&#125;&apos; name=&quot;reason&quot; /&gt;  </span><br><span class="line">2.  Page(&#123;  </span><br><span class="line">3.  data:&#123;  </span><br><span class="line">4.  reason:&apos;&apos;  </span><br><span class="line">5.  &#125;,  </span><br><span class="line">6.  bindReason(e) &#123;  </span><br><span class="line">7.  this.setData(&#123;  </span><br><span class="line">8.  reason: e.detail.value  </span><br><span class="line">9.  &#125;)  </span><br><span class="line">10.  &#125;  </span><br><span class="line">11.  &#125;)</span><br></pre></td></tr></table></figure>

<p>当页面表单元素很多的时候，更改值就是一件体力活了。和小程序一比较，vue的v-model简直爽的不要不要的。<br><strong>2.取值</strong></p>
<p>vue中，通过this.reason取值</p>
<p>小程序中，通过this.data.reason取值</p>
<h3 id="7-绑定事件传参"><a href="#7-绑定事件传参" class="headerlink" title="7.绑定事件传参"></a>7.绑定事件传参</h3><p>在vue中，绑定事件传参挺简单，只需要在触发事件的方法中，把需要传递的数据作为形参传入就可以了，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.  &lt;button @click=&quot;say(&apos;明天不上班&apos;)&quot;&gt;&lt;/button&gt;  </span><br><span class="line">2.  new Vue(&#123;  </span><br><span class="line">3.  el: &apos;#app&apos;,  </span><br><span class="line">4.  methods:&#123;  </span><br><span class="line">5.  say(arg)&#123;  </span><br><span class="line">6.  consloe.log(arg)  </span><br><span class="line">7.  &#125;  </span><br><span class="line">8.  &#125;  </span><br><span class="line">9.  &#125;)</span><br></pre></td></tr></table></figure>

<p>在小程序中，不能直接在绑定事件的方法中传入参数，需要将参数作为属性值，绑定到元素上的data-属性上，然后在方法中，通过e.currentTarget.dataset.*的方式获取，从而完成参数的传递，很麻烦有没有…</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.  &lt;view class=&apos;tr&apos; bindtap=&apos;toApprove&apos; data-id=&quot;&#123;&#123;item.id&#125;&#125;&quot;&gt;&lt;/view&gt;  </span><br><span class="line">2.  Page(&#123;  </span><br><span class="line">3.  data:&#123;  </span><br><span class="line">4.  reason:&apos;&apos;  </span><br><span class="line">5.  &#125;,  </span><br><span class="line">6.  toApprove(e) &#123;  </span><br><span class="line">7.  let id = e.currentTarget.dataset.id;  </span><br><span class="line">8.  &#125;  </span><br><span class="line">9.  &#125;)</span><br></pre></td></tr></table></figure>

<h3 id="8-父子组件通信"><a href="#8-父子组件通信" class="headerlink" title="8.父子组件通信"></a>8.父子组件通信</h3><p><strong>1.子组件的使用</strong></p>
<p>在vue中，需要：</p>
<p>编写子组件<br>在需要使用的父组件中通过import引入<br>在vue的components中注册<br>在模板中使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">1.  //子组件 bar.vue  </span><br><span class="line">2.  &lt;template&gt;  </span><br><span class="line">3.  &lt;div class=&quot;search-box&quot;&gt;  </span><br><span class="line">4.  &lt;div @click=&quot;say&quot; :title=&quot;title&quot; class=&quot;icon-dismiss&quot;&gt;&lt;/div&gt;  </span><br><span class="line">5.  &lt;/div&gt;  </span><br><span class="line">6\.  &lt;/template&gt;  </span><br><span class="line">7.  &lt;script&gt;  </span><br><span class="line">8.  export default&#123;  </span><br><span class="line">9.  props:&#123;  </span><br><span class="line">10.  title:&#123;  </span><br><span class="line">11.  type:String,  </span><br><span class="line">12.  default:&apos;&apos;  </span><br><span class="line">13.  &#125;  </span><br><span class="line">14.  &#125;  </span><br><span class="line">15.  &#125;, </span><br><span class="line"></span><br><span class="line">17.  methods:&#123;  </span><br><span class="line">18.  say()&#123; </span><br><span class="line">19.  console.log(&apos;明天不上班&apos;);  </span><br><span class="line">20.  this.$emit(&apos;helloWorld&apos;)  </span><br><span class="line">21.  &#125;  </span><br><span class="line">22.  &#125; </span><br><span class="line">23.  &lt;/script&gt;  </span><br><span class="line"></span><br><span class="line">25\.  // 父组件 foo.vue  </span><br><span class="line">26.  &lt;template&gt;  </span><br><span class="line">27.  &lt;div class=&quot;container&quot;&gt;  </span><br><span class="line">28.  &lt;bar :title=&quot;title&quot; @helloWorld=&quot;helloWorld&quot;&gt;&lt;/bar&gt;  </span><br><span class="line">29.  &lt;/div&gt;  </span><br><span class="line">30\.  &lt;/template&gt;  </span><br><span class="line"></span><br><span class="line">32.  &lt;script&gt;  </span><br><span class="line">33.  import Bar from &apos;./bar.vue&apos;  </span><br><span class="line">34.  export default&#123;  </span><br><span class="line">35.  data:&#123;  </span><br><span class="line">36.  title:&quot;我是标题&quot;  </span><br><span class="line">37.  &#125;,  </span><br><span class="line">38.  methods:&#123;  </span><br><span class="line">39.  helloWorld()&#123;  </span><br><span class="line">40.  console.log(&apos;我接收到子组件传递的事件了&apos;)  </span><br><span class="line">41.  &#125;  </span><br><span class="line">42.  &#125;,  </span><br><span class="line">43.  components:&#123; </span><br><span class="line">44.  Bar  </span><br><span class="line">45.  &#125;  </span><br><span class="line">46.  &lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>在小程序中，需要：<br>1.编写子组件<br>2.在子组件的json文件中，将该文件声明为组件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.  &#123;  </span><br><span class="line">2.  &quot;component&quot;: true  </span><br><span class="line">3.  &#125;</span><br></pre></td></tr></table></figure>

<p>3.在需要引入的父组件的json文件中，在usingComponents填写引入组件的组件名以及路径</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">1.  &quot;usingComponents&quot;: &#123;  </span><br><span class="line">2.  &quot;tab-bar&quot;: &quot;../../components/tabBar/tabBar&quot;  </span><br><span class="line">3.  &#125;</span><br></pre></td></tr></table></figure>

<p>4.在父组件中，直接引入即可<br><code>1.  &lt;tab-bar currentpage=&quot;index&quot;&gt;&lt;/tab-bar&gt;</code><br><strong>2.父子组件间通信</strong></p>
<p>在vue中</p>
<p>父组件向子组件传递数据，只需要在子组件通过v-bind传入一个值，在子组件中，通过props接收，即可完成数据的传递，示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">1.  // 父组件 foo.vue  </span><br><span class="line">2.  &lt;template&gt;  </span><br><span class="line">3.  &lt;div class=&quot;container&quot;&gt;  </span><br><span class="line">4.  &lt;bar :title=&quot;title&quot;&gt;&lt;/bar&gt;  </span><br><span class="line">5.  &lt;/div&gt;  </span><br><span class="line">6\.  &lt;/template&gt;  </span><br><span class="line">7.  &lt;script&gt;  </span><br><span class="line">8.  import Bar from &apos;./bar.vue&apos;  </span><br><span class="line">9.  export default&#123;  </span><br><span class="line">10.  data:&#123;  </span><br><span class="line">11.  title:&quot;我是标题&quot;  </span><br><span class="line">12.  &#125;,  </span><br><span class="line">13.  components:&#123;  </span><br><span class="line">14.  Bar  </span><br><span class="line">15.  &#125;  </span><br><span class="line">16.  &lt;/script&gt;  </span><br><span class="line"></span><br><span class="line">18\.  // 子组件bar.vue  </span><br><span class="line">19.  &lt;template&gt;  </span><br><span class="line">20.  &lt;div class=&quot;search-box&quot;&gt;  </span><br><span class="line">21.  &lt;div :title=&quot;title&quot; &gt;&lt;/div&gt;  </span><br><span class="line">22.  &lt;/div&gt;  </span><br><span class="line">23\.  &lt;/template&gt;  </span><br><span class="line">24.  &lt;script&gt;  </span><br><span class="line">25.  export default&#123;  </span><br><span class="line">26.  props:&#123;  </span><br><span class="line">27.  title:&#123;  </span><br><span class="line">28.  type:String,  </span><br><span class="line">29.  default:&apos;&apos;  </span><br><span class="line">30.  &#125;  </span><br><span class="line">31.  &#125;  </span><br><span class="line">32.  &#125;  </span><br><span class="line">33.  &lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>子组件和父组件通信可以通过this.$emit将方法和数据传递给父组件。<br>在小程序中</p>
<p>父组件向子组件通信和vue类似，但是小程序没有通过v-bind，而是直接将值赋值给一个变量，如下：<br><code>1.  &lt;tab-bar currentpage=&quot;index&quot;&gt;&lt;/tab-bar&gt;</code><br>此处， “index”就是要向子组件传递的值<br>在子组件properties中，接收传递的值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">1.  properties: &#123;  </span><br><span class="line">2.  // 弹窗标题  </span><br><span class="line">3.  currentpage: &#123;            // 属性名  </span><br><span class="line">4.  type: String,     // 类型（必填），目前接受的类型包括：String, Number, Boolean, Object, Array, null（表示任意类型）  </span><br><span class="line">5.  value: &apos;index&apos;     // 属性初始值（可选），如果未指定则会根据类型选择一个 </span><br><span class="line">6.  &#125; </span><br><span class="line">7.  &#125;</span><br></pre></td></tr></table></figure>

<p>子组件向父组件通信和vue也很类似，代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">1.  //子组件中  </span><br><span class="line">2.  methods: &#123;     </span><br><span class="line">3.  // 传递给父组件  </span><br><span class="line">4.  cancelBut: function (e) &#123;  </span><br><span class="line">5.  var that = this;  </span><br><span class="line">6.  var myEventDetail = &#123; pickerShow: false, type: &apos;cancel&apos; &#125; // detail对象，提供给事件监听函数  </span><br><span class="line">7.  this.triggerEvent(&apos;myevent&apos;, myEventDetail) //myevent自定义名称事件，父组件中使用  </span><br><span class="line">8.  &#125;, </span><br><span class="line">9.  &#125;  </span><br><span class="line">10.  //父组件中  </span><br><span class="line">11.  &lt;bar bind:myevent=&quot;toggleToast&quot;&gt;&lt;/bar&gt;   </span><br><span class="line">12.  // 获取子组件信息  </span><br><span class="line">13.  toggleToast(e)&#123;  </span><br><span class="line">14.  console.log(e.detail)  </span><br><span class="line">15.  &#125;</span><br></pre></td></tr></table></figure>

<p>如果父组件想要调用子组件的方法</p>
<p>vue会给子组件添加一个ref属性，通过this.$refs.ref的值便可以获取到该子组件，然后便可以调用子组件中的任意方法，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">1.  //子组件  </span><br><span class="line">2.  &lt;bar ref=&quot;bar&quot;&gt;&lt;/bar&gt;  </span><br><span class="line">3.  //父组件  </span><br><span class="line">4.  this.$ref.bar.子组件的方法</span><br></pre></td></tr></table></figure>

<p>小程序是给子组件添加id或者class，然后通过this.selectComponent找到子组件，然后再调用子组件的方法,示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">1.  //子组件  </span><br><span class="line">2.  &lt;bar id=&quot;bar&quot;&gt;&lt;/bar&gt;  </span><br><span class="line">3.  // 父组件  </span><br><span class="line">4.  this.selectComponent(&apos;#id&apos;).syaHello()</span><br></pre></td></tr></table></figure>

<p>小程序和vue在这点上太相似了…</p>
<hr>
<p>这些都是我们常用到的知识点，还有不足，以后慢慢改善~~！</p>
<p><a href="https://segmentfault.com/a/1190000015684864" target="_blank" rel="noopener">原文地址</a></p>
]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>小程序</tag>
      </tags>
  </entry>
</search>
