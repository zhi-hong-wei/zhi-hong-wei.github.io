<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>markdown语法</title>
    <url>/2020/11/12/markdown%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h1 id="Markdown语法总结"><a href="#Markdown语法总结" class="headerlink" title="Markdown语法总结"></a>Markdown语法总结</h1><h2 id="笔记神器"><a href="#笔记神器" class="headerlink" title="笔记神器"></a>笔记神器</h2><a id="more"></a>

<h2 id="1、标题"><a href="#1、标题" class="headerlink" title="1、标题"></a>1、标题</h2><p>一个#是一级标题，二个#是二级标题，以此类推。支持六级标题。</p>
<p>注：标准语法一般在#后跟个空格再写文字，貌似简书不加空格也行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 这是一级标题</span><br><span class="line">## 这是二级标题</span><br><span class="line">### 这是三级标题</span><br><span class="line">#### 这是四级标题</span><br><span class="line">##### 这是五级标题</span><br><span class="line">###### 这是六级标题</span><br></pre></td></tr></table></figure>

<h2 id="2、字体"><a href="#2、字体" class="headerlink" title="2、字体"></a>2、字体</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">**这是加粗的文字**</span><br><span class="line">*这是倾斜的文字*`</span><br><span class="line">***这是斜体加粗的文字***</span><br><span class="line">~~这是加删除线的文字~~</span><br></pre></td></tr></table></figure>

<h2 id="3、引用"><a href="#3、引用" class="headerlink" title="3、引用"></a>3、引用</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;这是引用的内容</span><br><span class="line">&gt;&gt;这是引用的内容</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容</span><br></pre></td></tr></table></figure>

<p>效果图：</p>
<blockquote>
<p>这是引用的内容</p>
<blockquote>
<p>这是引用的内容</p>
</blockquote>
</blockquote>
<h2 id="4、分割线"><a href="#4、分割线" class="headerlink" title="4、分割线"></a>4、分割线</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">----</span><br><span class="line">***</span><br><span class="line">*****</span><br></pre></td></tr></table></figure>

<h2 id="5、图片"><a href="#5、图片" class="headerlink" title="5、图片"></a>5、图片</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![图片alt](图片地址 &apos;&apos;图片title&apos;&apos;)</span><br><span class="line"></span><br><span class="line">图片alt就是显示在图片下面的文字，相当于对图片内容的解释。</span><br><span class="line">图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加</span><br></pre></td></tr></table></figure>

<h2 id="6、超链接"><a href="#6、超链接" class="headerlink" title="6、超链接"></a>6、超链接</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[超链接名](超链接地址 &quot;超链接title&quot;)</span><br><span class="line">title可加可不加</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[简书](http://jianshu.com)</span><br><span class="line">[百度](http://baidu.com)</span><br></pre></td></tr></table></figure>

<p>如果想在新页面打开：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;a href=&quot;超链接地址&quot; target=&quot;_blank&quot;&gt;超链接名&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">示例</span><br><span class="line">&lt;a href=&quot;https://www.jianshu.com/u/1f5ac0cf6a8b&quot; target=&quot;_blank&quot;&gt;简书&lt;/a&gt;</span><br></pre></td></tr></table></figure>

<h2 id="7、列表"><a href="#7、列表" class="headerlink" title="7、列表"></a>7、列表</h2><h3 id="7-1、有序列表"><a href="#7-1、有序列表" class="headerlink" title="7.1、有序列表"></a>7.1、有序列表</h3><p>数字加点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 列表内容</span><br><span class="line">2. 列表内容</span><br><span class="line">3. 列表内容</span><br><span class="line"></span><br><span class="line">注意：序号跟内容之间要有空格</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<ol>
<li>列表内容</li>
<li>列表内容</li>
<li>列表内容</li>
</ol>
<h3 id="7-2、无序列表"><a href="#7-2、无序列表" class="headerlink" title="7.2、无序列表"></a>7.2、无序列表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- 列表内容</span><br><span class="line">+ 列表内容</span><br><span class="line">* 列表内容</span><br><span class="line"></span><br><span class="line">注意：- + * 跟内容之间都要有一个空格</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<ul>
<li>列表内容</li>
<li>列表内容</li>
<li>列表内容</li>
</ul>
<h2 id="8、表格"><a href="#8、表格" class="headerlink" title="8、表格"></a>8、表格</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">表头|表头|表头</span><br><span class="line">---|:--:|---:</span><br><span class="line">内容|内容|内容</span><br><span class="line">内容|内容|内容</span><br><span class="line"></span><br><span class="line">第二行分割表头和内容。</span><br><span class="line">- 有一个就行，为了对齐，多加了几个</span><br><span class="line">文字默认居左</span><br><span class="line">-两边加：表示文字居中</span><br><span class="line">-右边加：表示文字居右</span><br><span class="line">注：原生的语法两边都要用 | 包起来。此处省略</span><br></pre></td></tr></table></figure>

<h2 id="9、代码"><a href="#9、代码" class="headerlink" title="9、代码"></a>9、代码</h2><p>单行代码：代码之间分别用一个反引号包起来</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">`代码内容`</span><br></pre></td></tr></table></figure>

<p>代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">​</span><br></pre></td></tr></table></figure>

<p>  代码…<br>  代码…<br>  代码…<br>​<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">## 10、一些特殊语法</span><br><span class="line"></span><br><span class="line">空格符：</span><br></pre></td></tr></table></figure></p>
<p>从小到大：<br>小：&amp;nbsp  中：ensp  大：emsp</p>
<center>居中的内容</center>

<p>就像使用html一样，使用<br>标签或者在末尾敲击两个空格，然后回车</p>
<p><font face="黑体">我是黑体字</font><br><font color="red">我是红色</font><br><font size="5">我是5号大小</font><br><font face="黑体" color="green" size="5">我是黑体，绿色，尺寸为5</font></p>
<pre><code>
---

### 以上就是比较常用的Markdown语法，日常生活一定够用了，特殊情况请找无所不知的百度大明白！
</code></pre>]]></content>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>Canvas绘图及描框</title>
    <url>/2020/07/22/Canvas%E7%BB%98%E5%9B%BE%E5%8F%8A%E6%8F%8F%E6%A1%86/</url>
    <content><![CDATA[<h1 id="canvas绘制图片和画识别框问题"><a href="#canvas绘制图片和画识别框问题" class="headerlink" title="canvas绘制图片和画识别框问题"></a>canvas绘制图片和画识别框问题</h1><h2 id="canvas知识"><a href="#canvas知识" class="headerlink" title="canvas知识"></a>canvas知识</h2><a id="more"></a>

<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>先说一下业务需求，此处的功能是用于微信OCR文字识别的PC端和小程序端应用。要求上传本地图片后，图片以及识别结果能够展示，为便于测试要求在识别图片上对识别的文字用矩形框及序号框出，与结果一一对应。</p>
<p><font color="orange">记录下此处的实现方法及难点：</font></p>
<p>1、首先图片显示不要使用img标签，使用canvas来描绘，我们需要得到的是img的宽高属性。小程序使用：wx.getImageInfo，vue中直接new Image()</p>
<p>2、我们要知道两个比例：（1）图片与画布的比例，用于图片自适应画布大小。（2）图片自身缩放比例，<br>用于识别框同比例缩放。</p>
<p>3、计算居中显示的偏移量：（画布-图片）/2；调用canvas的api接口绘图ctx.drawImage</p>
<p>4、根据后台返回的坐标点（原图）进行描框和缩放ctx.strokeRect，对序号框字体进行优化，自适应框的大小，此处小程序和pc不同。</p>
<h3 id="分别附带小程序及vue的完整代码"><a href="#分别附带小程序及vue的完整代码" class="headerlink" title="分别附带小程序及vue的完整代码"></a>分别附带小程序及vue的完整代码</h3><h4 id="小程序："><a href="#小程序：" class="headerlink" title="小程序："></a>小程序：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">canvasToFile(ctx) &#123;</span><br><span class="line">    const cWidth = 640,</span><br><span class="line">      cHeight = 480;</span><br><span class="line">    console.log(&apos;画布宽：&apos; + cWidth)</span><br><span class="line">    console.log(&apos;画布高：&apos; + cHeight)</span><br><span class="line"></span><br><span class="line">    wx.getImageInfo(&#123;</span><br><span class="line">      src: SRC,</span><br><span class="line">      success: res =&gt; &#123;</span><br><span class="line">        console.log(res)</span><br><span class="line">        // 原始图大小</span><br><span class="line">        let imgWidth = res.width,</span><br><span class="line">          imgHeight = res.height;</span><br><span class="line">        // 相对画布等比例缩放</span><br><span class="line">        let n = 1;</span><br><span class="line">        if (imgWidth &gt; imgHeight) &#123;</span><br><span class="line">          n = imgWidth / cWidth;</span><br><span class="line">          imgWidth = cWidth;</span><br><span class="line">          imgHeight = imgHeight / n;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          n = imgHeight / cHeight;</span><br><span class="line">          imgHeight = cHeight;</span><br><span class="line">          imgWidth = imgWidth / n;</span><br><span class="line">        &#125;</span><br><span class="line">        // 图片自身缩放比例</span><br><span class="line">        let widthScal = imgWidth / res.width</span><br><span class="line">        console.log(widthScal)</span><br><span class="line">        console.log(&apos;imgWidth:&apos; + imgWidth)</span><br><span class="line">        console.log(&apos;imgHeight:&apos; + imgHeight)</span><br><span class="line">        console.log(cWidth)</span><br><span class="line">        console.log(cHeight)</span><br><span class="line">        let zoom = &#123;</span><br><span class="line">          width: widthScal,</span><br><span class="line">          height: widthScal</span><br><span class="line">        &#125;</span><br><span class="line">        // 偏移x,y位移量</span><br><span class="line">        let right_move = (cWidth - imgWidth) / 2;</span><br><span class="line">        let bottom_move = (cHeight - imgHeight) / 2;</span><br><span class="line">        console.log(&apos;right_move:&apos; + right_move)</span><br><span class="line">        console.log(&apos;bottom_move:&apos; + bottom_move)</span><br><span class="line">        // 获取预览画布上下文</span><br><span class="line">        const c_t_x = wx.createCanvasContext(&apos;canvas_pre&apos;)</span><br><span class="line">        // 缩放展示画布图片</span><br><span class="line">        ctx.scale(0.5, 0.5)</span><br><span class="line">        ctx.drawImage(SRC, right_move, bottom_move, imgWidth, imgHeight)</span><br><span class="line">        c_t_x.drawImage(SRC, right_move, bottom_move, imgWidth, imgHeight)</span><br><span class="line">        ctx.draw()</span><br><span class="line">        c_t_x.draw()</span><br><span class="line">        // 画矩形识别框</span><br><span class="line">        setTimeout(function() &#123;</span><br><span class="line">          let value = wx.getStorageSync(&apos;ocr&apos;)</span><br><span class="line">          if (value.hasOwnProperty(&apos;items&apos;)) &#123;</span><br><span class="line">            console.log(value)</span><br><span class="line">            let length = value.items.length</span><br><span class="line">            let item = value.items</span><br><span class="line">            for (let i = 0; i &lt; length; i++) &#123;</span><br><span class="line">              let show = item[i]</span><br><span class="line">              // 原图坐标</span><br><span class="line">              let X1 = show.pos.left_top.x</span><br><span class="line">              let Y1 = show.pos.left_top.y</span><br><span class="line">              let X2 = show.pos.right_bottom.x</span><br><span class="line">              let Y2 = show.pos.right_bottom.y</span><br><span class="line">              let startPoint = [X1, Y1],</span><br><span class="line">                endPoint = [X2, Y2];</span><br><span class="line">              // console.log(startPoint)</span><br><span class="line">              // console.log(endPoint)</span><br><span class="line">              // 等比例缩放坐标</span><br><span class="line">              let Num_x = startPoint[0] * zoom.width + right_move</span><br><span class="line">              let Num_y = startPoint[1] * zoom.height + bottom_move</span><br><span class="line">              let Num_width = (endPoint[0] - startPoint[0]) * zoom.width</span><br><span class="line">              let Num_height = (endPoint[1] - startPoint[1]) * zoom.height</span><br><span class="line">              ctx.setStrokeStyle(&apos;blue&apos;)</span><br><span class="line">              c_t_x.setStrokeStyle(&apos;blue&apos;)</span><br><span class="line">              // 分别画两个画布的矩形框</span><br><span class="line">              c_t_x.strokeRect(Num_x, Num_y, Num_width, Num_height)</span><br><span class="line">              ctx.strokeRect(Num_x, Num_y, Num_width, Num_height);</span><br><span class="line">              // 区分文字横向，竖向展示时，数字框位置</span><br><span class="line">              if (Num_width &lt; Num_height) &#123;</span><br><span class="line">                let top_x = Num_x</span><br><span class="line">                let top_y = (startPoint[1] - (endPoint[0] - startPoint[0])) * zoom.height + bottom_move</span><br><span class="line">                let w_h = Num_width</span><br><span class="line">                ctx.setFontSize(w_h)</span><br><span class="line">                c_t_x.setFontSize(w_h)</span><br><span class="line">                ctx.setStrokeStyle(&apos;#006bff&apos;)</span><br><span class="line">                c_t_x.setStrokeStyle(&apos;#006bff&apos;)</span><br><span class="line">                ctx.setFillStyle(&apos;#006bff&apos;)</span><br><span class="line">                c_t_x.setFillStyle(&apos;#006bff&apos;)</span><br><span class="line">                ctx.fillText(i + 1, Num_x + (w_h / 2), Num_y, w_h)</span><br><span class="line">                c_t_x.fillText(i + 1, Num_x + (w_h / 2), Num_y, w_h)</span><br><span class="line">                ctx.strokeRect(top_x, top_y, w_h, w_h)</span><br><span class="line">                c_t_x.strokeRect(top_x, top_y, w_h, w_h)</span><br><span class="line">                ctx.setTextAlign(&apos;center&apos;)</span><br><span class="line">                c_t_x.setTextAlign(&apos;center&apos;)</span><br><span class="line">              &#125; else &#123;</span><br><span class="line">                let left_X = (startPoint[0] - (endPoint[1] - startPoint[1])) * zoom.width + right_move</span><br><span class="line">                let left_Y = Num_y</span><br><span class="line">                let W_H = Num_height</span><br><span class="line">                ctx.setFontSize(W_H)</span><br><span class="line">                ctx.setStrokeStyle(&apos;#006bff&apos;)</span><br><span class="line">                ctx.setFillStyle(&apos;#006bff&apos;)</span><br><span class="line">                ctx.fillText(i + 1, left_X + W_H / 2, left_Y + W_H, W_H)</span><br><span class="line">                ctx.strokeRect(left_X, left_Y, W_H, W_H)</span><br><span class="line">                ctx.setTextAlign(&apos;center&apos;)</span><br><span class="line">                c_t_x.setFontSize(W_H)</span><br><span class="line">                c_t_x.setStrokeStyle(&apos;#006bff&apos;)</span><br><span class="line">                c_t_x.setFillStyle(&apos;#006bff&apos;)</span><br><span class="line">                c_t_x.fillText(i + 1, left_X + W_H / 2, left_Y + W_H, W_H)</span><br><span class="line">                c_t_x.strokeRect(left_X, left_Y, W_H, W_H)</span><br><span class="line">                c_t_x.setTextAlign(&apos;center&apos;)</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ctx.draw(true)</span><br><span class="line">            // 导出图片到url数组中，注意像素值</span><br><span class="line">            c_t_x.draw(true, setTimeout(function() &#123;</span><br><span class="line">              let dpr = wx.getSystemInfoSync().pixelRatio</span><br><span class="line">              console.log(dpr)</span><br><span class="line">              wx.canvasToTempFilePath(&#123;</span><br><span class="line">                x: right_move,</span><br><span class="line">                y: bottom_move,</span><br><span class="line">                width: imgWidth,</span><br><span class="line">                height: imgHeight,</span><br><span class="line">                destWidth: imgWidth * dpr,</span><br><span class="line">                destHeight: imgHeight * dpr,</span><br><span class="line">                canvasId: &apos;canvas_pre&apos;,</span><br><span class="line">                success(res) &#123;</span><br><span class="line">                  console.log(res)</span><br><span class="line">                  url.push(res.tempFilePath)</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;)</span><br><span class="line">            &#125;, 100));</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, 1200)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>

<p>这里有两个canvas，是因为公司新加的一个需求：点击图片放大预览，同时识别框也要放大。但是在同一画布内使用wx.canvasToTempFilePath导成图片后，预览的图片很模糊，网上也有些方法，但并不起作用。所以我使用两个画布，一个画布展示图片和识别框，另一个定位在屏幕外用于预览图片，预览画布宽高是展示画布的2倍。即可解决模糊问题。</p>
<p>在onload调用该方法并初始化：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const ctx = wx.createCanvasContext(&apos;canvas&apos;)</span><br><span class="line">ctx.clearRect(0, 0, 320, 240)</span><br><span class="line">ctx.draw()</span><br><span class="line">this.canvasToFile(ctx)</span><br></pre></td></tr></table></figure>

<h3 id="vue中实现："><a href="#vue中实现：" class="headerlink" title="vue中实现："></a>vue中实现：</h3><p>调canvas组件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;Canvas @upload=&quot;upload&quot; :result_show=&quot;result_title&quot;</span><br><span class="line">          :list=&quot;ocr_comm&quot; :show=&quot;loading&quot; :err=&quot;err&quot;&gt;&lt;/Canvas&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import Canvas from &apos;components/HomeChildren/Canvas/Canvas&apos;</span><br><span class="line"></span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &quot;ocr_comm&quot;,</span><br><span class="line">    components: &#123;</span><br><span class="line">      Canvas</span><br><span class="line">    &#125;,</span><br><span class="line">    data() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        CW: &apos;400px&apos;,</span><br><span class="line">        CH: &apos;400px&apos;,</span><br><span class="line">        result_title: &apos;通用OCR识别结果&apos;,</span><br><span class="line">        ocr_comm: [],</span><br><span class="line">        loading: false,</span><br><span class="line">        err: false</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>

<p>图片自适应及绘图，使用async解决异步影响：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">async upload(file, canvas) &#123;</span><br><span class="line">        // console.log(file)</span><br><span class="line">        if (!file) return;</span><br><span class="line">        // 加载图标显示</span><br><span class="line">        this.loading = true</span><br><span class="line">        // 图片缩放比例</span><br><span class="line">        let widthScal = 0</span><br><span class="line">        // 先基于FileReader进行文件的读取</span><br><span class="line">        let fileExample = new FileReader();</span><br><span class="line">        // console.dir(fileExample)</span><br><span class="line">        fileExample.readAsDataURL(file);</span><br><span class="line">        fileExample.onload = ev =&gt; &#123;</span><br><span class="line">          // 创建新图片</span><br><span class="line">          // console.dir(ev)</span><br><span class="line">          this.IMAGE = new Image();</span><br><span class="line">          this.IMAGE.src = ev.target.result;</span><br><span class="line">          this.IMAGE.onload = () =&gt; &#123;</span><br><span class="line">            this.IW = this.IMAGE.width;</span><br><span class="line">            this.IH = this.IMAGE.height;</span><br><span class="line">            const NCW = parseInt(this.CW);</span><br><span class="line">            const NCH = parseInt(this.CW);</span><br><span class="line">            // 重新按照比例计算宽高</span><br><span class="line">            let n = 1;</span><br><span class="line">            if (this.IW &gt; this.IH) &#123;</span><br><span class="line">              n = this.IW / NCW;</span><br><span class="line">              this.IW = NCW;</span><br><span class="line">              this.IH = this.IH / n;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">              n = this.IH / NCH;</span><br><span class="line">              this.IH = NCH;</span><br><span class="line">              this.IW = this.IW / n;</span><br><span class="line">            &#125;</span><br><span class="line">            this.IL = (NCW - this.IW) / 2;</span><br><span class="line">            this.IT = (NCH - this.IH) / 2;</span><br><span class="line">            widthScal = this.IW / this.IMAGE.width;</span><br><span class="line">            // console.log(zoom.width)</span><br><span class="line">            // 绘制图片</span><br><span class="line">            this.CTX = canvas.getContext(&quot;2d&quot;);</span><br><span class="line">            // 清空画布</span><br><span class="line">            this.CTX.clearRect(0, 0, parseInt(this.CW), parseInt(this.CH));</span><br><span class="line">            // 绘制图片</span><br><span class="line">            this.CTX.drawImage(this.IMAGE, this.IL, this.IT, this.IW, this.IH);</span><br><span class="line">          &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        //上传文件</span><br><span class="line">        await this.uploadImg(file)</span><br><span class="line">        this.strokeRect(widthScal)</span><br><span class="line">      &#125;,</span><br></pre></td></tr></table></figure>

<p>描框代码，这里的序号字体自适应使用字符串拼接形式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">strokeRect(widthScal) &#123;</span><br><span class="line">        if (this.ocr_comm.length !== 0) &#123;</span><br><span class="line">          for (let i = 0; i &lt; this.ocr_comm.length; i++) &#123;</span><br><span class="line">            // console.log(this.ocr_comm)</span><br><span class="line">            let show = this.ocr_comm[i]</span><br><span class="line">            // 原图坐标</span><br><span class="line">            // console.log(show)</span><br><span class="line">            let X1 = show.pos.left_top.x</span><br><span class="line">            let Y1 = show.pos.left_top.y</span><br><span class="line">            let X2 = show.pos.right_bottom.x</span><br><span class="line">            let Y2 = show.pos.right_bottom.y</span><br><span class="line">            let startPoint = [X1, Y1],</span><br><span class="line">              endPoint = [X2, Y2];</span><br><span class="line">            let Num_x = startPoint[0] * widthScal + this.IL</span><br><span class="line">            let Num_y = startPoint[1] * widthScal + this.IT</span><br><span class="line">            let Num_width = (endPoint[0] - startPoint[0]) * widthScal</span><br><span class="line">            let Num_height = (endPoint[1] - startPoint[1]) * widthScal</span><br><span class="line">            this.CTX.strokeStyle = &apos;blue&apos;;</span><br><span class="line">            this.CTX.strokeRect(Num_x, Num_y, Num_width, Num_height);</span><br><span class="line">            if (Num_width &lt; Num_height) &#123;</span><br><span class="line">              let top_x = Num_x</span><br><span class="line">              let top_y = (startPoint[1] - (endPoint[0] - startPoint[0])) * widthScal + this.IT</span><br><span class="line">              let w_h = Num_width</span><br><span class="line">              // console.log(w_h)</span><br><span class="line">              let fontsize=w_h+&apos;px&apos;</span><br><span class="line">              let fontFamily=&quot;宋体&quot;</span><br><span class="line">              let Num_font=fontsize+&apos; &apos;+fontFamily</span><br><span class="line">              this.CTX.font=Num_font</span><br><span class="line">              this.CTX.strokeStyle = &apos;#006bff&apos;</span><br><span class="line">              this.CTX.fillStyle = &apos;#006bff&apos;</span><br><span class="line">              this.CTX.fillText(i + 1, Num_x + (w_h / 2), Num_y, w_h)</span><br><span class="line">              this.CTX.strokeRect(top_x, top_y, w_h, w_h)</span><br><span class="line">              this.CTX.textAlign = &apos;center&apos;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">              let left_X = (startPoint[0] - (endPoint[1] - startPoint[1])) * widthScal + this.IL</span><br><span class="line">              let left_Y = Num_y</span><br><span class="line">              let W_H = Num_height</span><br><span class="line">              let fontsize=W_H+&apos;px&apos;</span><br><span class="line">              let fontFamily=&quot;宋体&quot;</span><br><span class="line">              let Num_font=fontsize+&apos; &apos;+fontFamily</span><br><span class="line">              this.CTX.font=Num_font</span><br><span class="line">              this.CTX.strokeStyle = &apos;#006bff&apos;</span><br><span class="line">              this.CTX.fillStyle = &apos;#006bff&apos;</span><br><span class="line">              this.CTX.fillText(i + 1, left_X + W_H / 2, left_Y + W_H, W_H)</span><br><span class="line">              this.CTX.strokeRect(left_X, left_Y, W_H, W_H)</span><br><span class="line">              this.CTX.textAlign = &apos;center&apos;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          console.log(&quot;数据未取到&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br></pre></td></tr></table></figure>

<p>上传代码到后台服务器，前端使用api代理解决跨域问题：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">async uploadImg(file) &#123;</span><br><span class="line">        var forms = new FormData();</span><br><span class="line">        forms.append(&apos;file&apos;, file)</span><br><span class="line">        let config = &#123;</span><br><span class="line">          headers: &#123;&apos;Content-Type&apos;: &apos;multipart/form-data&apos;&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        await this.$axios.post(&apos;/apidebug_imagequery?action=ocr_comm&apos;, forms, config)</span><br><span class="line">          .then(res =&gt; &#123;</span><br><span class="line">            console.log(res);</span><br><span class="line">            this.loading = false</span><br><span class="line">            if (res.data.ocrcomm_res.items.length !== 0) &#123;</span><br><span class="line">              this.ocr_comm = res.data.ocrcomm_res.items</span><br><span class="line">              console.log(this.ocr_comm)</span><br><span class="line">              this.err = false</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">              this.ocr_comm = []</span><br><span class="line">              this.err = true</span><br><span class="line">            &#125;</span><br><span class="line">            // resolve(this.ocr_comm)</span><br><span class="line">          &#125;).catch(err =&gt; &#123;</span><br><span class="line">            //补充异常处理代码</span><br><span class="line">            console.log(err)</span><br><span class="line">          &#125;)</span><br><span class="line">      &#125;,</span><br></pre></td></tr></table></figure>

<p>至此！canvas的相关实现就是这些，图片预览仅用于小程序中，解决模糊问题是难点。canvas远比自己想的强大，现在所知也是九牛一毛，以后再会~！</p>
]]></content>
      <tags>
        <tag>html5</tag>
        <tag>canvas</tag>
      </tags>
  </entry>
  <entry>
    <title>节流和防抖</title>
    <url>/2020/06/01/%E8%8A%82%E6%B5%81%E5%92%8C%E9%98%B2%E6%8A%96/</url>
    <content><![CDATA[<h1 id="性能优化问题"><a href="#性能优化问题" class="headerlink" title="性能优化问题"></a>性能优化问题</h1><h2 id="Js知识"><a href="#Js知识" class="headerlink" title="Js知识"></a>Js知识</h2><a id="more"></a>

<h3 id="防抖与节流"><a href="#防抖与节流" class="headerlink" title="防抖与节流"></a>防抖与节流</h3><p>防抖与节流是前端最基本的优化技巧，实现很简单，为了记录下，可供学习参考。</p>
<h4 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h4><h5 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h5><p>防抖就是在持续触发事件的时候，只有当不触发事件一段时间后才会执行处理的函数，当触发一次事件后，在规定事件内再次触发， 就会清除上次的定时任务，重新创建定时任务。</p>
<ul>
<li>实现方式：每次触发事件时设置一个延迟调用方法，并且取消之前的延时调用方法</li>
<li>缺点：如果事件在规定的时间间隔内被不断的触发，则调用方法会被不断的延迟</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//防抖debounce代码：</span><br><span class="line">function debounce(fn,delay) &#123;</span><br><span class="line">    var timeout = null; // 创建一个标记用来存放定时器的返回值</span><br><span class="line">    return function (e) &#123;</span><br><span class="line">        // 每当用户输入的时候把前一个 setTimeout clear 掉</span><br><span class="line">        clearTimeout(timeout); </span><br><span class="line">        // 然后又创建一个新的 setTimeout, 这样就能保证interval 间隔内如果时间持续触发，就不会执行 fn 函数</span><br><span class="line">        timeout = setTimeout(() =&gt; &#123;</span><br><span class="line">            fn.apply(this, arguments);</span><br><span class="line">        &#125;, delay);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">// 处理函数</span><br><span class="line">function handle() &#123;</span><br><span class="line">    console.log(&apos;防抖：&apos;, Math.random());</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">//滚动事件</span><br><span class="line">window.addEventListener(&apos;scroll&apos;, debounce(handle,500));</span><br></pre></td></tr></table></figure>

<h4 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h4><h5 id="概念：-1"><a href="#概念：-1" class="headerlink" title="概念："></a>概念：</h5><p>节流就是在持续触发事件的时候，利用标志位进行控制处理函数是否执行，比如为 true 执行，为 false 不执行<br>通过指定间隔时间修改标志位的值即可实现在指定时间内只触发一次处理函数</p>
<ul>
<li>实现方式：每次触发事件时，如果当前有等待执行的延时函数，则直接return<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//节流throttle代码：</span><br><span class="line">function throttle(fn,delay) &#123;</span><br><span class="line">    let canRun = true; // 通过闭包保存一个标记</span><br><span class="line">    return function () &#123;</span><br><span class="line">         // 在函数开头判断标记是否为true，不为true则return</span><br><span class="line">        if (!canRun) return;</span><br><span class="line">         // 立即设置为false</span><br><span class="line">        canRun = false;</span><br><span class="line">        // 将外部传入的函数的执行放在setTimeout中</span><br><span class="line">        setTimeout(() =&gt; &#123; </span><br><span class="line">        // 最后在setTimeout执行完毕后再把标记设置为true(关键)表示可以执行下一次循环了。</span><br><span class="line">        // 当定时器没有执行的时候标记永远是false，在开头被return掉</span><br><span class="line">            fn.apply(this, arguments);</span><br><span class="line">            canRun = true;</span><br><span class="line">        &#125;, delay);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">function sayHi(e) &#123;</span><br><span class="line">    console.log(&apos;节流：&apos;, e.target.innerWidth, e.target.innerHeight);</span><br><span class="line">&#125;</span><br><span class="line">window.addEventListener(&apos;resize&apos;, throttle(sayHi,500));</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><strong>函数防抖</strong>：将多次操作合并为一次操作进行。原理是维护一个计时器，规定在delay时间后触发函数，但是在delay时间内再次触发的话，就会取消之前的计时器而重新设置。这样一来，只有最后一次操作能被触发。<br><strong>函数节流</strong>：使得一定时间内只触发一次函数。原理是通过判断是否有延迟调用函数未执行。<br><strong>区别</strong>： 函数节流不管事件触发有多频繁，都会保证在规定时间内一定会执行一次真正的事件处理函数，而函数防抖只是在最后一次事件后才触发一次函数。 比如在页面的无限加载场景下，我们需要用户在滚动页面时，<br>每隔一段时间发一次 Ajax 请求，而不是在用户停下滚动页面操作时才去请求数据。这样的场景，就适合用节流技术来实现。</p>
]]></content>
      <tags>
        <tag>Js</tag>
        <tag>Js封装</tag>
      </tags>
  </entry>
  <entry>
    <title>Js同步与异步</title>
    <url>/2020/04/01/JS%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5/</url>
    <content><![CDATA[<h1 id="Js的同步与异步问题"><a href="#Js的同步与异步问题" class="headerlink" title="Js的同步与异步问题"></a>Js的同步与异步问题</h1><h2 id="Js知识"><a href="#Js知识" class="headerlink" title="Js知识"></a>Js知识</h2><a id="more"></a>

<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>如果有人问你Js的同步异步问题，你该怎么回答？理解一个问题无非是what-why-how，js同步和异步问题是什么–&gt;为什么会产生异步问题–&gt;如何解决。</p>
<blockquote>
<p>首先，我们要知道Js是单线程的，同一时间只处理一个任务，这已经成这门语言的核心特征。</p>
</blockquote>
<h3 id="同步与异步（重点）"><a href="#同步与异步（重点）" class="headerlink" title="同步与异步（重点）"></a>同步与异步（重点）</h3><p><font color="orange">同步</font>就是任务放入到队列中后按照顺序执行；<br><font color="orange">异步</font>就是同时进行多个任务。<br>举个例子：比方说你要烧水做菜，如果你先烧水，等着水烧开，再去做菜，这就是同步操作；但如果你边烧着水，同时准备做菜材料，同时进行，这就是异步操作；<br>&nbsp;<br>js单线程是执行同步操作的，但有时也需要异步操作，防止某一块解析时间过长，造成“卡死”情况。<br>那么，js单线程又是如何实现异步的呢? ——<strong>是通过事件循环实现“异步”</strong><br>js中，最基础的异步是setTimeout和setInterval函数，还有onclick, ajax等异步操作。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> console.log(&apos;1&apos;)</span><br><span class="line">setTimeout(function()&#123;</span><br><span class="line"> console.log(&apos;2&apos;)</span><br><span class="line">&#125;,0)</span><br><span class="line">console.log(&apos;3&apos;)  </span><br><span class="line">//输出       1，3，2</span><br></pre></td></tr></table></figure>

<h3 id="promise解决异步问题"><a href="#promise解决异步问题" class="headerlink" title="promise解决异步问题"></a>promise解决异步问题</h3><p>promise解决嵌套回调的问题，将嵌套的回调函数改成.then()的连缀使用。<br>Promise有这些特征：只能决议一次，决议值只能有一个，决议之后无法改变。任何then中的回调也只会被调用一次。Promise的特征保证了Promise可以解决信任问题。</p>
<h4 id="promise-的使用"><a href="#promise-的使用" class="headerlink" title="promise 的使用"></a>promise 的使用</h4><blockquote>
<p>首先通过new Promise（function）创建一个promise对象，接收一个函数参数，并且在函数中传入resolve以及reject两个参数；</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var p = new Promise(function(resolve, reject)&#123;      </span><br><span class="line">            //做一些异步操作</span><br><span class="line">            setTimeout(function()&#123;</span><br><span class="line">                console.log(&apos;这是一个异步操作&apos;);</span><br><span class="line">                resolve(&apos;异步操作成功并且结束&apos;);</span><br><span class="line">            &#125;, 1000);</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>then() 接收两个函数，分别是对promise的resolve及reject状态处理的函数，并且处理结束之后返回promise对象</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function fn1() &#123;</span><br><span class="line">       console.log(&quot;第一个函数开始执行&quot;);</span><br><span class="line">       var p = new Promise(function (resolve, reject) &#123;</span><br><span class="line">           setTimeout(function () &#123;</span><br><span class="line">               console.log(&apos;第一个函数执行完毕&apos;);</span><br><span class="line">               resolve(&apos;接下来进入第二个函数&apos;);</span><br><span class="line">           &#125;, 1000);</span><br><span class="line">       &#125;);</span><br><span class="line">       return p;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   function fn2(data) &#123;</span><br><span class="line">       console.log(data);</span><br><span class="line">       console.log(&apos;第二个函数开始执行&apos;);</span><br><span class="line">       var p = new Promise(function (resolve, reject) &#123;</span><br><span class="line">           setTimeout(function () &#123;</span><br><span class="line">               var num = Math.ceil(Math.random() * 10); // 生成随机数</span><br><span class="line">              console.log(num);</span><br><span class="line">               //num = 0；设置num=0</span><br><span class="line">               if (num === 0) &#123;</span><br><span class="line">                   console.log(&apos;第二个函数执行完毕&apos;);</span><br><span class="line">                   resolve(&apos;所有函数执行完毕&apos;);</span><br><span class="line">               &#125;</span><br><span class="line">               else&#123;</span><br><span class="line">                   reject(&quot;执行函数2失败&quot;);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;, 2000);</span><br><span class="line">       &#125;);</span><br><span class="line">       return p;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   fn1()</span><br><span class="line">       .then(function (data) &#123;</span><br><span class="line">           return fn2(data);</span><br><span class="line">       &#125;)</span><br><span class="line">       .then(function (data) &#123;</span><br><span class="line">           console.log(data);</span><br><span class="line">       &#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li><em>第一个函数开始执行</em></li>
<li><em>第一个函数执行完毕</em></li>
<li><em>接下来进入第二个函数</em></li>
<li><em>第二个函数开始执行</em></li>
<li><em>第二个函数执行完毕</em></li>
<li><em>所有函数执行完毕</em><br>&emsp;&emsp;<font size="2">调用reslove</font></li>
</ul>
<p>.all() 接收一个函数数组，进行并发操作，并将每个函数的结果以数组的形式返回。<br>.race()接收函数数组，函数先执行完成之后先进入下一个回调函数中。<br>.catch() 当then中出现错误时不会中止整个函数，catch能够获取到错误并进行提示。   </p>
<h2 id="这几种方法不做详述啦！会用即可，好了！今天先到这里，我们下期见"><a href="#这几种方法不做详述啦！会用即可，好了！今天先到这里，我们下期见" class="headerlink" title="这几种方法不做详述啦！会用即可，好了！今天先到这里，我们下期见!"></a>这几种方法不做详述啦！会用即可，好了！今天先到这里，我们下期见!</h2>]]></content>
      <tags>
        <tag>Js</tag>
        <tag>解决异步</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue双向绑定原理</title>
    <url>/2020/03/23/Vue%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="详述Vue的数据双向绑定原理"><a href="#详述Vue的数据双向绑定原理" class="headerlink" title="详述Vue的数据双向绑定原理"></a>详述Vue的数据双向绑定原理</h1><h2 id="前端知识"><a href="#前端知识" class="headerlink" title="前端知识"></a>前端知识</h2><a id="more"></a>

<blockquote>
<p>Vue实现双向数据绑定的原理就是利用了 Object.defineProperty() 这个方法重新定义了对象获取属性值(get)和设置属性值(set)的操作来实现的。</p>
</blockquote>
<p>另一种说法：vue的双向绑定是由数据劫持结合发布者－订阅者模式实现的。（这里不懂没关系，接着往下看…）<br>首先，我们我们需要一个监听器Observer来给所有的属性设置set函数。如果属性发生了变化，就要通知所有的订阅者Watcher。而这些Watcher统一存放在消息订阅器Dep中，这样比较方便统一管理。Watcher接受到来自Dep的通知后就执行相应的操作去更新视图。<br>&nbsp;</p>
<h3 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h3><blockquote>
<p>监听器的核心代码如下：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function observe(data) &#123;</span><br><span class="line">  if (!data || typeof data !== &apos;object&apos;) &#123;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  Object.keys(data).forEach(function(key) &#123;  // 遍历属性，递归设置set函数</span><br><span class="line">    defineReactive(data, key, data[key]);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">function defineReactive(data, key, val) &#123;</span><br><span class="line">  observe(val)</span><br><span class="line">  var dep = new Dep()</span><br><span class="line">  Object.defineProperty(data, key, &#123;</span><br><span class="line">    enumerable: true,</span><br><span class="line">    configurable: true,</span><br><span class="line">    get: function() &#123;</span><br><span class="line">      if (Dep.target) &#123;</span><br><span class="line">        dep.addSub(Dep.target)  // 添加watcher</span><br><span class="line">      &#125;</span><br><span class="line">      return val</span><br><span class="line">    &#125;,</span><br><span class="line">    set: function(newVal) &#123;</span><br><span class="line">      if (val === newVal) &#123;</span><br><span class="line">        return;</span><br><span class="line">      &#125;</span><br><span class="line">      val = newVal;</span><br><span class="line">      dep.notify()  // 通知dep</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过调用observe（）函数来递归地给data对象设置set和get函数，在data的属性被get时添加watcher，被set时通知dep，dep的notify会接着通知所有的watcher去执行更新操作。<br>&nbsp;<br>这里需要对defineProperty做一个补充，上述的observe递归过程，在value值为对象时会继续递归，只有当value值是非对象时才return，然后调用definePropery。所以对于data里面的数组arr，vue实际监听的是arr[0]、arr[1]…arr[n]，而不是arr本身。所以对于改变arr的操作，arr[0] = 9这样是可以被监听到的，而arr.push(‘123’)这样是不行的，因为push方法本质上只是改变了arr[n+1]的值，而这个值本身是没有被监听的，即没有设置set函数。<br>vue为了方便我们对数组的操作，对数组的一些常用方法进行额外的封装，即对vue的data的属性的原型赋值为封装层，当我们使用this.arr.push时，根据原型链向上找会先找到封装层的push，而不会使用原生的push。封装层的push做的事情是先触发原生push方法，然后再监听新push的项，再触发消息订阅器dep的notify方法，从而提醒watcher去更新视图。<br>&nbsp;</p>
<h3 id="Dep"><a href="#Dep" class="headerlink" title="Dep"></a>Dep</h3><blockquote>
<p>消息订阅器的核心代码如下：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Dep() &#123;</span><br><span class="line">  this.subs = []  // 订阅者数组</span><br><span class="line">&#125;</span><br><span class="line">Dep.prototype = &#123;</span><br><span class="line">  addSub: function(sub) &#123;</span><br><span class="line">    this.subs.push(sub)</span><br><span class="line">  &#125;,</span><br><span class="line">  notify: function() &#123;</span><br><span class="line">    this.subs.forEach(function(sub) &#123;</span><br><span class="line">      sub.update()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Dep.target = null</span><br></pre></td></tr></table></figure>

<p>消息订阅器比较简单，就是维护一个subs数组。当监听新属性时把它push进subs数组中，然后dep被通知时触发notify函数，从而触发subs数组中每个watcher的update操作。<br>&nbsp;</p>
<h3 id="Watcher"><a href="#Watcher" class="headerlink" title="Watcher"></a>Watcher</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Watcher(vm, exp, cb) &#123;</span><br><span class="line">  this.cb = cb</span><br><span class="line">  this.vm = vm</span><br><span class="line">  this.exp = exp</span><br><span class="line">  this.value = this.get()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Watcher.prototype = &#123;</span><br><span class="line">  update: function() &#123;</span><br><span class="line">    this.run()</span><br><span class="line">  &#125;,</span><br><span class="line">  run: function() &#123;</span><br><span class="line">    var value = this.vm.data[this.exp]</span><br><span class="line">    var oldVal = this.value</span><br><span class="line">    if (value !== oldVal) &#123;</span><br><span class="line">      this.value = value</span><br><span class="line">      this.cb.call(this.vm, value, oldVal)  // 执行更新时的回调函数</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  get: function() &#123;</span><br><span class="line">    Dep.target = this</span><br><span class="line">    var value = this.vm.data[this.exp]  // 读取data的属性，从而执行属性的get函数</span><br><span class="line">    Dep.target = null</span><br><span class="line">    return value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Watcher的主要功能是去触发属性的get函数，从而添加watcher到Dep的subs数组中。另外就是在update()中更新属性的值并触发更新回调函数。<br>使用Watcher的方法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var el = document.getElementById(&apos;XXX&apos;)</span><br><span class="line">observe(data)</span><br><span class="line">new Watcher(vm, exp, function(value) &#123;  // vm表示某个实例,exp表示属性名</span><br><span class="line">  el.innerHTML = value</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>为了使用时的整洁，我们需要把代码稍微包装下。</p>
<h3 id="SimpleVue"><a href="#SimpleVue" class="headerlink" title="SimpleVue"></a>SimpleVue</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function SimpleVue (data, el, exp) &#123;</span><br><span class="line">  var self = this</span><br><span class="line">  this.data = data</span><br><span class="line">  Object.keys(data).forEach(function(key) &#123;</span><br><span class="line">    self.proxyKeys(key)</span><br><span class="line">  &#125;)</span><br><span class="line">  observe(data)</span><br><span class="line">  el.innerHTML = this.data[exp]</span><br><span class="line">  new Watcher(this, exp, function(value) &#123;</span><br><span class="line">    el.innerHTML = value</span><br><span class="line">  &#125;)</span><br><span class="line">  return this</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SimpleVue.prototype = &#123;</span><br><span class="line">  proxyKeys: function(key) &#123;</span><br><span class="line">    var self = this</span><br><span class="line">    Object.defineProperty(this, key, &#123;</span><br><span class="line">      enumerable: false,</span><br><span class="line">      configurable: true,</span><br><span class="line">      get: function() &#123;</span><br><span class="line">        return self.data[key]</span><br><span class="line">      &#125;,</span><br><span class="line">      set: function(newVal) &#123;</span><br><span class="line">        self.data[key] = newVal</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SimpleVue做的事情就是使用observe递归地给data的每个属性都加上get和set，然后对于要监听的属性exp新建一个Watcher对象去监听。（Watcher对象触发属性exp的get函数从而添加订阅事件到Dep，而且会在属性的update方法里面触发监听回调函数）<br>使用如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// html</span><br><span class="line">&lt;h1 id=&quot;name&quot;&gt;&#123;&#123;name&#125;&#125;&lt;/h1&gt;  //这个&#123;&#123;name&#125;&#125;暂时没用</span><br><span class="line"></span><br><span class="line">// js</span><br><span class="line">var el = document.querySelector(&apos;#name&apos;)</span><br><span class="line">var selfVue = new SimpleVue(&#123; name: &apos;hello&apos;&#125;, el, &apos;name&apos;)</span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">  selfVue.name = &apos;123&apos;</span><br><span class="line">&#125;, 2000)</span><br></pre></td></tr></table></figure>

<p>需要注意的是SimpleVue原型的proxyKeys是为了将selfVue.data.name这种操作代理为selfVue.name。这下我们就可以直接通过selfVue.name = “XXX”来改变数据了，并且视图也会相应变化。</p>
<h3 id="Compile"><a href="#Compile" class="headerlink" title="Compile"></a>Compile</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nodeToFragement: function(el) &#123;</span><br><span class="line">    var fragment = document.createDocumentFragment()</span><br><span class="line">    var child = el.firstChild</span><br><span class="line">    // 将dom节点移到fragment</span><br><span class="line">    while(child) &#123;</span><br><span class="line">      fragment.appendChild(child)</span><br><span class="line">      child = el.firstChild</span><br><span class="line">    &#125;</span><br><span class="line">    return fragment</span><br><span class="line">  &#125;,</span><br><span class="line">  compileElement: function(el) &#123;</span><br><span class="line">    var childNodes = el.childNodes</span><br><span class="line">    var self = this;</span><br><span class="line">    [].slice.call(childNodes).forEach(function(node) &#123;</span><br><span class="line">      var reg = /\&#123;\&#123;(.*)\&#125;\&#125;/</span><br><span class="line">      var text = node.textContent</span><br><span class="line">      if (self.isTextNode(node) &amp;&amp; reg.test(text)) &#123;</span><br><span class="line">        self.compileText(node, reg.exec(text)[1])</span><br><span class="line">      &#125;</span><br><span class="line">      if (node.childNodes &amp;&amp; node.childNodes.length) &#123;</span><br><span class="line">        self.compileElement(node)  // 递归遍历子节点</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">  compileText: function(node, exp) &#123;</span><br><span class="line">    var self = this</span><br><span class="line">    var initText = this.vm[exp]</span><br><span class="line">    this.updateText(node, initText)</span><br><span class="line">    new Watcher(this.vm, exp, function(value) &#123;</span><br><span class="line">      self.updateText(node, value)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>

<p>compile将dom节点移入DocumentFragment中去，并递归调用compileElement函数来遍历所有子节点，compileText函数创建新的watcher。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function SimpleVue (options) &#123;</span><br><span class="line">  var self = this</span><br><span class="line">  this.vm = this</span><br><span class="line">  this.data = options.data</span><br><span class="line">  Object.keys(this.data).forEach(function(key) &#123;</span><br><span class="line">    self.proxyKeys(key)</span><br><span class="line">  &#125;)</span><br><span class="line">  observe(this.data)</span><br><span class="line">  new Compile(options.el, this.vm)</span><br><span class="line">  return this</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&nbsp;</p>
<hr>
<h2 id="好了！以上就是全部内容啦-希望可以帮到你！！！"><a href="#好了！以上就是全部内容啦-希望可以帮到你！！！" class="headerlink" title="好了！以上就是全部内容啦~~希望可以帮到你！！！"></a>好了！以上就是全部内容啦~~希望可以帮到你！！！</h2>]]></content>
      <tags>
        <tag>Vue</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>小程序开发和Vue组件化开发的使用区别</title>
    <url>/2020/03/21/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%8EVue%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h1 id="总结一下二者的共同点和区别"><a href="#总结一下二者的共同点和区别" class="headerlink" title="总结一下二者的共同点和区别"></a>总结一下二者的共同点和区别</h1><h2 id="前端知识"><a href="#前端知识" class="headerlink" title="前端知识"></a>前端知识</h2><a id="more"></a>
<p>写了vue项目和小程序，发现二者有许多相同之处，在此想总结一下二者的共同点和区别。</p>
<h3 id="1-生命周期"><a href="#1-生命周期" class="headerlink" title="1.生命周期"></a>1.生命周期</h3><blockquote>
<p>vue生命周期：</p>
</blockquote>
<p><img src="https://segmentfault.com/img/bVVORa?w=1200&h=3039/view" alt></p>
<blockquote>
<p>小程序生命周期:</p>
</blockquote>
<p><img src="https://segmentfault.com/img/bVbcfCK?w=662&h=1014" alt><br>相比之下，小程序的钩子函数要简单得多。<br>vue的钩子函数在跳转新页面时，钩子函数都会触发，但是小程序的钩子函数，页面不同的跳转方式，触发的钩子并不一样。</p>
<p>onLoad: 页面加载<br>一个页面只会调用一次，可以在 onLoad 中获取打开当前页面所调用的 query 参数。</p>
<p>onShow: 页面显示<br>每次打开页面都会调用一次。</p>
<p>onReady: 页面初次渲染完成<br>一个页面只会调用一次，代表页面已经准备妥当，可以和视图层进行交互。</p>
<p>对界面的设置如wx.setNavigationBarTitle请在onReady之后设置。详见生命周期</p>
<p>onHide: 页面隐藏<br>当navigateTo或底部tab切换时调用。</p>
<p>onUnload: 页面卸载<br>当redirectTo或navigateBack的时候调用。</p>
<p>数据请求:</p>
<p>在页面加载请求数据时，两者钩子的使用有些类似，vue一般会在created或者mounted中请求数据，而在小程序，会在onLoad或者onShow中请求数据。</p>
<h3 id="2-数据绑定"><a href="#2-数据绑定" class="headerlink" title="2.数据绑定"></a>2.数据绑定</h3><p>VUE:vue动态绑定一个变量的值为元素的某个属性的时候，会在变量前面加上冒号：，例：<br><code>1.  &lt;img :src=&quot;imgSrc&quot;/&gt;</code><br>小程序：绑定某个变量的值为元素属性时，会用两个大括号括起来，如果不加括号，为被认为是字符串。例：<br><code>1.  &lt;image src=&quot;&quot;&gt;&lt;/image&gt;</code></p>
<h3 id="3-列表渲染"><a href="#3-列表渲染" class="headerlink" title="3.列表渲染"></a>3.列表渲染</h3><p>两者还是有些相似</p>
<blockquote>
<p>vue：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">1.  &lt;ul id=&quot;example-1&quot;&gt;  </span><br><span class="line">2.  &lt;li v-for=&quot;item in items&quot;&gt;  </span><br><span class="line">3.  &#123;&#123; item.message &#125;&#125;  </span><br><span class="line">4.  &lt;/li&gt;  </span><br><span class="line">5\.  &lt;/ul&gt;  </span><br><span class="line"></span><br><span class="line">7.  var example1 = new Vue(&#123;  </span><br><span class="line">8.  el: &apos;#example-1&apos;,  </span><br><span class="line">9.  data: &#123;  </span><br><span class="line">10.  items: [  </span><br><span class="line">11.  &#123; message: &apos;苹果&apos; &#125;,  </span><br><span class="line">12.  &#123; message: &apos;橘子&apos; &#125;  </span><br><span class="line">13.  ] </span><br><span class="line">14.  &#125;  </span><br><span class="line">15.  &#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>小程序:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.  Page(&#123;  </span><br><span class="line">2.  data: &#123;  </span><br><span class="line">3.  items: [  </span><br><span class="line">4.  &#123; message: &apos;苹果&apos; &#125;,  </span><br><span class="line">5.  &#123; message: &apos;橘子&apos; &#125;  </span><br><span class="line">6.  ]  </span><br><span class="line">7.  &#125;  </span><br><span class="line">8.  &#125;)  </span><br><span class="line"></span><br><span class="line">10.  &lt;text wx:for=&quot;&#123;&#123;items&#125;&#125;&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/text&gt;</span><br></pre></td></tr></table></figure>

<h3 id="4-显示与隐藏元素"><a href="#4-显示与隐藏元素" class="headerlink" title="4.显示与隐藏元素"></a>4.显示与隐藏元素</h3><p>vue中，使用v-if 和v-show控制元素的显示和隐藏</p>
<p>小程序中，使用wx-if和hidden控制元素的显示和隐藏</p>
<h3 id="5-事件处理"><a href="#5-事件处理" class="headerlink" title="5.事件处理"></a>5.事件处理</h3><p>vue：使用v-on:event绑定事件，或者使用@event绑定事件,例如:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.  &lt;button v-on:click=&quot;counter += 1&quot;&gt;Add 1&lt;/button&gt;  </span><br><span class="line">2\.  &lt;button v-on:click.stop=&quot;counter+=1&quot;&gt;Add1&lt;/button&gt;  //阻止事件冒泡</span><br></pre></td></tr></table></figure>

<p>小程序中，全用bindtap(bind+event)，或者catchtap(catch+event)绑定事件,例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.  &lt;button bindtap=&quot;noWork&quot;&gt;明天不上班&lt;/button&gt;  </span><br><span class="line">2.  &lt;button catchtap=&quot;noWork&quot;&gt;明天不上班&lt;/button&gt;  //阻止事件冒泡</span><br></pre></td></tr></table></figure>

<h3 id="6-数据双向绑定"><a href="#6-数据双向绑定" class="headerlink" title="6.数据双向绑定"></a>6.数据双向绑定</h3><p><strong>1.设置值</strong></p>
<p>在vue中,只需要再表单元素上加上v-model,然后再绑定data中对应的一个值，当表单元素内容发生变化时，data中对应的值也会相应改变，这是vue非常nice的一点。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">1.  &lt;div id=&quot;app&quot;&gt;  </span><br><span class="line">2.  &lt;input v-model=&quot;reason&quot; placeholder=&quot;填写理由&quot; class=&apos;reason&apos;/&gt;  </span><br><span class="line">3.  &lt;/div&gt;  </span><br><span class="line"></span><br><span class="line">5.  new Vue(&#123;  </span><br><span class="line">6.  el: &apos;#app&apos;,  </span><br><span class="line">7.  data: &#123;  </span><br><span class="line">8.  reason:&apos;&apos;  </span><br><span class="line">9.  &#125;  </span><br><span class="line">10.  &#125;)</span><br></pre></td></tr></table></figure>

<p>但是在小程序中，却没有这个功能。那怎么办呢？</p>
<p>当表单内容发生变化时，会触发表单元素上绑定的方法，然后在该方法中，通过this.setData({key:value})来将表单上的值赋值给data中的对应值。</p>
<p>下面是代码，可以感受一下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.  &lt;input bindinput=&quot;bindReason&quot; placeholder=&quot;填写理由&quot; class=&apos;reason&apos; value=&apos;&#123;&#123;reason&#125;&#125;&apos; name=&quot;reason&quot; /&gt;  </span><br><span class="line">2.  Page(&#123;  </span><br><span class="line">3.  data:&#123;  </span><br><span class="line">4.  reason:&apos;&apos;  </span><br><span class="line">5.  &#125;,  </span><br><span class="line">6.  bindReason(e) &#123;  </span><br><span class="line">7.  this.setData(&#123;  </span><br><span class="line">8.  reason: e.detail.value  </span><br><span class="line">9.  &#125;)  </span><br><span class="line">10.  &#125;  </span><br><span class="line">11.  &#125;)</span><br></pre></td></tr></table></figure>

<p>当页面表单元素很多的时候，更改值就是一件体力活了。和小程序一比较，vue的v-model简直爽的不要不要的。<br><strong>2.取值</strong></p>
<p>vue中，通过this.reason取值</p>
<p>小程序中，通过this.data.reason取值</p>
<h3 id="7-绑定事件传参"><a href="#7-绑定事件传参" class="headerlink" title="7.绑定事件传参"></a>7.绑定事件传参</h3><p>在vue中，绑定事件传参挺简单，只需要在触发事件的方法中，把需要传递的数据作为形参传入就可以了，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.  &lt;button @click=&quot;say(&apos;明天不上班&apos;)&quot;&gt;&lt;/button&gt;  </span><br><span class="line">2.  new Vue(&#123;  </span><br><span class="line">3.  el: &apos;#app&apos;,  </span><br><span class="line">4.  methods:&#123;  </span><br><span class="line">5.  say(arg)&#123;  </span><br><span class="line">6.  consloe.log(arg)  </span><br><span class="line">7.  &#125;  </span><br><span class="line">8.  &#125;  </span><br><span class="line">9.  &#125;)</span><br></pre></td></tr></table></figure>

<p>在小程序中，不能直接在绑定事件的方法中传入参数，需要将参数作为属性值，绑定到元素上的data-属性上，然后在方法中，通过e.currentTarget.dataset.*的方式获取，从而完成参数的传递，很麻烦有没有…</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.  &lt;view class=&apos;tr&apos; bindtap=&apos;toApprove&apos; data-id=&quot;&#123;&#123;item.id&#125;&#125;&quot;&gt;&lt;/view&gt;  </span><br><span class="line">2.  Page(&#123;  </span><br><span class="line">3.  data:&#123;  </span><br><span class="line">4.  reason:&apos;&apos;  </span><br><span class="line">5.  &#125;,  </span><br><span class="line">6.  toApprove(e) &#123;  </span><br><span class="line">7.  let id = e.currentTarget.dataset.id;  </span><br><span class="line">8.  &#125;  </span><br><span class="line">9.  &#125;)</span><br></pre></td></tr></table></figure>

<h3 id="8-父子组件通信"><a href="#8-父子组件通信" class="headerlink" title="8.父子组件通信"></a>8.父子组件通信</h3><p><strong>1.子组件的使用</strong></p>
<p>在vue中，需要：</p>
<p>编写子组件<br>在需要使用的父组件中通过import引入<br>在vue的components中注册<br>在模板中使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">1.  //子组件 bar.vue  </span><br><span class="line">2.  &lt;template&gt;  </span><br><span class="line">3.  &lt;div class=&quot;search-box&quot;&gt;  </span><br><span class="line">4.  &lt;div @click=&quot;say&quot; :title=&quot;title&quot; class=&quot;icon-dismiss&quot;&gt;&lt;/div&gt;  </span><br><span class="line">5.  &lt;/div&gt;  </span><br><span class="line">6\.  &lt;/template&gt;  </span><br><span class="line">7.  &lt;script&gt;  </span><br><span class="line">8.  export default&#123;  </span><br><span class="line">9.  props:&#123;  </span><br><span class="line">10.  title:&#123;  </span><br><span class="line">11.  type:String,  </span><br><span class="line">12.  default:&apos;&apos;  </span><br><span class="line">13.  &#125;  </span><br><span class="line">14.  &#125;  </span><br><span class="line">15.  &#125;, </span><br><span class="line"></span><br><span class="line">17.  methods:&#123;  </span><br><span class="line">18.  say()&#123; </span><br><span class="line">19.  console.log(&apos;明天不上班&apos;);  </span><br><span class="line">20.  this.$emit(&apos;helloWorld&apos;)  </span><br><span class="line">21.  &#125;  </span><br><span class="line">22.  &#125; </span><br><span class="line">23.  &lt;/script&gt;  </span><br><span class="line"></span><br><span class="line">25\.  // 父组件 foo.vue  </span><br><span class="line">26.  &lt;template&gt;  </span><br><span class="line">27.  &lt;div class=&quot;container&quot;&gt;  </span><br><span class="line">28.  &lt;bar :title=&quot;title&quot; @helloWorld=&quot;helloWorld&quot;&gt;&lt;/bar&gt;  </span><br><span class="line">29.  &lt;/div&gt;  </span><br><span class="line">30\.  &lt;/template&gt;  </span><br><span class="line"></span><br><span class="line">32.  &lt;script&gt;  </span><br><span class="line">33.  import Bar from &apos;./bar.vue&apos;  </span><br><span class="line">34.  export default&#123;  </span><br><span class="line">35.  data:&#123;  </span><br><span class="line">36.  title:&quot;我是标题&quot;  </span><br><span class="line">37.  &#125;,  </span><br><span class="line">38.  methods:&#123;  </span><br><span class="line">39.  helloWorld()&#123;  </span><br><span class="line">40.  console.log(&apos;我接收到子组件传递的事件了&apos;)  </span><br><span class="line">41.  &#125;  </span><br><span class="line">42.  &#125;,  </span><br><span class="line">43.  components:&#123; </span><br><span class="line">44.  Bar  </span><br><span class="line">45.  &#125;  </span><br><span class="line">46.  &lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>在小程序中，需要：<br>1.编写子组件<br>2.在子组件的json文件中，将该文件声明为组件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.  &#123;  </span><br><span class="line">2.  &quot;component&quot;: true  </span><br><span class="line">3.  &#125;</span><br></pre></td></tr></table></figure>

<p>3.在需要引入的父组件的json文件中，在usingComponents填写引入组件的组件名以及路径</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">1.  &quot;usingComponents&quot;: &#123;  </span><br><span class="line">2.  &quot;tab-bar&quot;: &quot;../../components/tabBar/tabBar&quot;  </span><br><span class="line">3.  &#125;</span><br></pre></td></tr></table></figure>

<p>4.在父组件中，直接引入即可<br><code>1.  &lt;tab-bar currentpage=&quot;index&quot;&gt;&lt;/tab-bar&gt;</code><br><strong>2.父子组件间通信</strong></p>
<p>在vue中</p>
<p>父组件向子组件传递数据，只需要在子组件通过v-bind传入一个值，在子组件中，通过props接收，即可完成数据的传递，示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">1.  // 父组件 foo.vue  </span><br><span class="line">2.  &lt;template&gt;  </span><br><span class="line">3.  &lt;div class=&quot;container&quot;&gt;  </span><br><span class="line">4.  &lt;bar :title=&quot;title&quot;&gt;&lt;/bar&gt;  </span><br><span class="line">5.  &lt;/div&gt;  </span><br><span class="line">6\.  &lt;/template&gt;  </span><br><span class="line">7.  &lt;script&gt;  </span><br><span class="line">8.  import Bar from &apos;./bar.vue&apos;  </span><br><span class="line">9.  export default&#123;  </span><br><span class="line">10.  data:&#123;  </span><br><span class="line">11.  title:&quot;我是标题&quot;  </span><br><span class="line">12.  &#125;,  </span><br><span class="line">13.  components:&#123;  </span><br><span class="line">14.  Bar  </span><br><span class="line">15.  &#125;  </span><br><span class="line">16.  &lt;/script&gt;  </span><br><span class="line"></span><br><span class="line">18\.  // 子组件bar.vue  </span><br><span class="line">19.  &lt;template&gt;  </span><br><span class="line">20.  &lt;div class=&quot;search-box&quot;&gt;  </span><br><span class="line">21.  &lt;div :title=&quot;title&quot; &gt;&lt;/div&gt;  </span><br><span class="line">22.  &lt;/div&gt;  </span><br><span class="line">23\.  &lt;/template&gt;  </span><br><span class="line">24.  &lt;script&gt;  </span><br><span class="line">25.  export default&#123;  </span><br><span class="line">26.  props:&#123;  </span><br><span class="line">27.  title:&#123;  </span><br><span class="line">28.  type:String,  </span><br><span class="line">29.  default:&apos;&apos;  </span><br><span class="line">30.  &#125;  </span><br><span class="line">31.  &#125;  </span><br><span class="line">32.  &#125;  </span><br><span class="line">33.  &lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>子组件和父组件通信可以通过this.$emit将方法和数据传递给父组件。<br>在小程序中</p>
<p>父组件向子组件通信和vue类似，但是小程序没有通过v-bind，而是直接将值赋值给一个变量，如下：<br><code>1.  &lt;tab-bar currentpage=&quot;index&quot;&gt;&lt;/tab-bar&gt;</code><br>此处， “index”就是要向子组件传递的值<br>在子组件properties中，接收传递的值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">1.  properties: &#123;  </span><br><span class="line">2.  // 弹窗标题  </span><br><span class="line">3.  currentpage: &#123;            // 属性名  </span><br><span class="line">4.  type: String,     // 类型（必填），目前接受的类型包括：String, Number, Boolean, Object, Array, null（表示任意类型）  </span><br><span class="line">5.  value: &apos;index&apos;     // 属性初始值（可选），如果未指定则会根据类型选择一个 </span><br><span class="line">6.  &#125; </span><br><span class="line">7.  &#125;</span><br></pre></td></tr></table></figure>

<p>子组件向父组件通信和vue也很类似，代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">1.  //子组件中  </span><br><span class="line">2.  methods: &#123;     </span><br><span class="line">3.  // 传递给父组件  </span><br><span class="line">4.  cancelBut: function (e) &#123;  </span><br><span class="line">5.  var that = this;  </span><br><span class="line">6.  var myEventDetail = &#123; pickerShow: false, type: &apos;cancel&apos; &#125; // detail对象，提供给事件监听函数  </span><br><span class="line">7.  this.triggerEvent(&apos;myevent&apos;, myEventDetail) //myevent自定义名称事件，父组件中使用  </span><br><span class="line">8.  &#125;, </span><br><span class="line">9.  &#125;  </span><br><span class="line">10.  //父组件中  </span><br><span class="line">11.  &lt;bar bind:myevent=&quot;toggleToast&quot;&gt;&lt;/bar&gt;   </span><br><span class="line">12.  // 获取子组件信息  </span><br><span class="line">13.  toggleToast(e)&#123;  </span><br><span class="line">14.  console.log(e.detail)  </span><br><span class="line">15.  &#125;</span><br></pre></td></tr></table></figure>

<p>如果父组件想要调用子组件的方法</p>
<p>vue会给子组件添加一个ref属性，通过this.$refs.ref的值便可以获取到该子组件，然后便可以调用子组件中的任意方法，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">1.  //子组件  </span><br><span class="line">2.  &lt;bar ref=&quot;bar&quot;&gt;&lt;/bar&gt;  </span><br><span class="line">3.  //父组件  </span><br><span class="line">4.  this.$ref.bar.子组件的方法</span><br></pre></td></tr></table></figure>

<p>小程序是给子组件添加id或者class，然后通过this.selectComponent找到子组件，然后再调用子组件的方法,示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">1.  //子组件  </span><br><span class="line">2.  &lt;bar id=&quot;bar&quot;&gt;&lt;/bar&gt;  </span><br><span class="line">3.  // 父组件  </span><br><span class="line">4.  this.selectComponent(&apos;#id&apos;).syaHello()</span><br></pre></td></tr></table></figure>

<p>小程序和vue在这点上太相似了…</p>
<hr>
<p>这些都是我们常用到的知识点，还有不足，以后慢慢改善~~！</p>
<p><a href="https://segmentfault.com/a/1190000015684864" target="_blank" rel="noopener">原文地址</a></p>
]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
</search>
